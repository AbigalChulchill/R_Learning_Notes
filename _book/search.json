[{"path":"index.html","id":"序言","chapter":"序言","heading":"序言","text":"rather discover one true cause gain kingdom Persia.— Democritus本筆記為多本 R 語言書籍內容之抄錄、摘要與重新編排，僅作為學習筆記之用，版權仍歸作者所有，並以 R 套件 knitr (Xie 2017) 與 bookdown (Xie 2016) 編譯而成。","code":""},{"path":"rlang.html","id":"rlang","chapter":"1 R 資料結構","heading":"1 R 資料結構","text":"本章為 Zamora Saiz et al. (2020) 節 2.2 內容。","code":""},{"path":"rlang.html","id":"變數與基本的運算","chapter":"1 R 資料結構","heading":"1.1 變數與基本的運算","text":"以下分別是「加」、「減」、「乘」、「除」、「餘數除法」、與「整數除法」：我們可以 <- 來指派值給變數：最基本的資料型態有三種：numeric、character 與 logical。numeric 即數字，character 即字串而 logical 即布林值 TRUE 或 FALSE。此外，使用 .integer() 可以把 numeric 轉成型態 integer，1也另有複數為型態 complex。而我們可以使用 class() 來查看變數的資料型態，如：我們也可以使用科學記號代表很大的數，如：Logical value 也可以進行運算，其中 TRUE 代表 1，而 FALSE 代表 0，如：此外，還有兩種特殊的資料型態：NULL 與 NA。當我們指派一個 NULL 給一個變數時，會讓其變成一個空的物件。而 NA 的意思是 non-available，常常表示 missing data。但特別的是用 class() 檢視為 NA 的變數時會發現其為一 logical value。NA 運算後也會產生 NA：","code":"\n3 + 4\n3 - 4\n3 * 4\n3 / 4\n15 %% 2  # get \"1\"\n15 %/% 2  # get \"7\"\nx <- 3 * 4\ny <- 4 * 20\nz <- x + y\nz  # get \"92\"\nGPA <- 4.3\nclass(GPA)  # get \"'numeric'\"\n\nword <- \"GPA\"\nclass(word)  # get \"'character'\"\n\nyes.no <- TRUE\nclass(yes.no)  # get \"'logical'\"\n\nGTA <- as.integer(5)\nclass(GTA)  # get \"'integer'\"\n\ncomplex.number <- 2 + 5i\nclass(complex.number)  # get \"'complex'\"\n\nas.integer(TRUE)\n2.35e7  # get \"23500000\"\nTRUE + TRUE  # get \"2\"\nTRUE + FALSE  # get \"1\"\nTRUE * FALSE  # get \"0\"\nFALSE * FALSE  # get \"0\"\nnull.object <- NULL\nnull.object  # get \"NULL\"\nclass(null.object)  # get \"'NULL'\"\nmissing <- NA\nmissing  # get \"NA\"\nclass(missing)  # get \"'NA'\"\n1 + NA  # get \"NA\"\nTRUE - NA  # get \"NA\""},{"path":"rlang.html","id":"向量","chapter":"1 R 資料結構","heading":"1.2 向量","text":"向量（vector）是一列元素。我們以 c() 可以創造向量，裡頭的元素可以是 numeric、character 或 logical 其中一種，或者混合，而之間須以逗號分隔；我們可以用 length() 來得知向量的長度；如果裡頭的元素都是 numeric、character 或 logical 其中一種，則該向量的型態即其元素的型態，如：但如果是向量內有不同種類的元素，那麼 R 會去讓向量裡的元素的型態變得更「一般」，即 character 優先於 numeric 又優先於 logical，就連 NA 都能被變成其他型態，如：","code":"\nvector.numbers <- c(1, 2, 3, 4)\nvector.numbers  # get \"1 2 3 4\"\nlength(vector.numbers)  # \"4\"\nclass(vector.numbers)  # get \"'numeric'\"\n\nvector.characters <- c(\"R\", \"is\", \"cool\") \nvector.characters  # get \"'R'    'is'   'cool'\"\nclass(vector.characters)  # get \"'character'\"\n\nvector.logicals <- c(TRUE, FALSE)\nvector.logicals  # get \"TRUE FALSE\"\nclass(vector.logicals)  # get \"'logical'\"\nc(\"I\", \"am\", 1)  # get \"'I'  'am' '1'\"\nclass(c(\"I\", \"am\", 1))  # get \"'character'\"\n\nc(\"He\", \"is\", \"the\", TRUE)  # get \"'He'   'is'   'the'  'TRUE'\"\nclass(c(\"He\", \"is\", \"the\", TRUE))  # get \"'character'\"\n\nc(1, FALSE)  # get \"1 0\"\nclass(c(1, FALSE))  # get \"'numeric'\"\n\nc(NA, \"1\")  # get \"NA  '1'\"\nclass(c(NA, \"1\"))  # get \"'character'\"\n\nc(NA, TRUE)  # get \"NA  TRUE\"\nclass(c(NA, TRUE))  # get \"'logical'\""},{"path":"rlang.html","id":"創造向量的其他方法","chapter":"1 R 資料結構","heading":"1.2.1 創造向量的其他方法","text":"如果我們要創造一個連續的向量，可以使用 :b，如：如果我們想要重複（repeat）某個數字或某群數字好幾遍，可以使用 rep()，例如：或者，我們可以在第二個 argument 丟入一個向量，指定第一個 argument 的個別的向量分別要重覆幾次，但這時候會長得像在第二個 argument 丟入 = 的樣子，如：我們也可以在第二個 argument 丟入一個 length.=，這會使第一個 argument 的向量重複，而直到長度與 length.= 的值相當，如：除了手動輸入、使用 :b 或者以 rep() 的方式產生向量，我們還可以使用 seq()，這可以創造出一個數列。seq() 有三個引數，第一個引數為起始值，第二個引數為結束值，第三個引述則為公差，如：","code":"\n3:12  # get \"3  4  5  6  7  8  9 10 11 12\"\nclass(3:12)  # get \"'numeric'\"\nrep(c(3, -1, 0.5), 3)  # get \"3.0 -1.0  0.5  3.0 -1.0  0.5  3.0 -1.0  0.5\"\nrep(c(3, -1, 0.5), times=3)  # get \"3.0 -1.0  0.5  3.0 -1.0  0.5  3.0 -1.0  0.5\"\n# 所以第二個 argument 預設是整串重複幾次的意思\n# 但也能改成個別重複幾次，如下：\nrep(c(3, -1, 0.5), each=3)  # get \"3.0  3.0  3.0 -1.0 -1.0 -1.0  0.5  0.5  0.5\"\nrep(c(3, -1, 0.5), times=c(2, 1, 3)) # get \"3.0  3.0 -1.0  0.5  0.5  0.5\"\nrep(c(3, -1, 0.5), length.out=8)  # get \"3.0 -1.0  0.5  3.0 -1.0  0.5  3.0 -1.0\"\nseq(0, 10, 2.5)  # get \"0.0  2.5  5.0  7.5 10.0\"\nseq(0, 10, 2.3)  # get \"0.0 2.3 4.6 6.9 9.2\""},{"path":"rlang.html","id":"標籤","chapter":"1 R 資料結構","heading":"1.2.2 標籤","text":"只要創建了向量，裡頭的元素就能以 name() 命名。在我們要指出向量中的特定元素時還蠻有用的。此功能也有點像 Python 裡頭的字典，如：這時候，ouput 就不會有 [1] 了，而是變成結構性的帶有標籤的向量。此外，如果要新增一個有同樣多座標且標籤順序一致的向量，有兩種方法。第一種方法是直接把 names(標籤向量) 指派給 names(欲標籤的向量)，這樣會把前者的標籤貼到後者身上；或者，我們還是可以仿效原先的做法，再新創一個同等長度的字串向量，然後輸入 names(欲標籤的向量)，如下：","code":"\ntemperatures <- c(28, 29, 27, 27, 30)\nnames(temperatures) <- c(\"Monday\", \"Tuesday\", \"Wednesday\",\n\"Thursday\", \"Friday\")\ntemperatures##    Monday   Tuesday Wednesday  Thursday    Friday \n##        28        29        27        27        30\n# Method 1\nrains <- c(0, 5, 6, 0, 2)\nnames(rains) <- names(temperatures)\nrains##    Monday   Tuesday Wednesday  Thursday    Friday \n##         0         5         6         0         2\n# Method 2\nrains <- rep(NULL, 5)  # 先清空剛剛指派的 named num [1:5]\nrains <- c(0, 5, 6, 0, 2)\ndays <- c(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\")\nnames(rains) <- days\nrains##    Monday   Tuesday Wednesday  Thursday    Friday \n##         0         5         6         0         2"},{"path":"rlang.html","id":"vectcalc","chapter":"1 R 資料結構","heading":"1.2.3 向量的運算","text":"而如果我們想要把向量中的每個數字都加上另一個數字，只要直接把兩個物件相加就行了（雖然這違反了數學邏輯的公理）；如果要把向量中的每個數字都乘上某個數字也是同理，如攝氏溫標轉換成凱式溫標與華氏溫標：減、除、次方也是類似的道理。此外，sum() 可以將所有向量的座標加總，如：","code":"\n# Kelvin degrees\nKtemp <- temperatures + 273.15\nKtemp##    Monday   Tuesday Wednesday  Thursday    Friday \n##    301.15    302.15    300.15    300.15    303.15\n# Fahrenheit degrees\nFtemp <- temperatures * 1.8 + 32\nFtemp##    Monday   Tuesday Wednesday  Thursday    Friday \n##      82.4      84.2      80.6      80.6      86.0\ntotal.rains <- sum(rains)\ntotal.rains  # get \"13\""},{"path":"rlang.html","id":"accesselements","chapter":"1 R 資料結構","heading":"1.2.4 存取向量中的元素","text":"在 R 語言中，第一個位置是 1（而不像有些語言是從 0 開始），並依序下去。如果我們要存取一個向量中的元素，可以直接指定向量中的位置；若要存取多個元素，就要使用 變數[c(想指定的位置)]；存取連續的位置則依然可以使用 :b；當然也可以丟等差數列 seq() 進去，如：除了以位置來存取，當然也可以標籤來存取向量中的元素，如：","code":"\n# 存取一個元素\nrains[2]## Tuesday \n##       5\n# 存取多個元素\nrains[c(2, 5)]## Tuesday  Friday \n##       5       2\n# 存取連續的元素\nrains[2: 5]##   Tuesday Wednesday  Thursday    Friday \n##         5         6         0         2\n# 等差地存取元素\nrains[seq(1, 5, 2)]##    Monday Wednesday    Friday \n##         0         6         2\nrains[c(\"Monday\", \"Tuesday\")]##  Monday Tuesday \n##       0       5"},{"path":"rlang.html","id":"關係","chapter":"1 R 資料結構","heading":"1.2.5 關係","text":"<：小於。>：大於。<=：小於或等於。>=：大於或等於。==：相等。!=：不相等。在兩個值之間加入這些關係符號，會輸出一個布林值，描述兩者的關係是否符合輸入的關係，如：向量也能與一個數字比較，此時會依據向量裡頭的位置順序，連帶著標籤（如果有的話），輸出各個座標的布林值，如：也能考慮多重的關係。& 代表的是「且」（），而 | 代表的是「或」（），而函數 xor() 在其中一者為真一者為假時會回傳真，在兩者皆真或皆假的情況會回傳假，如：我們可以運用這些比較關係來確認向量裡頭的元素是否符合某個性質。例如是否下雨、是否溫度高於某個給定的溫度，即：還可以用剛剛新建的向量，來存取原先向量中的位置，如：此外，我們可以透過兩個函數來一次檢查向量中的元素與某個性質之間的關係，即 () 與 ()。前者在都有滿足的情況下就會回傳 TRUE，反之則回傳 FALSE；後者在其中一個座標有滿足的情況下就會回傳 TRUE，反之則回傳 FALSE。例如以下分別為「如果所有日子氣溫都大於等於 28 度則回傳 TRUE」與「如果其中一天氣溫恰等於 30 度則回傳 TRUE」，即：另外，() 則可以找到滿足條件的位置，即回傳為 TRUE 的位置的標籤與索引值，如找出溫度恰等於 27 度的日子：","code":"\n4 > 3  # get \"TRUE\"\n4 != 4  # get \"FALSE\"\nrains > 0##    Monday   Tuesday Wednesday  Thursday    Friday \n##     FALSE      TRUE      TRUE     FALSE      TRUE\n3 == 4 & 3 == 3  # get \"FALSE\"\n3 == 4 | 3 == 3  # get \"TRUE\"\n3 < 5 & 4 > 2  # get \"TRUE\"\nTRUE & TRUE & FALSE  # get \"FALSE\"\nxor(3 > 2, FALSE)  # get \"TRUE\"\nxor(3 > 2, TRUE)  # get \"FALSE\"\nxor(3 < 2, FALSE)  # get \"FALSE\"\n# 沒下雨的日子\nnot.rainy.days <- rains == 0\nnot.rainy.days##    Monday   Tuesday Wednesday  Thursday    Friday \n##      TRUE     FALSE     FALSE      TRUE     FALSE\n# 炎熱的日子\nhot.days <- temperatures >= 29\nhot.days##    Monday   Tuesday Wednesday  Thursday    Friday \n##     FALSE      TRUE     FALSE     FALSE      TRUE\n# 在 hot.days 中，Tues. 與 Fri. 是真\n# 所以 rains 中 Tues. 與 Fri. 標籤的位置的標籤與值會被叫出來\nrains[hot.days]## Tuesday  Friday \n##       5       2\nall(temperatures >= 28)  # get \"FALSE\"\nany(temperatures >= 30)  # get \"TRUE\"\nwhich(temperatures == 27)## Wednesday  Thursday \n##         3         4"},{"path":"rlang.html","id":"排序","chapter":"1 R 資料結構","heading":"1.2.6 排序","text":"我們可以使用 order()，其引數為一個向量，而此函數會回傳此向量中的元素的索引值為一個向量，由原向量的元素由小到大排列。如下，order(.vector) 回傳的向量的第一個元素為 5，這意味著原先的向量中最小的元素 2 其索引值為 5，而次小的元素 3 其索引值為 1，依此類推，最大的元素 9 其索引值為 3：所以，將 order(.vector) 作為 .veector[] 的引數（回憶節 1.2.4），我們可以由小到大重新排列向量，即回傳一個向量，其第一個元素為原向量索引值 5 的元素，其值為 2，依此類推，如：不過要把向量由小排到大也可以使用 sort() 就是了。此操作不會改變原本的向量的排序，但會回傳排序後的向量。不過與上面的方法不同的是，此方法無法知道這些值原先在什麼位置：","code":"\nsome.vector <- c(3, 7, 9, 6, 2, 8)\norder(some.vector)## [1] 5 1 4 2 6 3\nsome.vector[order(some.vector)]## [1] 2 3 6 7 8 9\nsome.vector <- c(3, 7, 9, 6, 2, 8)\nsort(some.vector)## [1] 2 3 6 7 8 9"},{"path":"rlang.html","id":"其他操作","chapter":"1 R 資料結構","heading":"1.2.7 其他操作","text":"我們可以使用 sum() 將向量的所有元素的值加總；max() 與 min() 則分別會回傳其中最大與最小的值；range() 則將回傳向量中的元素的範圍（即同時回傳 min() 與 max()）；mean() 可以計算向量的算術平均，如：結合 ()（回傳為 TRUE 的位置的標籤與索引值）與 max()（找到氣溫最高的值），就可以找到氣溫最高的日子的標籤與索引值，如：","code":"\nsum(some.vector)  # get \"35\"\nmax(some.vector)  # get \"9\"\nmin(some.vector)  # get \"2\"\nrange(some.vector)  # get \"2 9\"\nmean(some.vector)  # get \"5.833333\"\ntemperatures##    Monday   Tuesday Wednesday  Thursday    Friday \n##        28        29        27        27        30\nwhich(temperatures == min(temperatures))## Wednesday  Thursday \n##         3         4\nmax(temperatures)## [1] 30"},{"path":"rlang.html","id":"矩陣","chapter":"1 R 資料結構","heading":"1.3 矩陣","text":"","code":""},{"path":"rlang.html","id":"創建矩陣","chapter":"1 R 資料結構","heading":"1.3.1 創建矩陣","text":"我們可以用 matrix() 來創建矩陣，其語法為：其中，data 為我們要放進矩陣的向量資料；nrow 為 row 的數量；ncol 為 column 的數量；byrow 為以 column 或 row 的方式填滿矩陣（預設為 FALSE，即以 column 的方式填滿矩陣）；dimnames 則可以添加一個 list 為 row 與 column 的名字到矩陣（見節 1.6）。對於 byrow 的用法如下兩個例子：而如果我們以向量的資料填滿矩陣，只要丟入 nrow 或 ncol 其中一者的引數即可，R 會根據資料的長度，算出 column 或 row 該要是多少。但如果向量資料的長度無法非 nrow 或 ncol，就會出現 Warning。但 R 還是會像資料長度為 nrow 或 ncol 的因數的情況一樣，從頭開始以原本的向量把矩陣給填滿，如：矩陣也可以放以 character 或 logical 組成的向量資料，如：我們可以 rownames() 與 colnames 為 row 與 column 加上名字，使用方法如：我們可以透過 dim(想得知的矩陣) 得知 row 與 column 的數量，如：","code":"\nmatrix(data = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL)\nmatrix(1:6, nrow = 2, byrow = TRUE)##      [,1] [,2] [,3]\n## [1,]    1    2    3\n## [2,]    4    5    6\nmatrix(1:6, nrow = 2, byrow = FALSE)  # default argument##      [,1] [,2] [,3]\n## [1,]    1    3    5\n## [2,]    2    4    6\nmatrix(1:11, nrow = 3)## Warning in matrix(1:11, nrow = 3): data length [11] is not a sub-multiple or\n## multiple of the number of rows [3]##      [,1] [,2] [,3] [,4]\n## [1,]    1    4    7   10\n## [2,]    2    5    8   11\n## [3,]    3    6    9    1\nmatrix(c(\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"), nrow = 4)##      [,1]       [,2]     [,3]       \n## [1,] \"January\"  \"May\"    \"September\"\n## [2,] \"February\" \"June\"   \"October\"  \n## [3,] \"March\"    \"July\"   \"November\" \n## [4,] \"April\"    \"August\" \"December\"\nmatrix(c(TRUE, FALSE, TRUE, TRUE, FALSE, FALSE), nrow = 2)##       [,1] [,2]  [,3]\n## [1,]  TRUE TRUE FALSE\n## [2,] FALSE TRUE FALSE\nclimate <- matrix(c(temperatures, rains), byrow = TRUE, nrow = 2)\nrownames(climate) <- c(\"Temperatures\", \"Rains\")\ncolnames(climate) <- days\nclimate##              Monday Tuesday Wednesday Thursday Friday\n## Temperatures     28      29        27       27     30\n## Rains             0       5         6        0      2\ndim(climate)  # get \"2 5\""},{"path":"rlang.html","id":"合併矩陣與矩陣運算","chapter":"1 R 資料結構","heading":"1.3.2 合併矩陣與矩陣運算","text":"我們可以透過 rbinds() 與 cbinds() 在矩陣新增 row 或 column，如：我們可以使用 rowSums() 或 colSums() 把各個 row 或 column 的值加起來。把各個 row 的值相加以後指派給變數 totals，然後與原先的 climate 合併，就如：","code":"\nWinds <- c(30, 25, 22, 24, 18)\ntotal.climate <- rbind(climate, Winds)\ntotal.climate##              Monday Tuesday Wednesday Thursday Friday\n## Temperatures     28      29        27       27     30\n## Rains             0       5         6        0      2\n## Winds            30      25        22       24     18\ntotals <- rowSums(total.climate)\ncbind(total.climate, totals)##              Monday Tuesday Wednesday Thursday Friday totals\n## Temperatures     28      29        27       27     30    141\n## Rains             0       5         6        0      2     13\n## Winds            30      25        22       24     18    119"},{"path":"rlang.html","id":"存取矩陣中的元素","chapter":"1 R 資料結構","heading":"1.3.3 存取矩陣中的元素","text":"存取矩陣的方式與向量類似，即 矩陣[row, col]，如：如果不輸入 row 的引數，則會列出該 column 所有的資料，如下列出了週三的氣溫、雨量及風速：如果不輸入 column 的引數，則會列出該 row 所有的資料，如下列出了每日的雨量：另外，也可以直接指定某個 row 或 column 的名字來存取資料，如：","code":"\ntotal.climate[2, 3]  # get \"6\"\ntotal.climate[, 3]## Temperatures        Rains        Winds \n##           27            6           22\ntotal.climate[2, ]##    Monday   Tuesday Wednesday  Thursday    Friday \n##         0         5         6         0         2\ntotal.climate[, \"Wednesday\"]## Temperatures        Rains        Winds \n##           27            6           22\ntotal.climate[\"Rains\",]##    Monday   Tuesday Wednesday  Thursday    Friday \n##         0         5         6         0         2\ntotal.climate[\"Rains\", \"Wednesday\"]## [1] 6"},{"path":"rlang.html","id":"矩陣的運算","chapter":"1 R 資料結構","heading":"1.3.4 矩陣的運算","text":"我們可以用 mean() 計算向量的算術平均，我們也能以此計算矩陣的 column 或 row 的算術平均。例如想要計算每天的平均氣溫，可以如下：矩陣也能像向量一般運算（回憶節 1.2.3），如：","code":"\nmean(total.climate[\"Temperatures\", ])## [1] 28.2\nclimate * 2##              Monday Tuesday Wednesday Thursday Friday\n## Temperatures     56      58        54       54     60\n## Rains             0      10        12        0      4\nclimate ^ 2##              Monday Tuesday Wednesday Thursday Friday\n## Temperatures    784     841       729      729    900\n## Rains             0      25        36        0      4\n# 計算雨量與氣溫的比例\nclimate[2, ] / climate[1, ]##     Monday    Tuesday  Wednesday   Thursday     Friday \n## 0.00000000 0.17241379 0.22222222 0.00000000 0.06666667"},{"path":"rlang.html","id":"factors","chapter":"1 R 資料結構","heading":"1.4 Factors","text":"質性或類別變數（qualitative categorical variable）的值即類別，而非數值。把向量丟到 factor() 中可以把向量轉換成 factor。創建一個向量 sizes，如：但這時候如果用 summary()，我們只看得到資料長度和他們的類別：此時，把向量丟到 fator() 中將會回傳不太一樣的結果，並且 summary() 將會回傳各個值出現的次數；levels() 則會回傳此 factor vector 中有哪些元素（重複的不計），如：類別變數可以分為無序（nominal）與有序（ordinal）兩種。前者如顏色，後者如尺寸。如果要讓變數是有序的，我們在 factor() 中須將引數 ordered 設置為 TRUE，並且以引數 levels = 向量 由小到大地來描述順序關係，如：我們也可以把向量指派給 level(目標 factor)，來覆寫 factor 中的值，如：無序的 factor 的元素無法比較，但有序的可以，如：","code":"\nsizes <- c(\"Small\", \"Big\", \"Big\", \"Medium\", \"Medium\", \"Small\", \"Medium\", \"Small\", \"Small\")\nsizes## [1] \"Small\"  \"Big\"    \"Big\"    \"Medium\" \"Medium\" \"Small\"  \"Medium\" \"Small\" \n## [9] \"Small\"\nsummary(sizes)##    Length     Class      Mode \n##         9 character character\nfactor.sizes <- factor(sizes)\nfactor.sizes## [1] Small  Big    Big    Medium Medium Small  Medium Small  Small \n## Levels: Big Medium Small\nsummary(factor.sizes)##    Big Medium  Small \n##      2      3      4\nlevels(factor.sizes)## [1] \"Big\"    \"Medium\" \"Small\"\nsizes2 <- c(\"Small\", \"Big\", \"Big\", \"Medium\", \"Medium\", \"Small\", \"Medium\", \"Small\", \"Small\")\nfactor.sizes2 <- factor(sizes, ordered=TRUE, levels=c(\"Small\", \"Medium\", \"Big\"))\nfactor.sizes2## [1] Small  Big    Big    Medium Medium Small  Medium Small  Small \n## Levels: Small < Medium < Big\nsurvey.vector <- c(\"M\", \"F\", \"F\", \"M\", \"M\", \"F\", \"M\", \"M\") \nfactor.survey.vector <- factor(survey.vector)\n# 此時儲存的順序是 \"F M\"，因此可以 c(\"Female\", \"Male\") 覆寫之\nlevels(factor.survey.vector) <- c(\"Female\", \"Male\")\nfactor.survey.vector## [1] Male   Female Female Male   Male   Female Male   Male  \n## Levels: Female Male\nfactor.sizes2[1] < factor.sizes2[2]  # get \"TRUE\"\nfactor.sizes2[2] == factor.sizes2[2]  # get \"TRUE\"\nfactor.sizes2[2] != factor.sizes2[3]  # get \"FALSE\""},{"path":"rlang.html","id":"data-frames","chapter":"1 R 資料結構","heading":"1.5 Data Frames","text":"在 vectors 與 matrices 中，資料都會儲存成一樣的型態。但進行資料分析時，我們會同時處理不同型態的資料。此時我們需要 data frames 來儲存資料表。與矩陣不同的是， data frames 可以儲存不同型態的資料。R 有內置的 datasets，可以使用以下指令查看其資訊：我們也可以使用 data() 查看電腦內現有的 datasets。我們可以使用其中一個現成的 dataset OrchardSprays。輸入 OrchardSprays 可以查看整個表。我們可以發現有四個變數，分別是 decrease、rowpos、colpos 與 treatmenet。decrease 為對處置的反應，以數值記載；rowpos 與 colpos 分別代表其 design 的 row 與 column；treatment 則為 至 H 的類別變數。以 head(OrchardSprays) 可以查看表格的前六個 rows。以 str() 可以獲知表格的資訊，如：我們可以用 dataframe() 來創建 data frames。其中的引數放入向量，而依序構成該 data frames 的各個 columns，如：","code":"\n?datasets\nlibrary(help=\"datasets\")\nstr(OrchardSprays)## 'data.frame':    64 obs. of  4 variables:\n##  $ decrease : num  57 95 8 69 92 90 15 2 84 6 ...\n##  $ rowpos   : num  1 2 3 4 5 6 7 8 1 2 ...\n##  $ colpos   : num  1 1 1 1 1 1 1 1 2 2 ...\n##  $ treatment: Factor w/ 8 levels \"A\",\"B\",\"C\",\"D\",..: 4 5 2 8 7 6 3 1 3 2 ...\nname <- c(\"Alfonso\", \"Carlos\", \"Lluis\", \"Diego\")\nlast.name <- c(\"Zamora\", \"Quesada\", \"Hurtado\", \"Mondejar\")\nsecond.last.name <- c(\"Saiz\", \"Gonzalez\", \"Gil\", \"Ruiz\")\nage <- c(33, 32, 30, 37)\nphd <- c(\"math\", \"math\", \"physics\", \"math\")\noffice <- c(4, 14, 6, 8)\nfrom.madrid <- c(FALSE, TRUE, FALSE, TRUE)\nprofessors <- data.frame(name, last.name, second.last.name, age, phd, office, from.madrid)\nstr(professors)## 'data.frame':    4 obs. of  7 variables:\n##  $ name            : chr  \"Alfonso\" \"Carlos\" \"Lluis\" \"Diego\"\n##  $ last.name       : chr  \"Zamora\" \"Quesada\" \"Hurtado\" \"Mondejar\"\n##  $ second.last.name: chr  \"Saiz\" \"Gonzalez\" \"Gil\" \"Ruiz\"\n##  $ age             : num  33 32 30 37\n##  $ phd             : chr  \"math\" \"math\" \"physics\" \"math\"\n##  $ office          : num  4 14 6 8\n##  $ from.madrid     : logi  FALSE TRUE FALSE TRUE"},{"path":"rlang.html","id":"dataframesubsetting","chapter":"1 R 資料結構","heading":"1.5.1 存取 data frames 中的元素與 subset","text":"想要選取 data frames 中的元素，就像選取矩陣中的元素一樣，即 dataframes[row, col]，如：要注意的是，data frames 的 column 的名字是來自 column vector 的名字，所以我們也可以用 $ 來存取特定的 column vector，如：我們還可以用 logical 的方式來叫出 data frames 的 subset，例如要叫出 .madrid 為 TRUE 的兩個 rows，即：以指令 subset(data_frame, subset=logical_condition) 也能做到類似的事，如：","code":"\nprofessors[2, 3]\nprofessors[1, ]  # 顯示第一個 row\nprofessors[, 2]  # 顯示第二個 column\nprofessors[1 : 2, ]  # 選擇頭兩個 rows\nprofessors$phd## [1] \"math\"    \"math\"    \"physics\" \"math\"\nprofessors$phd[3]## [1] \"physics\"\nmadrileans <- professors$from.madrid\nprofessors[madrileans, ]##     name last.name second.last.name age  phd office from.madrid\n## 2 Carlos   Quesada         Gonzalez  32 math     14        TRUE\n## 4  Diego  Mondejar             Ruiz  37 math      8        TRUE\nsubset(professors, subset=age > 31)##      name last.name second.last.name age  phd office from.madrid\n## 1 Alfonso    Zamora             Saiz  33 math      4       FALSE\n## 2  Carlos   Quesada         Gonzalez  32 math     14        TRUE\n## 4   Diego  Mondejar             Ruiz  37 math      8        TRUE\nsubset(professors, subset=phd == \"math\")##      name last.name second.last.name age  phd office from.madrid\n## 1 Alfonso    Zamora             Saiz  33 math      4       FALSE\n## 2  Carlos   Quesada         Gonzalez  32 math     14        TRUE\n## 4   Diego  Mondejar             Ruiz  37 math      8        TRUE"},{"path":"rlang.html","id":"dataframeordering","chapter":"1 R 資料結構","heading":"1.5.2 排序","text":"想要以某個特定的變數的順序整理 data frames，可以使用 order()，如：","code":"\npositions <- order(professors$age)\nprofessors[positions, ]##      name last.name second.last.name age     phd office from.madrid\n## 3   Lluis   Hurtado              Gil  30 physics      6       FALSE\n## 2  Carlos   Quesada         Gonzalez  32    math     14        TRUE\n## 1 Alfonso    Zamora             Saiz  33    math      4       FALSE\n## 4   Diego  Mondejar             Ruiz  37    math      8        TRUE"},{"path":"rlang.html","id":"其他操作-1","chapter":"1 R 資料結構","heading":"1.5.3 其他操作","text":"我們可以 .data.frame() 把矩陣轉為 data frames。","code":""},{"path":"rlang.html","id":"lists","chapter":"1 R 資料結構","heading":"1.6 Lists","text":"Lists 就像向量，但其元素可以有不同的長度、大小、型態。我們可以用 list() 創建 lists，如：我們也可以選取 lists 中的元素，如：我們也可以為 list 中的元素命名，如將第一個元素命名為 .days、第二個元素命名為 .factors、將第三個元素命名為 .data：這樣就可以用 $名字 來存取 list 中的元素，如：如果要新增元素到 list，可以 list_name[[\"名字\"]] <- 要輸入的物件 指令，其中名字當然是選擇性的，也能空下來；此外，如果要刪除 list 中的成份，只要指派 NULL 給它就行，如：我們也可以用 str() 來查看 lists 的資訊，如：","code":"\nnew.list <- list(days, factor.sizes, climate)\nnew.list## [[1]]\n## [1] \"Monday\"    \"Tuesday\"   \"Wednesday\" \"Thursday\"  \"Friday\"   \n## \n## [[2]]\n## [1] Small  Big    Big    Medium Medium Small  Medium Small  Small \n## Levels: Big Medium Small\n## \n## [[3]]\n##              Monday Tuesday Wednesday Thursday Friday\n## Temperatures     28      29        27       27     30\n## Rains             0       5         6        0      2\nnew.list[1]  # 第一個元素\nnew.list[[1]][3]  # 第一個元素中的第三個元素\nnew.list[[3]][1, 2:5]  # 第三個元素中的第一個 row 的第二至五個的元素\nnew.list <- list(the.days=days, the.factors=factor.sizes, the.data=climate)\nnew.list## $the.days\n## [1] \"Monday\"    \"Tuesday\"   \"Wednesday\" \"Thursday\"  \"Friday\"   \n## \n## $the.factors\n## [1] Small  Big    Big    Medium Medium Small  Medium Small  Small \n## Levels: Big Medium Small\n## \n## $the.data\n##              Monday Tuesday Wednesday Thursday Friday\n## Temperatures     28      29        27       27     30\n## Rains             0       5         6        0      2\nnew.list$the.factors\nnew.list$the.data[2, 5]\nnew.list[\"the.data\"]\nnew.list[[\"professors\"]] <- professors  # 新增第四個元素，名為 \"professors\" 的 data frames\nnew.list[[\"\"]] <- positions  # 新增第五個元素，無名的向量\nnew.list[[5]] <- NULL  # 刪除第五個元素\nnew.list[[\"professors\"]] <- NULL  # 刪除名為 \"professors\" 的元素\nstr(new.list)"},{"path":"control.html","id":"control","chapter":"2 控制結構與函數","heading":"2 控制結構與函數","text":"本章為 Zamora Saiz et al. (2020) 節 2.3 與 2.4 內容。","code":""},{"path":"control.html","id":"conditionals","chapter":"2 控制結構與函數","heading":"2.1 Conditionals","text":"條件句的語法如下：例如：如果我們希望在條件沒有滿足時執行其他動作，就得使用 else，其語法如：例如：上述的 codes 其實在邏輯上是正確的，但顯然與我們希望電腦能做的事有落差（\\(x=0\\) 非正也非負才對）。所以，如果有好幾個條件要確認，也能多用幾個 else blocks，如：不過，要注意的是上述的結構在 R 的運行速度較慢，不如以 ifelse() 函數，把上述的結構寫成一行，其語法即：前開判別變數為正或負的條件結構也能寫成：只要在向量使用 binary operator，同樣的條件就也可以被確認多次。例如如果要確認向量中的元素是否小於 5，我們可以寫成：","code":"\nif (\"condition is satisfied\") {\n  \"do something\"\n}\nx <- 3\nif (x > 0) {\n  print(\"Positive\")\n}## [1] \"Positive\"\nif (\"condition is satisfied\"){ \n  \"do something\"\n} else {\n  \"otherwise do something else\"\n}\nx <- 0\nif (x > 0) {\n  print(\"Positive\")\n} else {\n  print(\"Negative\")\n}\nx <- 0\nif (x > 0) {\n  print(\"Positive\")\n} else if (x < 0) {\n  print(\"Negative\")\n} else {\n  print(\"Zero\")\n}\nifelse(\"condition\", \"task if TRUE\", \"task if FALSE\")\nx <- 9\nifelse(x > 0, \"Positive\", \"Negative\")## [1] \"Positive\"\nifelse((1 : 10) < 5, \"Fail\", \"Pass\")##  [1] \"Fail\" \"Fail\" \"Fail\" \"Fail\" \"Pass\" \"Pass\" \"Pass\" \"Pass\" \"Pass\" \"Pass\""},{"path":"control.html","id":"loops","chapter":"2 控制結構與函數","heading":"2.2 Loops","text":"用於重複次數預先指定的時候，則反之，將持續運行直到條件無法滿足。","code":""},{"path":"control.html","id":"for-迴圈","chapter":"2 控制結構與函數","heading":"2.2.1 for 迴圈","text":"迴圈的語法為：例如印出 1–10 可以如此：因為 [1] 出現了十次，我們可知這段程式碼有十次輸出，每次輸出包含一個 row，顯然這是 print() 運行十次的結果。在此迴圈中，每次執行都會使 的值增加，所以如果我們此時在 console 輸入 ，將會回傳 10，顯示 作為一個變數，其值已經變成 10 了。那如果我們要把連續的整數和存成一個向量該怎麼做呢？其中，s 的作用就是在迴圈結束後儲存剛剛的結果，以便與下一個數相加。如此，可以依序將 \\(1\\)、\\(1+2\\)、\\(1+2+3\\)、\\(\\cdots{}\\)、\\(1+\\cdots{}+10\\) 存到向量 v 並印出。以下還有幾個 迴圈運作的簡單範例。例如印出 1–19 的奇數，可以：我們也可以把 迴圈與 條件句結合，要把某個向量中低於某個數字的元素印出 FAIL，如：","code":"for (\"counter\" in \"vector of indices\") { \n  \"do something\"\n}\nfor (i in 1 : 10) {\n  print(i)\n}## [1] 1\n## [1] 2\n## [1] 3\n## [1] 4\n## [1] 5\n## [1] 6\n## [1] 7\n## [1] 8\n## [1] 9\n## [1] 10\nv <- c()\n\ns <- 0\nfor (i in 1 : 10) {\n  s <- s + i\n  v[i] <- s\n}\nv##  [1]  1  3  6 10 15 21 28 36 45 55\nodd <- 2 * (1 : 10) - 1\nfor (i in odd) {\n  print(i)\n}## [1] 1\n## [1] 3\n## [1] 5\n## [1] 7\n## [1] 9\n## [1] 11\n## [1] 13\n## [1] 15\n## [1] 17\n## [1] 19\nfor (i in 1 : 10) {\n  if (i < 5) {\n    print(\"Fail\")\n  } else {\n    print(\"Pass\")\n  }\n}## [1] \"Fail\"\n## [1] \"Fail\"\n## [1] \"Fail\"\n## [1] \"Fail\"\n## [1] \"Pass\"\n## [1] \"Pass\"\n## [1] \"Pass\"\n## [1] \"Pass\"\n## [1] \"Pass\"\n## [1] \"Pass\""},{"path":"control.html","id":"while-迴圈","chapter":"2 控制結構與函數","heading":"2.2.2 while 迴圈","text":"除了 迴圈以外，還有 迴圈，其語法為：以下為一個 迴圈的簡單範例：第一圈 為 0，運行到 print() 時將會印出包含 “0” 與 “less 10” 元素的向量，而 <- + 1 相當於計數器，第一個迴圈結束後，變數 就會變成 1，以此類推。在第十個迴圈結束後，變數 將會變成 10，而就不符合 迴圈繼續執行的條件了，迴圈至此終止。","code":"\nwhile (\"condition holds\") { \n  \"do something\"\n}\ni <- 0\nwhile (i < 10) {\n  print(c(i,\"is less than 10\"))\n  i <- i + 1\n}## [1] \"0\"               \"is less than 10\"\n## [1] \"1\"               \"is less than 10\"\n## [1] \"2\"               \"is less than 10\"\n## [1] \"3\"               \"is less than 10\"\n## [1] \"4\"               \"is less than 10\"\n## [1] \"5\"               \"is less than 10\"\n## [1] \"6\"               \"is less than 10\"\n## [1] \"7\"               \"is less than 10\"\n## [1] \"8\"               \"is less than 10\"\n## [1] \"9\"               \"is less than 10\""},{"path":"control.html","id":"functions-and-operators","chapter":"2 控制結構與函數","heading":"2.3 Functions and Operators","text":"","code":""},{"path":"control.html","id":"創建新函數","chapter":"2 控制結構與函數","heading":"2.3.1 創建新函數","text":"R 本身就有很多預設的函數，如 mean() 可以取平均，sum() 可以加總，sqrt() 可以計算數字的平方根，log() 與 exp() 可以計算數字的對數值與指數值，sin()、cos()、tan() 可以計算三角函數值，.logical() 可以確認型態是否是 logical。如果要創建我們自己的函數，其語法為：函數的名字隨意，只要沒有與既存的函數同名或以某些不合法的方式命名即可；引述的數量可多可少；body function 則裝載執行程序，裡頭用的值由引數而來，最後一行命令則會回傳成輸出。例如若想新建一個函數來協助計算 \\(f(x, y)=x^2 - \\frac{y}{5}\\) 的話，可以或者我們也可以寫成：執行的最後一行預設就是輸出了，我們不需要寫出 return，但也能把它寫出來，如：定義函數以後我們就可以使用此函數進行運算。","code":"\nfunction.name <- function(argument1, argument2,...) {\n  \"body function\"\n}\nf <- function(x, y) {\n  x ^ 2 - y / 5  # the output is the evaluation of last line\n}\nf <- function(x, y) x ^ 2 - y / 5\nf <- function(x, y) { \n  return (x ^ 2 - y / 5)\n}"},{"path":"control.html","id":"defaultargument","chapter":"2 控制結構與函數","heading":"2.3.2 引數的預設值","text":"函數不一定要輸入引數。如果引數有預設值，而未輸入引數的話，即隨預設值。創建一個有預設的引數的函數的語法，如：以下是一個能輸出連續的數字為向量或矩陣的簡單範例：此函數有三個變數：指矩陣或向量的元素個數；b 為如果我們想輸出的是矩陣的話其 rows 的數量；flag 決定是輸出矩陣還是向量，若 flag=TRUE，將會輸出包含 \\(1\\)-至 \\(\\)，而有 \\(b\\) 個 rows 的矩陣（預設為 b=2） ，若 flag=FALSE，將會輸出包含 \\(1\\) 至 \\(\\) 的向量（預設為 flag=FALSE）。有預設的引數還有一個好處，即就算我們漏輸入了、忘記了有哪些引數，程式碼還是能正常運行，而不會報錯。函數能輸出的就只有單一個物件。所以如果想要輸出多個元素，可以使用 lists。例如我們可以創建一個函數，其回傳三項資訊：資料長度、總和與平均值，即：我們把向量 1:10 丟進此函數，可得：如果我們想查看函數是如何構成的，可以直接輸入其名，如：如果想要套用函數在多個元素時，可以使用 lapply(list, function)，其會把函數套用到 vector 或 list 的所有元素。sapply() 則類似於 lapply()，不同的是會把輸出簡化成向量或矩陣，而不是元素。其使用範例如：或者也可以簡化成：以內建的 cars datasets 為例，其有兩個變數：speed 與 dist。當我們想要計算這兩者的算術平均，可以：或者：","code":"\nfuntion.name <- function(name.argument1=default.value1, \n                         name.argument2=default.value2,...) {\n  \"body function\"\n}\nmat.vec <- function(a, b=2, flag=FALSE){ \n  if (flag) {\n    matrix(1 : a, nrow=b)\n  } else {\n    1:a \n  }\n}\nitems <- function(x) list(len=length(x),total=sum(x), mean=mean(x))\ndata <- 1 : 10\nresult <- items(data)\nresult## $len\n## [1] 10\n## \n## $total\n## [1] 55\n## \n## $mean\n## [1] 5.5\nlog## function (x, base = exp(1))  .Primitive(\"log\")\nsalutation <- function(x) print(\"Hello\")\n# Note that this output does not depend on the value of x\noutput <- sapply(1 : 5, salutation)## [1] \"Hello\"\n## [1] \"Hello\"\n## [1] \"Hello\"\n## [1] \"Hello\"\n## [1] \"Hello\"\noutput <- sapply(1 : 5, function(x) print(\"Hello\"))## [1] \"Hello\"\n## [1] \"Hello\"\n## [1] \"Hello\"\n## [1] \"Hello\"\n## [1] \"Hello\"\nlapply(cars, mean)## $speed\n## [1] 15.4\n## \n## $dist\n## [1] 42.98\nsapply(cars, mean)## speed  dist \n## 15.40 42.98"},{"path":"rdata.html","id":"rdata","chapter":"3 R 的資料庫","heading":"3 R 的資料庫","text":"本章為 Zamora Saiz et al. (2020) 節 3.1 與 3.2 內容。","code":""},{"path":"rdata.html","id":"資料來源匯入與匯出","chapter":"3 R 的資料庫","heading":"3.1 資料來源、匯入與匯出","text":"","code":""},{"path":"rdata.html","id":"tabulated-file-types","chapter":"3 R 的資料庫","heading":"3.1.1 Tabulated File Types","text":"最簡單的表格檔就是每個 column 的資料由空格分開，而每個 row 的資料由換行分開。這種分隔符號（separator）方便卻有一個大問題，即兩個字的資訊無法儲存，例如 orange shirt 就會變成兩塊。所以要解決這個問題，就是每個 column 的資料改由逗號分開。不過想當然耳，如果資料內有逗號，那儲存上也會出現問題。如果想解決這個問題，也能用分號分開每個 column。雖然使用到分號的機率低上許多，但還是沒辦法免於這種風險。所以說，分隔好的選擇其實沒有什麼放諸四海皆準的通則，只能多加注意。表格檔可以儲存種許多種檔案格式，最常見的是 comma separated values format，即 .csv 檔。雖然它是如此稱呼，但我們在匯入與匯出資料時也都要敘明 seperator。","code":""},{"path":"rdata.html","id":"匯入與匯出","chapter":"3 R 的資料庫","heading":"3.1.2 匯入與匯出","text":"","code":""},{"path":"rdata.html","id":"csv-檔","chapter":"3 R 的資料庫","heading":"3.1.2.1 .csv 檔","text":"要匯入 .csv 檔可以使用 read.csv()。其有多個引數，最重要的是以下的四個。第一個引數指定要從哪裡讀取資料；第二個引數決定表格有無 header；第三個引數指定 separator 而第四個引數指定 decimal separator。而以 write.csv() 可以匯出 data frames 成 .csv 檔。第一個引數指定要輸出的 data frames；第二個引數指定輸出的名稱；第三個與第四個引數分別指定有無包含 coloumn 與 row 的名字；第五個與第六個引數分別指定 separator 與 decimal separator。除了 .csv 檔也還有其他資料類型，如 .txt 與 .dat 檔，分別可以 read.table() 與 read.delim() 讀取。不過，我們要匯出資料時最好還是匯出為 .csv 檔，因為它最通用。但要注意的是，前開的 read.csv() 與 write.csv() 處理起大數據速度很慢。我們可以使用一個 R package data.table 來解決這個問題，只要在 console 輸入：library(data.table)，2並分別以 fread() 與 fwrite() 來讀取與輸出檔案，其中 f 為 “fast” 之義。除了處理速度大增，使用 fread() 與 fwrite() 還可以讀取 .csv 檔以外的檔案，也可以自動識別 separator，而資料將會開啟成 data.table 的型態（data.frame 的升級版），而非 data.frame。","code":"\nour.table <- read.csv(\"myfilewithdata.csv\", header=TRUE, sep=\";\", dec=\".\")\nwrite.csv(our.table, \"filetosave.csv\", col.names=FALSE, row.names=TRUE, sep=\";\", dec=\".\")"},{"path":"rdata.html","id":"json-檔","chapter":"3 R 的資料庫","heading":"3.1.2.2 .json 檔","text":"除了表格檔，我們還會需要使用階層檔（hierarchical files）。標準的階層檔檔案格式為 JavaScript Object Notation，即 .json 檔，就像書目一樣儲存資訊。但我們要讀取這類的檔案無法直接為之，必須借助套件 jsonlite。想要匯入一個 .json 檔到 R 裡頭並轉成 data.frame 格式只要輸入：","code":"\nlibrary(jsonlite)\njsonastable <- as.data.frame(fromJSON(\"ourjsonfile.json\"))"},{"path":"rdata.html","id":"xls-與.xlsx-檔","chapter":"3 R 的資料庫","heading":"3.1.2.3 .xls 與.xlsx 檔","text":"除外，還有一種檔案格式為試算表（spreadsheets）。MS Excel 就是最受歡迎的試算表程式。試算表雖然在某些領域頗有用，但也有計算速度與檔案大小的限制：Excel 檔最多只能有 1,048,576 個 rows 與 16,384 個 columns。想要在 R 載入 Excel 檔（.xls 或 .xlsx 檔），可以使用套件 readxl。輸入：引數 col_types 指定每個 column 裡的資料型態，而引數 sheet 則選擇要匯入檔案中的哪張試算表。","code":"\nlibrary(readxl)\ndata <- read_excel(\"file.xlsx\", col_names=TRUE, col_types=c(\"numeric\", \"numeric\"), sheet=2)"},{"path":"rdata.html","id":"資料收集","chapter":"3 R 的資料庫","heading":"3.2 資料收集","text":"資料依據其結構化的程度分成：Fully Structured: 變數已經明確定義而為表格的形式的 datasets。不費吹灰之力就能轉換成 data frames。使用 APIs 或一些公開的資料來源可以取得此類型的資料。Fully Structured: 變數已經明確定義而為表格的形式的 datasets。不費吹灰之力就能轉換成 data frames。使用 APIs 或一些公開的資料來源可以取得此類型的資料。Semi Structured: 變數也已經明確定義，但還沒有變成表格的形式，例如網頁。還需要經前處理。Semi Structured: 變數也已經明確定義，但還沒有變成表格的形式，例如網頁。還需要經前處理。Unstructured: 變數尚未明確定義，例如圖片、音樂或未經處理的文字。需要先經過其他前處理，才能轉換成可供分析的資料。Unstructured: 變數尚未明確定義，例如圖片、音樂或未經處理的文字。需要先經過其他前處理，才能轉換成可供分析的資料。處理非結構化的資料需要足夠的數學基礎，此處將會專於前兩者。","code":""},{"path":"rdata.html","id":"data-repositories","chapter":"3 R 的資料庫","heading":"3.2.1 Data Repositories","text":"存取資料最簡單的方式是使用免費公開的資料庫，如 World Data Bank、Eurostat、U.S. Government’s Open Data 等，或者其他商用的資料庫。此外，也有套件 mlbench，包含了 UCI Machine Learning Repository 的 datasets。如果要載入 Glass dataset，只要輸入：","code":"\nlibrary(mlbench)\ndata(Glass)"},{"path":"rdata.html","id":"apis","chapter":"3 R 的資料庫","heading":"3.2.2 APIs","text":"Application Programming Interfaces (APIs) 使我們可以直接存取資訊，而不需要透過手動下載 datasets 的方式。APIs 是一種通訊協定（communication protocols），有清楚的結構，可以有效率的傳遞資訊。此外，還可以如果有需要限制下載量，或者確認憑證（credentials），或者分割過大的檔案。","code":""},{"path":"rdata.html","id":"rest-apis","chapter":"3 R 的資料庫","heading":"3.2.2.1 REST APIs","text":"APIs 都會有文件說明如何使用，有些要以特定的程式語言才能存取，例如 Python 或 PHP。最常見的 APIs 為 Representational State Transfer APIs (REST APIs)，其透過 URLs 要求資料，而提供的資料都會是標準的結構化格式（standard structured formats）。因為每個 REST API 組織用以存取資料的 URLs 的方式都不同，所以使用 REST APIs 前得要先閱讀文件，了解如何存取想要的文件，然後再透過 R 存取之，若有需要並將其轉換成 data frames。","code":""},{"path":"rdata.html","id":"opensky-network-example","chapter":"3 R 的資料庫","heading":"3.2.2.2 OpenSky Network Example","text":"OpenSky Network 為一非營利組織，其透過 REST API 分享資料，旨在增進航空交通的安全與效率。我們要獲取當下的航班的狀態。第一步是閱讀其文件。因為其提供的文檔是 .json 檔，所以我們要載入 jsonlite：然後透過所提供的 URL，請求檔案，並轉成 data frame：第一行把 URL 指派給字串 url；而第二行中，fromJSON() 可以讀取 .json 檔，URLenconde() 則是要告訴 R，將要放進一個有 .json 檔的 URL，其說明可在 Console 輸入 ?URLencode 了解，然後以 .data.frame() 將資料轉成 data frame，並存進變數 flights 中（也可以 .data.table() 把資料轉成 data table 的型態）另一方面，如果 APIs 提供的檔案是 .csv 檔，那我們可以直接使用 fread(URLencode(指定的url))，而毋需使用 jsonlite。","code":"\nlibrary(jsonlite)\nurl <- \"https://opensky-network.org/api/states/all\"\nflights <- as.data.table(fromJSON(URLencode(url)))"},{"path":"rdata.html","id":"rvestweb","chapter":"3 R 的資料庫","heading":"3.2.3 Web Scraping","text":"至今，已有 rvest 已有更新，可見 https://www.tidyverse.org/blog/2021/03/rvest-1-0-0/。從網頁抓取資料時，一般的流程為：清楚定義要下載的資訊為何。了解網頁的編碼方式。以 R 選擇並下載之。將其轉換為變數並組合成 data frame。以下以兩個例子說明網頁抓取的流程。","code":""},{"path":"rdata.html","id":"thesportsdb","chapter":"3 R 的資料庫","heading":"3.2.3.1 TheSportsDB","text":"雖說這個網頁有 API，但此僅作為範例。每個網頁都有一個 robots.txt，在瀏覽器的網址列輸入 目標網頁/robots.txt 可以查看。以此處的 TheSportsDB 為例，即輸入 https://www.thesportsdb.com/robots.txt 就能查看之。其記載著：我們先從其第三、四行開始閱讀，其意指機器人 AhrefsBot 被禁止從網頁抓取任何東西，其中 / 為「任何東西」之義，Disallow: / 即禁止抓取任何東西。第一、二行則表示所有既存的機器人（表示為 *）沒有禁止，即存取是合法的。我們想抓取的網頁是https://www.thesportsdb.com/season.php?l=4387&s=2020-2021，即 NBA 2020–2021 年的球賽。多數的網頁是由 HyperText Markup Language (HTML) 編碼的。當我們連到上述的網頁，按下鍵盤 F12，並選取「元素」（Elements）的頁面標籤，可以開啟如圖 3.1 的畫面。\nFigure 3.1: Inspection menu.\n在 .html 檔中，所有元素的首尾都有一個 tag，即以 <tag> 為開頭（可能會包含屬性，如 <tag attribute=value>），而以 <\/tag> 結尾。在該網頁中，如圖 3.2，當我們把游標放到第一場球賽的結果時，右欄 <td style=\"text-align:center; width:10%\">112 - 116<\/td> 也會被強調。在這個 tag 中，描述了文字的對齊方式與要呈現哪些文字在螢幕上。\nFigure 3.2: 第一場比賽的比分所對應到的程式碼。\n了解我們所要的資訊所對應到的程式碼是哪部分以後，下一個步驟是用 R 打開網頁，並告訴它要存取哪部分的資料。接下來的流程是：呼叫網頁，並將其存在變數中。指定要抓取的部分。轉換資訊成文字。首先使用套件 rvest，用以擷取網頁資料。在 Console 輸入：並以指令 read_html() 呼叫網頁，將其儲存在變數中，如：輸入 nbagames 我們可以看到：而我們可以利用 html_nodes() 指定要抓取的部分。此函數需要兩個引數，其一為網頁（剛剛把網頁存到的變數就要放在這裡），其二為我們所需要的 tag 的字串，因為我們需要 <td> 這個 tag，所以在這裡即輸入 \"td\"，如：此時，變數 games 儲存了：由此可見，匯入了所有 td tags，而儲存於 xml_nodeset，一種專為與 .html 互動而設計的資料型態。因為要轉換成 character 才能處理，所以我們要使用 html_text()，如：此時，games 內儲存的就會是：可以發現，此時還是有一些空字串與 \\n（換新行）、\\t（表格）與 \\tr00 之類的字元。我們接下來的目標是把資訊拆開，存入不同的變數中。待到節 4 將會處理這些問題。","code":"User-agent: *\nDisallow:\nUser-agent: AhrefsBot\nDisallow: /\nlibrary(rvest)\nnbagames <- read_html(\"https://www.thesportsdb.com/season.php?l=4387&s=2020-2021\"){html_document}\n<html>\n[1] <head>\\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\\n<script type=\"text/ja ...\n[2] <body class=\"homepage\">\\n\\n<header id=\"header\"><nav class=\"navbar navbar-inverse\" role=\"banner\"><d ...\ngames <- html_nodes(nbagames,\"td\"){xml_nodeset (7327)}\n [1] <td><br><\/td>\\n\n [2] <td style=\"text-align:left; width:20%\">12 Dec 2020<\/td>\\n\n [3] <td><\/td>\\n\n...\ngames <- html_text(html_nodes(nbagames, \"td\"))[1] \"\"                         \"12 Dec 2020\"              \"\"                        \n[4] \"\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tr00 \" \"Atlanta Hawks\"            \"112 - 116\"               \n[7] \" Orlando Magic\"           \"12 Dec 2020\"              \"\"                        \n[10] \"\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tr00 \" \"Detroit Pistons\"          \"84 - 90\"                 \n[13] \" New York Knicks\"         \"12 Dec 2020\"              \"\"        \n..."},{"path":"rdata.html","id":"goodreads","chapter":"3 R 的資料庫","heading":"3.2.3.2 Goodreads","text":"第二個任務是 Goodreads 網頁所列的 21 世紀最佳書籍，可以參見：https://www.goodreads.com/list/show/7.Best_Books_of_the_21st_Century。首先當然是查看 robots.txt。因此我們要連到 https://www.goodreads.com/robots.txt，可以發現有一大堆的 Disallow：但並非什麼存取都是不被允許的（因為 / 沒有被 Disallow），且 /list/ 也沒有被 Disallow，所以還是可以抓取此網頁。而我們可以發現，第一本書的標題所對應的 .html 碼為 <span itemprop=\"name\" role=\"heading\" aria-level=\"4\">Harry Potter Deathly Hallows (Harry Potter, #7)<\/span>，而 span 這個 tag 就是對應到書名。因此我們似乎可以仿效之前的做法：但我們將會發現，存進 books 的卻是：直到第 14 個元素，才抓到第一本書的書名。現在的問題就在，tag span 雖然有包含書名，但還有包含許多其他的資訊。要解決這個問題，我們可以發現 tag span 是在 tag 的下層，而 tag 有一屬性為 class=\"bookTitle\"。Class 在 HTML 中的用處就是用來分類 tags 的方式，所以我們可以有單一個 tag，但有不同種類的資訊。因此，我們可以把剛剛的程式碼改成：指涉 class 的時候，前面要加上 .，而我們可以在該引數中同時放入 classes 和 tags。上述的程式碼即選取所有有 class 為 bookTitle 的 nodes，而選取裡頭的 tag span。結果，books 會是：顯然，結果就正常許多。而我們也需要提取作者與評分的資訊，因此程式碼為：這時候算是大致完成了，但評分的部分的格式還是不太行，有些多餘的 hyphen 或字詞，在節 4，將會處理這個問題。","code":"# See http://www.robotstxt.org/robotstxt.html for documentation on how to use the robots.txt file\nUser-agent: *\nDisallow: /about/team_member/\nDisallow: /admin\nDisallow: /api\nDisallow: /blog/list_rss\nDisallow: /book/reviews/\nDisallow: /book_link/follow/\n...\ngoodreadsurl <- \"https://www.goodreads.com/list/show/7.Best_Books_of_the_21st_Century\"\ngoodreads <- read_html(goodreadsurl)\nbooks <- html_text(html_nodes(goodreads, \"span\")) [1] \"Browse ▾\"                                                          \n [2] \"Community ▾\"                                                       \n [3] \"\"                                                                  \n [4] \"\"                                                                  \n [5] \"\"                                                                  \n [6] \"\"                                                                  \n [7] \"Profile\"                                                           \n [8] \"Groups\"                                                            \n [9] \"Groups\"                                                            \n[10] \"Friends’ recommendations\"                                          \n[11] \"Friends’ recommendations\"                                          \n[12] \"Browse ▾\"                                                          \n[13] \"Community ▾\"                                                       \n[14] \"Harry Potter and the Deathly Hallows (Harry Potter, #7)\"      \n...\ngoodreadsurl <- \"https://www.goodreads.com/list/show/7.Best_Books_of_the_21st_Century\"\ngoodreads <- read_html(goodreadsurl)\nbooks <- html_text(html_nodes(goodreads, \".bookTitle span\"))  [1] \"Harry Potter and the Deathly Hallows (Harry Potter, #7)\"                     \n  [2] \"The Hunger Games (The Hunger Games, #1)\"                                     \n  [3] \"The Kite Runner\"                                                             \n  [4] \"The Book Thief\"                                                              \n  [5] \"Harry Potter and the Half-Blood Prince (Harry Potter, #6)\"                   \n  [6] \"Harry Potter and the Order of the Phoenix (Harry Potter, #5)\"                \n  [7] \"The Help\"    \n...\ngoodreads <- read_html(goodreadsurl)\nbook <- html_text(html_nodes(goodreads, \".bookTitle span\"))\nauthor <- html_text(html_nodes(goodreads, \".authorName span\"))\nrating <- html_text(html_nodes(goodreads, \".minirating\"))\ntopbooks <- data.frame(book, author, rating)"},{"path":"rdata.html","id":"臺大活動報名系統與-css-選擇器","chapter":"3 R 的資料庫","heading":"3.2.3.3 臺大活動報名系統與 CSS 選擇器","text":"想要找出網頁的 CSS 選擇器路徑，除了上述手動查看的方法以外，如果使用 Google chrome 系列的瀏覽器，更方便的做法是使用如 SelectorGadget 之類的外掛。安裝完成並開啟以後直接用滑鼠點選想要抓取的元素即可，如圖 3.3。而如果包含到不想要選取的元素，就點選使其變成紅色，未包含到想要選取的元素則亦再行點選之即可。之後，SelectorGadge 將會產生一組 CSS 選擇器。如我們要抓取活動的代碼，其 CSS 選擇器即 .actID。\nFigure 3.3: 使用 SelectorGadget。\n因此，我們可以如此抓取臺大活動系統之過期活動中 2021 年的活動清單，並製作成一張 data table：結果如圖 3.4。\nFigure 3.4: 抓取臺大活動系統中 2021 年的過期活動的資訊。\n","code":"\nevents.url <- \"https://my.ntu.edu.tw/actregister/expiredActionList.aspx\"\nevents <- read_html(events.url)\nevents.number <- html_text(html_nodes(events, \".actID\"))\nevents.name <- html_text(html_nodes(events, \".multiline\"))\nevents.time <- html_text(html_nodes(events, \".actTime\"))\nevents.state <- html_text(html_nodes(events, \"#ulbox .floatRight\"))\nevents.table <- data.table(events.number, events.name, events.time, events.state)"},{"path":"rdata.html","id":"臺大政治系專任教師資料簡表","chapter":"3 R 的資料庫","heading":"3.2.3.4 臺大政治系專任教師資料簡表","text":"Table 3.1: 臺大政治系專任教師資料簡表。","code":"\nlibrary(data.table)\npolisci.prof.url <- \"http://politics.ntu.edu.tw/?cat=8\"\npolisci.prof <- read_html(polisci.prof.url)\nprof.name <- html_text(html_nodes(polisci.prof, \".name a\"))\nprof.title <- html_text(html_nodes(polisci.prof, \".title\"))\nprof.phone <- html_text(html_nodes(polisci.prof, \".tel\"))\nprof.email <- html_text(html_nodes(polisci.prof, \".mail a\"))\nprof.table <- data.table(prof.name, prof.title, prof.email)\nprof.phone <- append(prof.phone, NA, 13)  # 蕭高彥沒有放電話\nprof.table <- cbind(prof.table, as.data.table(prof.phone))\nknitr::kable(prof.table, booktabs = TRUE, caption = '臺大政治系專任教師資料簡表。')"},{"path":"rdata.html","id":"小結","chapter":"3 R 的資料庫","heading":"3.3 小結","text":"此外，還有兩個抓取網頁上的困難，此處沒有提及：有些網頁在點擊之後會產生改變，但其網址並不會改變。此外，有些資訊需要登入才能存取。而有些網頁在 html 之上又使用 javascript。上述的問題都無法透過 rvest 來解決。雖然有其他套件，如 rselenium 可以解決這些問題，但並不簡單。此外，有些平臺不想讓資訊流出給外人使用，會去偵測並阻斷自動抓取，這時候就很難從中提取有用的資訊。","code":""},{"path":"preprocessing.html","id":"preprocessing","chapter":"4 資料前處理","heading":"4 資料前處理","text":"本章為 Zamora Saiz et al. (2020) 節 3.3 內容。在資料分析前，我們須先進行資料前處理（data preprocessing）。準備資料有以下幾個步驟（雖然並非都是永遠需要）：Cleaning: 改變 dataset 的變數的格式。例如清除節 3.2.3.2 中的 rating 變數中無用的字元。Cleaning: 改變 dataset 的變數的格式。例如清除節 3.2.3.2 中的 rating 變數中無用的字元。Integration: 從不同處來的資訊，在清潔以後，要整合成一張 data frame。Integration: 從不同處來的資訊，在清潔以後，要整合成一張 data frame。Transformation: 創造一些需要的變數，重構 dataset 成為更便於分析的格式。Transformation: 創造一些需要的變數，重構 dataset 成為更便於分析的格式。Reduction: 如果 dataset 很龐大，而要從事的分析只是一小部分的資料，就要刪除一些變數，以釋出記憶體。Reduction: 如果 dataset 很龐大，而要從事的分析只是一小部分的資料，就要刪除一些變數，以釋出記憶體。此章將專於使用 base 與 data.table；當然，也可以使用 tidyr、dplyr、stringr 或 stringi；3本書第 6、10、12 章將會分別介紹 dplyr、tidyr 與 stringr。","code":""},{"path":"preprocessing.html","id":"datatable","chapter":"4 資料前處理","heading":"4.1 Data Tables","text":"Data Tables 即 data frames 的改良版，效能更高、功能更多、速度更好。並且，一個 data.table 物件也同時是一個 data.frame 物件，所以前者也可以使用後者的語法。要將向量或矩陣轉換為 data table 可以使用 .data.table()，即：而既存的 data frame 或 list 可以使用 setDT() 將其轉換成 data table（雖然也可以使用 .data.table()，但前者使用較少記憶體，速度更快）。不過，data table 的 row 沒有名字，所以如果要把有名字的 data frame 轉換成 data table，要使用 keep.rownames=T 引數，新增一個名為 rn 的 column，例如：而 data.table 物件有如 example.data[, j, ] 的格式，此三個引數分別代表 row、column 與「分類依據」。","code":"\nour.matrix.DT <- as.data.table(our.matrix)\nlibrary(data.table)\nexample <- data.frame(info1 = c(1, 2), info2 = c(\"a\", \"b\"))\nrow.names(example) <- c(\"line1\", \"line2\")\nsetDT(example, keep.rownames=T)\nclass(example)## [1] \"data.table\" \"data.frame\""},{"path":"preprocessing.html","id":"排序-ordering","chapter":"4 資料前處理","heading":"4.1.1 排序 Ordering","text":"要重新排序 data table 的 row 除了可以用節 1.5.2 的 data frame 的方法以外，還有更簡單、快速的語法。以內置的套件 datasets 中的 swiss 為例。為了避免與原本的 dataset 混淆，我們可以創建一個複本。然後將其轉換成 data table，並以城鎮名稱字母序排列（現在城鎮名為新創的 rn column）：我們也可以依據多個變數來排列。order() 中的第一個引數會優先排列，如果值相等，再依據第二個引數排列，依此類推。而 - 為降冪排列之義。","code":"\nDT.swiss <- copy(swiss)\nsetDT(DT.swiss, keep.rownames=T)\nDT.swiss[order(rn)]\nDT.swiss[order(Education, -Agriculture)]"},{"path":"preprocessing.html","id":"子集-subsetting","chapter":"4 資料前處理","heading":"4.1.2 子集 Subsetting","text":"如節 1.5.1 一樣存取 data frame 中的元素，我們依樣畫葫蘆來存取 data table 內的元素。例如我們如果想要存取前三個 rows 與前三個 columns 的元素，可以：也可以使用名字來選取，如：或者使用 ! 來不選取某個名字的 column，如：如果使用 - 在數字前，則可以選取那個 row 或 column，如：或者以 c() 包裹的任何組合：我們也可以使用 .data[condition certain variables] 來選取滿足條件的 rows（類似節 1.5.1 提及的 subset()，但以 data table 速度更快）。如要找到 Education 恰等於 9 的城鎮，可以：其結果為：或者要找到 Education 小於等於 2 的城鎮，可以：其結果為：以邏輯條件選取 data table 中的元素時，也可以超過一個條件，如：回憶節 2.3.2 所提及的，sapply(list, function) 可以套用函數在多個元素上，並輸出為向量或矩陣。sapply(DT.swiss[, -1], mean) 之義為套用 mean() 這個函數在 DT.swiss 中除了第一個 column 以外的其他 columns，即算出其平均值，並輸出成有標籤的向量。而我們將輸出的資料存入 mean.values 變數中。如此，我們就能找出同時滿足「Agriculure 與 Education 皆大於平均值」的 rows，即：另一個 data table 的優勢是第二個引數 j 其實可以傳入非索引值的物件，例如我們想知道 Catholic > 50 的城鎮其 Education 的平均可以透過：也可以知道 Catholic > 50 的城鎮其 Education 的平均是否大於整體的 Education 平均：或者 Education 小於 10 的城鎮究竟有多少：","code":"\nDT.swiss[1 : 3, 1 : 3]\nDT.swiss[1 : 3, \"rn\"]\n# 顯示第一至三個 rows 與名為 rn 的 column\nDT.swiss[1 : 3, !\"Agriculture\"]\n# 顯示第一至三個 rows，不顯示名為 Agriculture 的 column\nDT.swiss[-(2 : 47),]  # 只會選取第一個 row\nDT.swiss[, -1]  # 不選取第一個 column\nDT.swiss[1 : 3, c(\"rn\", \"Education\", \"Catholic\")]\n#  顯示第一至三個 rows，與名為 rn、Education、Catholic 的 columns\nDT.swiss[Education == 9]           rn Fertility Agriculture Examination Education Catholic Infant.Mortality\n1:   Delemont      83.1        45.1           6         9    84.84             22.2\n2:     Lavaux      65.1        73.0          19         9     2.84             20.0\n3: St Maurice      65.0        75.9           9         9    99.06             17.8\nDT.swiss[Education <= 2]          rn Fertility Agriculture Examination Education Catholic Infant.Mortality\n1: Echallens      68.3        72.6          18         2    24.20             21.2\n2:      Oron      72.5        71.2          12         1     2.40             21.0\n3:   Conthey      75.5        85.9           3         2    99.71             15.1\n4:    Herens      77.3        89.7           5         2   100.00             18.3\nmean.values <- sapply(DT.swiss[, -1], mean)\nDT.swiss[Agriculture > mean.values[2] & Education > mean.values[4]]         rn Fertility Agriculture Examination Education Catholic Infant.Mortality\n1:    Aigle      64.1        62.0          21        12     8.52             16.5\n2: Avenches      68.9        60.7          19        12     4.43             22.7\n3:    Nyone      56.6        50.9          22        12    15.14             16.7\n4:     Sion      79.3        63.1          13        13    96.83             18.1\nDT.swiss[Catholic > 50, mean(Education)]## [1] 9.111111\nDT.swiss[Catholic > 50, mean(Education) > mean.values[4]]## Education \n##     FALSE\nDT.swiss[Education < 10, length(Education)]## [1] 28"},{"path":"preprocessing.html","id":"加總-aggregation","chapter":"4 資料前處理","heading":"4.1.3 加總 Aggregation","text":"前面曾經提及，example.data[, j, ] 中的引數 為分組依據。其使用要配合引數 j。例如我們想得知每一個 Education 的值所對應到的 Fertility 的平均值，並且依據 Education 降冪排列，可以：當使用 來分類時，在引數 j 就無法使用 length() 來計算出現次數了。這時候可以改用 .N 來計算各組的數字，如：也可以與 maen() 結合起來，以下列出各 Education 程度的數量，並分別算出各 Education 程度的 Fertility 與 Catholic 的平均，而以 Education 降冪排列：除此之外，也可以丟入邏輯式，如：我們可以得知，有 37 個城鎮的 Education 小於 15，且 Fertility 大於 60；2 個城鎮的 Education 不小於 15，且 Fertility 大於 60；有 6 個城鎮的 Education 不小於 15，且 Fertility 不大於 60；2 個城鎮的 Education 小於 15，且 Fertility 不大於 60。","code":"\nDT.swiss[order(-Education), mean(Fertility), by=Education]    Education       V1\n 1:        53 35.00000\n 2:        32 64.40000\n 3:        29 43.75000\n 4:        28 55.70000\n 5:        20 54.30000\n ...\nDT.swiss[order(-Education), .N, by=Education]    Education N\n 1:        53 1\n 2:        32 1\n 3:        29 2\n 4:        28 1\n 5:        20 1\n ...\nDT.swiss[order(-Education), .(.N, mean(Fertility), mean(Catholic)), by=Education]   Education N       V2       V3\n 1:        53 1 35.00000 42.34000\n 2:        32 1 64.40000 16.92000\n 3:        29 2 43.75000 54.38000\n 4:        28 1 55.70000 12.11000\n 5:        20 1 54.30000  2.15000\n...\nDT.swiss[, .N, .(Education < 15, Fertility > 60)]   Education Fertility  N\n1:      TRUE      TRUE 37\n2:     FALSE      TRUE  2\n3:     FALSE     FALSE  6\n4:      TRUE     FALSE  2"},{"path":"preprocessing.html","id":"keying","chapter":"4 資料前處理","heading":"4.1.4 Keying","text":"Keys 是另一個選取子集（subsetting）更快的方法。只要在 data table 的某個變數中設定了 key，表格在物理上就會重新排列記憶體與儲存的 rows 所分派的順序。設定 key 的指令為 setkey(data.table, key)，如：之後，表格就會依據 Education 重新排列：想要 subsetting keyed variable，可以使用 .()，如下列出 Education 等於 3 的 rows：也可以輸入向量，如下列出 Education 等於 3 或 5 的 rows：也可以與引數j 和 搭配使用，如：與：","code":"\nsetkey(DT.swiss, Education)              rn Fertility Agriculture Examination Education Catholic Infant.Mortality\n 1:         Oron      72.5        71.2          12         1     2.40             21.0\n 2:    Echallens      68.3        72.6          18         2    24.20             21.2\n 3:      Conthey      75.5        85.9           3         2    99.71             15.1\n 4:       Herens      77.3        89.7           5         2   100.00             18.3\n 5:       Moudon      65.0        55.1          14         3     4.52             22.4\n 6: Paysd'enhaut      72.0        63.5           6         3     2.56             18.0\n 7:      Monthey      79.4        64.9           7         3    98.22             20.2\n...\nDT.swiss[.(3)]##              rn Fertility Agriculture Examination Education Catholic\n## 1:       Moudon      65.0        55.1          14         3     4.52\n## 2: Paysd'enhaut      72.0        63.5           6         3     2.56\n## 3:      Monthey      79.4        64.9           7         3    98.22\n## 4:       Sierre      92.2        84.6           3         3    99.46\n##    Infant.Mortality\n## 1:             22.4\n## 2:             18.0\n## 3:             20.2\n## 4:             16.3\nDT.swiss[.(c(3, 5))]##              rn Fertility Agriculture Examination Education Catholic\n## 1:       Moudon      65.0        55.1          14         3     4.52\n## 2: Paysd'enhaut      72.0        63.5           6         3     2.56\n## 3:      Monthey      79.4        64.9           7         3    98.22\n## 4:       Sierre      92.2        84.6           3         3    99.46\n## 5: Franches-Mnt      92.5        39.7           5         5    93.40\n## 6:     Cossonay      61.7        69.3          22         5     2.82\n##    Infant.Mortality\n## 1:             22.4\n## 2:             18.0\n## 3:             20.2\n## 4:             16.3\n## 5:             20.2\n## 6:             18.7\nDT.swiss[.(1 : 2), !c(\"Agriculture\", \"Infant.Mortality\")]##           rn Fertility Examination Education Catholic\n## 1:      Oron      72.5          12         1     2.40\n## 2: Echallens      68.3          18         2    24.20\n## 3:   Conthey      75.5           3         2    99.71\n## 4:    Herens      77.3           5         2   100.00\nDT.swiss[.(3 : 6), mean(Fertility), by=Education]##    Education     V1\n## 1:         3 77.150\n## 2:        NA     NA\n## 3:         5 77.100\n## 4:         6 71.075"},{"path":"preprocessing.html","id":"編輯表格-updating-by-reference","chapter":"4 資料前處理","heading":"4.1.5 編輯表格 Updating by Reference","text":"那如何編輯表格呢？使用 :=，之前放 column 的名字，而之後放要指派的值。如果要新增兩個 column，可以：其結果為：修改其值也如同剛才的做法：結果為：如果要刪除既存的 column，則可以：","code":"\nDT.swiss[, c(\"new.col.1\", \"new.col.2\"):=list(1 : 47, 51 : 97)]              rn Fertility Agriculture Examination Education Catholic Infant.Mortality new.col.1 new.col.2\n 1:         Oron      72.5        71.2          12         1     2.40             21.0         1        51\n 2:    Echallens      68.3        72.6          18         2    24.20             21.2         2        52\n 3:      Conthey      75.5        85.9           3         2    99.71             15.1         3        53\n 4:       Herens      77.3        89.7           5         2   100.00             18.3         4        54\n 5:       Moudon      65.0        55.1          14         3     4.52             22.4         5        55\n...\n46:    Neuchatel      64.4        17.6          35        32    16.92             23.0        46        96\n47: V. De Geneve      35.0         1.2          37        53    42.34             18.0        47        97\nDT.swiss[, c(\"new.col.1\", \"new.col.2\"):=list(101 : 147, 151 : 197)]              rn Fertility Agriculture Examination Education Catholic Infant.Mortality new.col.1 new.col.2\n 1:         Oron      72.5        71.2          12         1     2.40             21.0       101       151\n 2:    Echallens      68.3        72.6          18         2    24.20             21.2       102       152\n 3:      Conthey      75.5        85.9           3         2    99.71             15.1       103       153\n 4:       Herens      77.3        89.7           5         2   100.00             18.3       104       154\n 5:       Moudon      65.0        55.1          14         3     4.52             22.4       105       155\n...\n46:    Neuchatel      64.4        17.6          35        32    16.92             23.0       146       196\n47: V. De Geneve      35.0         1.2          37        53    42.34             18.0       147       197\nDT.swiss[, c(\"new.col.1\", \"new.col.2\"):=list(NULL, NULL)]"},{"path":"preprocessing.html","id":"merging","chapter":"4 資料前處理","heading":"4.2 Merging","text":"如果兩個 data table 有一樣的變數，那要合併可以使用 rbind()（row binding），如：如果有相同多的觀察值，則使用 cbind()（column binding），例如：如果兩個表格共享某些 rows 與 columns，則可以使用 merge()，如：","code":"\ndataset.1 <- data.table(city=c(\"Large\", \"Medium\"), population=c(1000000, 250000), km2=c(20, 7))\ndataset.2 <- data.table(city=c(\"Small\"), population=c(50000), km2=c(1))\ndataset.final <- rbind(dataset.1, dataset.2)\ndataset.final##      city population km2\n## 1:  Large    1000000  20\n## 2: Medium     250000   7\n## 3:  Small      50000   1\ndataset.1 <- data.table(city=c(\"Large\", \"Medium\", \"Small\"), population=c(1000000, 250000, 50000))\ndataset.2 <- data.table(km2=c(20, 7, 1))\ndataset.final <- cbind(dataset.1, dataset.2)\ndataset.final##      city population km2\n## 1:  Large    1000000  20\n## 2: Medium     250000   7\n## 3:  Small      50000   1\ndataset.1 <- data.table(city=c(\"city.1\", \"city.2\", \"city.3\", \"city.4\", \"city.5\", \"city.6\"), \n                        population=c(10000, 20000, 100000, 5000, 30000, 65000),\n                        km2=c(1, 0.5, 0.9, 2, 1.2, 3))\ndataset.2 <- data.table(city=c(\"city.1\", \"city.2\", \"city.3\", \"city.7\"),\n                        airport=c(FALSE, FALSE, TRUE, TRUE))\ndataset.1##      city population km2\n## 1: city.1      10000 1.0\n## 2: city.2      20000 0.5\n## 3: city.3     100000 0.9\n## 4: city.4       5000 2.0\n## 5: city.5      30000 1.2\n## 6: city.6      65000 3.0\ndataset.2##      city airport\n## 1: city.1   FALSE\n## 2: city.2   FALSE\n## 3: city.3    TRUE\n## 4: city.7    TRUE\n# inner join：包含所有 columns，但有缺漏值的 rows 會被跳過\nmerge(dataset.1, dataset.2)##      city population km2 airport\n## 1: city.1      1e+04 1.0   FALSE\n## 2: city.2      2e+04 0.5   FALSE\n## 3: city.3      1e+05 0.9    TRUE\n# full join：包含所有 columns 與 rows\nmerge(dataset.1, dataset.2, all = TRUE)##      city population km2 airport\n## 1: city.1      10000 1.0   FALSE\n## 2: city.2      20000 0.5   FALSE\n## 3: city.3     100000 0.9    TRUE\n## 4: city.4       5000 2.0      NA\n## 5: city.5      30000 1.2      NA\n## 6: city.6      65000 3.0      NA\n## 7: city.7         NA  NA    TRUE\n# left join：包含所有 columns，但跳過第一個表格沒有的 rows\nmerge(dataset.1, dataset.2, all.x = TRUE)##      city population km2 airport\n## 1: city.1      10000 1.0   FALSE\n## 2: city.2      20000 0.5   FALSE\n## 3: city.3     100000 0.9    TRUE\n## 4: city.4       5000 2.0      NA\n## 5: city.5      30000 1.2      NA\n## 6: city.6      65000 3.0      NA\n# right join：包含所有 columns，但跳過第二個表格沒有的 rows\nmerge(dataset.1, dataset.2, all.y = TRUE)##      city population km2 airport\n## 1: city.1      1e+04 1.0   FALSE\n## 2: city.2      2e+04 0.5   FALSE\n## 3: city.3      1e+05 0.9    TRUE\n## 4: city.7         NA  NA    TRUE"},{"path":"preprocessing.html","id":"實例","chapter":"4 資料前處理","heading":"4.3 實例","text":"除了前章所介紹的指令，本節還會介紹用以：資料清理的 na.omit()、duplicated()；文字轉換的 substr()、tstrplit()、grepl()。na.omit() 可以剔除表格中有 NA 的觀察值（rows）；duplicated() 則可以幫助我們刪除重複的觀察值。例如我們新建一個 data table：使用 na.omit() 即會刪除有 NA 的觀察值：使用 duplicated() 可以協助我們找到特定的 columns 重複的觀察值，例如：那要怎樣刪除重複的觀察值呢？我們可以：","code":"\ndupli.table <- data.table(ID=c(\"E123456789\", \"N123456789\", \"N213456897\", \"N123456789\", \"A123456789\", \"N213456897\", \"E213456897\"), sex=c(\"M\", \"M\", \"F\", \"M\", \"M\", \"F\", \"F\"), major=c(\"Econ\", NA, \"Math\", \"OR\", \"EE\", \"CS\", \"Eng\"))\ndupli.table <- na.omit(dupli.table)\ndupli.table##            ID sex major\n## 1: E123456789   M  Econ\n## 2: N213456897   F  Math\n## 3: N123456789   M    OR\n## 4: A123456789   M    EE\n## 5: N213456897   F    CS\n## 6: E213456897   F   Eng\nduplicated.rows1 <- duplicated(dupli.table[, c(1, 3)])  # 設定第一個與第三個 cols\n# 得到 \"FALSE FALSE FALSE FALSE FALSE FALSE\"\n# 表示完全沒有在第一個與第三個 cols 都重複的觀察值\n\nduplicated.rows2 <- duplicated(dupli.table[, c(1, 2)])  # 設定第一個與第二個 cols\n# 得到 \"FALSE FALSE FALSE FALSE  TRUE FALSE\"\n# 表示第五個觀察值重複了\n\nduplicated.rows3 <- duplicated(dupli.table[, 1])  # 設定第一個 cols\n# 等價於 duplicated.rows3 <- duplicated(dupli.table$ID)\n# 得到 \"FALSE FALSE FALSE FALSE  TRUE FALSE\"\n# 表示第五個觀察值重複了\ndupli.table <- dupli.table[!duplicated.rows2]\ndupli.table##            ID sex major\n## 1: E123456789   M  Econ\n## 2: N213456897   F  Math\n## 3: N123456789   M    OR\n## 4: A123456789   M    EE\n## 5: E213456897   F   Eng"},{"path":"preprocessing.html","id":"thesportsdb-nba-dataset-preprocessing","chapter":"4 資料前處理","heading":"4.3.1 TheSportsDB NBA Dataset Preprocessing","text":"上一章使用：得到的 games 儲存了許多無用的字元：首先我們要先把空的項目刪除：接著，我們想把包含 \\n 的項目刪除。但是，他們都長得不太一樣，於是我們要以 grepl(text--find, --find-) 來刪除：現在這樣就正常很多了。而現在儲存的方式是向量，我們可以將其轉成有 4 個 column 的矩陣，然後將其轉換成 data table，並冠上 column names：不過，比分還是無法計算，因為現在是兩個數字。data.table 中的函數 tstrsplit(variable, separator, keep) 可以用以切開資訊，如：因此，我們如果要新增兩個 columns，分別是 隊與 B 隊的分數，可以：得：","code":"\nlibrary(rvest)\nnbagames <- read_html(\"https://www.thesportsdb.com/season.php?l=4387&s=2020-2021\")\ngames <- html_text(html_nodes(nbagames,\"td\"))  [1] \"\"                         \"12 Dec 2020\"              \"\"                         \"\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tr00 \"\n  [5] \"Atlanta Hawks\"            \"112 - 116\"                \" Orlando Magic\"           \"12 Dec 2020\"             \n  [9] \"\"                         \"\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tr00 \" \"Detroit Pistons\"          \"84 - 90\"       \n...\ngames <- games[!games==\"\"]\ngames <- games[!grepl(\"\\n\",games)]\ngames.2021 <- as.data.table(matrix(games, ncol=4, byrow=T))\ncolnames(games.2021) <- c(\"Date\",\"TeamA\",\"Result\",\"TeamB\")\ngames.2021[, tstrsplit(Result, \"-\")]\n# 相當於 games.2021[, tstrsplit(Result, \" \", keep = c(1, 3))]        V1   V2\n   1: 112   116\n   2:  84    90\n   3: 104   125\n   4:  87    81\n   5: 127   102\n  ---          \n1217: 118   108\n1218: 120   100\n1219: 109   103\n1220: 119   123\n1221: 105    98\ngames.2021[, c(\"PointsA\", \"PointsB\"):=tstrsplit(Result, \"-\")]\ngames.2021$Result <- NULL             Date                  TeamA                 TeamB PointsA PointsB\n   1: 12 Dec 2020          Atlanta Hawks         Orlando Magic    112      116\n   2: 12 Dec 2020        Detroit Pistons       New York Knicks     84       90\n   3: 12 Dec 2020          Chicago Bulls       Houston Rockets    104      125\n   4: 12 Dec 2020     Los Angeles Lakers  Los Angeles Clippers     87       81\n   5: 12 Dec 2020 Portland Trail Blazers      Sacramento Kings    127      102\n  ---                                                                         \n1217: 09 Jul 2021           Phoenix Suns       Milwaukee Bucks    118      108\n1218: 12 Jul 2021        Milwaukee Bucks          Phoenix Suns    120      100\n1219: 15 Jul 2021        Milwaukee Bucks          Phoenix Suns    109      103\n1220: 18 Jul 2021           Phoenix Suns       Milwaukee Bucks    119      123\n1221: 21 Jul 2021        Milwaukee Bucks          Phoenix Suns    105       98"},{"path":"ggplot2.html","id":"ggplot2","chapter":"5 以 ggplot2 進行資料視覺化","heading":"5 以 ggplot2 進行資料視覺化","text":"本部分（第 5、6、7 章）要談的是資料探索。本章為 Wickham Grolemund (2016) 第 1 章內容。\nFigure 5.1: Data exploring.\n","code":""},{"path":"ggplot2.html","id":"前置作業","chapter":"5 以 ggplot2 進行資料視覺化","heading":"前置作業","text":"此章的目的則是要學習以 ggplot2 進行簡單的資料視覺化。我們先要載入 tidyverse，其包含了 ggplot2。在 Console 輸入：","code":"\nlibrary(tidyverse)"},{"path":"ggplot2.html","id":"create","chapter":"5 以 ggplot2 進行資料視覺化","heading":"5.1 創建一個 ggplot","text":"引擎大的車子相較於引擎小的車子使用更多的汽油嗎？我們可以使用 tidyverse 中 mpg 這個 data frame 來嘗試回答這個問題。其中，displ 為引擎的大小，單位是公升數；hwy 為汽車在高速公路上的燃油效率，以每加侖英里（miles per gallon, mpg）為單位，較低的話代表同樣的里程得要使用更多的油。我們可以把 displ 放在 \\(x\\) 軸，而把 hwy 放在 \\(y\\) 軸，創建一個 ggplot：ggplot() 可以創造一個座標系統，而我們可以在上面加上圖層。其中，第一個引數為此圖所要使用的 dataset，例如此處為 ggplot(dataset=mpg)，但這時候不會得到任何東西，只有一張空白的圖。而我們可以再加上其他圖層，如使用 geom_point()，可以用來繪製散佈圖（scatterplot）。而 geom_point() 函數有引數 mapping，與 aes() 搭配使用，可以讓我們指定 \\(x\\) 軸與 \\(y\\) 軸分別要是什麼變數。此外，從此圖看起來，引擎大小與燃油效率呈現負向關係，即引擎更大的車，使用更多油。","code":"\nmpg## # A tibble: 234 × 11\n##    manufacturer model      displ  year   cyl trans drv     cty   hwy fl    class\n##    <chr>        <chr>      <dbl> <int> <int> <chr> <chr> <int> <int> <chr> <chr>\n##  1 audi         a4           1.8  1999     4 auto… f        18    29 p     comp…\n##  2 audi         a4           1.8  1999     4 manu… f        21    29 p     comp…\n##  3 audi         a4           2    2008     4 manu… f        20    31 p     comp…\n##  4 audi         a4           2    2008     4 auto… f        21    30 p     comp…\n##  5 audi         a4           2.8  1999     6 auto… f        16    26 p     comp…\n##  6 audi         a4           2.8  1999     6 manu… f        18    26 p     comp…\n##  7 audi         a4           3.1  2008     6 auto… f        18    27 p     comp…\n##  8 audi         a4 quattro   1.8  1999     4 manu… 4        18    26 p     comp…\n##  9 audi         a4 quattro   1.8  1999     4 auto… 4        16    25 p     comp…\n## 10 audi         a4 quattro   2    2008     4 manu… 4        20    28 p     comp…\n## # … with 224 more rows\nggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy))"},{"path":"ggplot2.html","id":"the-layered-grammar-of-graphics","chapter":"5 以 ggplot2 進行資料視覺化","heading":"5.2 The Layered Grammar of Graphics","text":"ggplot2 的語法大致如下，層層堆疊各種函數。在 geom 中，除了 mapping=aes()，我們還可以加上其他種類的 stat 與 “position adjustment”；若有需要，也可以加上不同的「座標系統」與 “facet function”。以下將逐一簡介這些參數（以 <> 包圍的字串）的使用方式。","code":"ggplot(data = <DATA>) + \n  <GEOM_FUNCTION>(\n    mapping = aes(<MAPPINGS>),\n    stat = <STAT>,\n    position = <POSITION>)+\n    <COORDINATE_FUNCTION> +\n    <FACET_FUNCTION>"},{"path":"ggplot2.html","id":"aesthetic-mappings","chapter":"5 以 ggplot2 進行資料視覺化","heading":"5.3 Aesthetic Mappings","text":"我們可以新增第三個變數，例如 mpg 中的 class 到兩向度的散佈圖，讓上面的點映射到 aesthetic。Aesthetic 是一種物件的視覺性質，包含了點的 color、size、shape 等。使用 aesthetic 在 aes() 中使用 aesthetic.name = variable.name 即可，而如果我們不想要旁邊的圖例，可以使用 show.legend = FALSE，如：此外，如果我們映射 color 到一個邏輯條件，則如：我們也可以使用 size = class。但要注意的是此時會出現 Warning，因為把一個無序的變數 class 映射到一個有序的 aesthetic size 並不是一個好方法：我們也可以映射 class 到 alpha 或 shape，分別代表透明度與形狀，但也都會出現 Warning：我們也可以從 geom 手動選擇 aesthetic properties，例如我們可以在 geom() 中加上 color = \"blue\"，讓所有點都變成藍色：這樣的話，就只是改變顏色，顏色並未傳達更多資訊。不過，事實上 ggplot2 也可以手動設置 aesthetic，不過此處從略。","code":"\n# ggplot(data = mpg) + \n#   geom_point(mapping = aes(x = displ, y = hwy, color = class), show.legend = FALSE)\nggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, color = class))\nggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, color = displ < 5))\nggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, size = class))## Warning: Using size for a discrete variable is not advised.\nggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, alpha = class))## Warning: Using alpha for a discrete variable is not advised.\nggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, shape = class))## Warning: The shape palette can deal with a maximum of 6 discrete values because\n## more than 6 becomes difficult to discriminate; you have 7. Consider\n## specifying shapes manually if you must have them.## Warning: Removed 62 rows containing missing values (geom_point).\nggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy), color = \"blue\")"},{"path":"ggplot2.html","id":"facets","chapter":"5 以 ggplot2 進行資料視覺化","heading":"5.4 Facets","text":"注意：類別變數才能繪製成 facets！除了把變數映射到 aesthetics，我們也可以把類別變數繪製成 facets，即分別繪製資料不同的子集。要繪製 facets，我們可以使用 facet_wrap()，其第一個引數是一個 formula，即 ~ 變數名稱。此外，也可以 nrow 或 ncol 來指定要有幾個 rows 或 columns。如我們要根據 class 來繪製 facets，而排成兩個 rows 的形式，即：如果我們要把 facets 畫成兩個變數的組合，那就必須使用 facet_gird()，其語法如 facet_grid(row ~ col)。以下的例子，因為 drv 共有三種值：4、f、r，而 cyl 共有四種值：4、5、6、8，所以：如果 row 或 column 其中一者不想要有變數，可以使用 facet_grid()。","code":"\nggplot(data = mpg) +\n      geom_point(mapping = aes(x = displ, y = hwy)) +\n      facet_wrap(~ class, nrow = 2)\nggplot(data = mpg) +\n      geom_point(mapping = aes(x = displ, y = hwy)) +\n      facet_grid(drv ~ cyl)"},{"path":"ggplot2.html","id":"幾何物件","chapter":"5 以 ggplot2 進行資料視覺化","heading":"5.5 幾何物件","text":"Geom 是一種圖用來表示資料的幾何物件。例如，bar charts 使用 bar geoms，line charts 使用 line geoms，boxplots 使用 boxplot geoms 等。要改變圖的 geom，即改變 ggplot() 所加的 geom function，例如我們把剛剛的 geom_point() 改成 geom_smooth 的話將會得到：我們也可以設置 aesthetic。雖然不能設置線的 shape，但可以設定線的 linetype。例如，我們可以根據變數 drv 來繪製三條不同的線：或者也可以疊加兩種 geom：如果把引數放在 ggplot() 中，則會被視為 global mapping，將會套用到圖中的所有 geom；而放在 geom() 中則會被視為 local mapping，只會套用到該 geom。所以上述的程式碼也可以簡化為：","code":"\n# 對於 geom_smooth() 中的 method 與 formula 用法可見其文檔\nggplot(data = mpg) +\n      geom_smooth(mapping = aes(x = displ, y = hwy), method = 'loess', formula = 'y ~ x')\nggplot(data = mpg) + \n  geom_smooth(mapping = aes(x = displ, y = hwy, linetype = drv),\n              method = \"loess\", formula = \"y ~ x\")\nggplot(data = mpg) + \n  geom_smooth(mapping = aes(x = displ, y = hwy, color = drv, linetype = drv),\n              method = \"loess\", formula = \"y ~ x\") + \n  geom_point(mapping = aes(x = displ, y = hwy, color = drv))\nggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = drv)) + \n  geom_smooth(aes(linetype = drv), method = \"loess\", formula = \"y ~ x\") + \n  geom_point()"},{"path":"ggplot2.html","id":"統計轉換","chapter":"5 以 ggplot2 進行資料視覺化","heading":"5.6 統計轉換","text":"diamonds 是 ggplot2 中的一個 dataset，約有 54000 顆鑽石的資料，包含 carat、cut、color、clarity、depth、table、price 等變數。使用 geom_bar() 可以依據某個變數畫出長條圖（bar chart），例如我們想要知道各種 cuts 到底有分別有多少鑽石，可以：在此，\\(x\\) 軸為 cut，是 diamonds 中的變數；\\(y\\) 軸為 count，並非 diamonds 中的變數，而是自動計算在各個 cut 中鑽石的數量。某些圖會計算新的變數然，例如：長條圖、直方圖（histogram）或 frequency polygons 都會計算個數。Smoothers 會適配模型然後畫出預測。Boxplots 會計算分佈。用來計算新的值的演算法稱之為 stat，為 statistical transformation 的簡稱。例如以 ?geom_bar 查看 geom_bar() 的幫助頁面，會發現其使用 stat_count()。因為每個 geom 都有一個預設的 stat，反之亦然，所以我們可以把 geom 與 stat 交換使用。也因此，如果把上圖的 geom_bar() 換成 stat_count() 也會到相同的結果。什麼時候需要明確地使用 stat 呢？想要替換預設的 stat 的時候。想要替換預設的 stat 的時候。想要換原本的 mapping 時。想要換原本的 mapping 時。想要使用其他的 statistical transformation 的時候。例如使用 stat_summary()，其會對每個 x 都 summarizes 其 y。","code":"\nggplot(data = diamonds) + geom_bar(mapping = aes(x = cut))\nggplot(data = diamonds) +\n  geom_bar(\n    mapping = aes(x = cut, y = ..prop.., group = 1)\n  )\nggplot(data = diamonds) +\n  stat_summary(\n    mapping = aes(x = cut, y = depth),\n    fun.min = min,\n    fun.max = max,\n    fun = median\n  )"},{"path":"ggplot2.html","id":"position-adjustment","chapter":"5 以 ggplot2 進行資料視覺化","heading":"5.7 Position Adjustment","text":"想要為長條圖著色，除了使用 color，還可以使用 fill，兩者的效果也不同：如果 fill 指定為另一個變數的話，就會自動變成「堆疊」的形式，如：這種堆疊是透過位置調整（position adjustment）進行的。position 預設為 position=\"stack\"，而我們還能把 position 指定成其他三種選項：identity、dodge 與 fill：position = \"identity\"：用在 bar chart 上效果有點像 stack，但差別在調整透明度後可以看出來（即 alpha = 1/5）；雖然還是不明顯，但差別在 identity 的各個物件是會相互堆疊的。例如在下圖中，調整透明度明明應該所有物件的透明度都相同，但越靠下的部分透明度顯然越低，這就是因為越靠下的部分有越多個物件重疊在一起，使得圖形顯得較不透明。position = \"fill\"：依據指定的變數（此數為 clarity）堆疊，差別在高度相同，所以便於我們比較組間的比例差別。position = \"dodge\"：以此例而言，即是對於每個不同的 cut，都分別把其各個 clarity 展現在逐一呈現，而非用堆疊的方式。此外，當然還有其他 position 的引數可用，例如 position = \"jitter\"，其在 bar chart 中沒什麼用，但在散佈圖中有大用。回憶節 5.1 的散佈圖：事實上，mpg 明明有 234 個觀察值，如：但上面的散佈圖卻只有顯示 126 個點，為什麼？因為 overplotting！有些點的座標相同，所以相互覆蓋了。設置 position = \"jitter\" 可以解決這個問題，這會在每個點加入一點點 random noise，排除 overplotting 的問題。","code":"\nggplot(data = diamonds) +\n  geom_bar(mapping = aes(x = cut, color = cut))\nggplot(data = diamonds) +\n  geom_bar(mapping = aes(x = cut, fill = cut))\nggplot(data = diamonds, mapping = aes(x = cut, fill = clarity)) + \n  geom_bar()\nggplot(data = diamonds, mapping = aes(x = cut, fill = clarity)) +\n  geom_bar(alpha = 1/5, position = \"identity\")\nggplot(data = diamonds, mapping = aes(x = cut, fill = clarity)) +\n  geom_bar(position = \"fill\")\nggplot(data = diamonds, mapping = aes(x = cut, fill = clarity)) +\n  geom_bar(position = \"dodge\")\nggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy))\nstr(mpg)\n# tibble [234 × 11] (S3: tbl_df/tbl/data.frame)\n# ...\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + \n  geom_point(position = \"jitter\")"},{"path":"ggplot2.html","id":"coordinatedsystem","chapter":"5 以 ggplot2 進行資料視覺化","heading":"5.8 座標系統","text":"除了前面使用的笛卡兒座標系統，還有其他有用的座標系統：coord_flip()：繪製旋轉 90 度的直角坐標，如：coord_quickmap()：繪製有正確方位比例的地圖4，如：coord_polar()：繪製極座標圖（polar coordinates），結合 bar char 與 Coxcomb chart，如：coord_fixed：因為人對與 45 度線的差異感受最明顯，而 coord_fixed() 可以讓 geom_abline()（用以產生 reference lines 的 geom）產生的線為 45 度，如：","code":"\nggplot(data = mpg, mapping = aes(x = class, y = hwy)) + geom_boxplot()\nggplot(data = mpg, mapping = aes(x = class, y = hwy)) + geom_boxplot() + coord_flip()\nnz <- map_data(\"nz\")\n\nggplot(nz, aes(long, lat, group = group)) + \n  geom_polygon(fill = \"white\", color = \"black\")\nggplot(nz, aes(long, lat, group = group)) + \n  geom_polygon(fill = \"white\", color = \"black\") + coord_quickmap()\nbar <- ggplot(data = diamonds) +\n  geom_bar(mapping = aes(x = cut, fill = cut), show.legend = FALSE, width = 1) +\n  theme(aspect.ratio = 1) + labs(x = NULL, y = NULL)\n\nbar + coord_polar()\np <- ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) +\n  geom_point() + geom_abline()\n\np + coord_fixed()  # 如果不加 coord_fixed()，比例將會跑掉。"},{"path":"ggplot2.html","id":"標籤-1","chapter":"5 以 ggplot2 進行資料視覺化","heading":"5.9 標籤","text":"labs() 能使我們為圖加上標題、註解或更改 x 軸、y 軸的名稱，如：","code":"\nggplot(data = mpg, mapping = aes(x = class, y = hwy)) + \n  geom_boxplot() + \n  coord_flip() +\n  labs(y = \"Highway MPG\",\n       x = \"Class\",\n       title = \"Highway MPG by car class\",\n       subtitle = \"1999-2008\",\n       caption = \"Source: http://fueleconomy.gov\")"},{"path":"dplyr.html","id":"dplyr","chapter":"6 以 dplyr 轉換資料","heading":"6 以 dplyr 轉換資料","text":"本章為 Wickham Grolemund (2016) 第 3 章內容。","code":""},{"path":"dplyr.html","id":"前言","chapter":"6 以 dplyr 轉換資料","heading":"6.1 前言","text":"一拿到資料，除了以視覺化的方式快速洞察資料的樣貌，我們可能還需要：新增新的變數。新增新的變數。統整。統整。重新命名變數。重新命名變數。重新排列觀察值的順序。重新排列觀察值的順序。dplyr 的某些功能也能以 data.table 完成，並且兩者各有所長（data.table 的介紹可見節 4.1），而本章將要介紹 dplyr，為 tidyverse 中一個重要的成員，用以資料轉換。本章的任務是以 nycflights13 資料為例，簡介 dplyr 的使用。","code":""},{"path":"dplyr.html","id":"前置作業-1","chapter":"6 以 dplyr 轉換資料","heading":"6.1.1 前置作業","text":"先載入 nycflights13 與 tidyverse：要注意的是，dplyr 與 base R 一套件 stats 的某些函數名稱相同，如 filter 與 lag。如果是先載入 stats，後載入 dplyr 的話，則使用 filter() 將會是 dplyr 的 filter，這時候如果還想使用 stats 的 filter()，則需使用其全名，即 stats::filter()。反之，如果是先載入 dplyr，後載入 stats，則使用 filter() 將會使用到 stats 的 filter()，這時候如果還想使用 dplyr 的 filter()，亦須使用全名，即 dplyr::filter()。","code":"\nlibrary(nycflights13)\nlibrary(tidyverse)"},{"path":"dplyr.html","id":"nycflights13","chapter":"6 以 dplyr 轉換資料","heading":"6.1.2 nycflights13","text":"我們將使用 nycflights13 中的 flights 這個 dataset，此 data frame 包含 336,776 個觀察值，並有 19 個變數。我們也可以看到，變數名稱下方有諸如 <int>、<dbl> 等代號，即變數的型態：int 代表整數。int 代表整數。dbl 代表 doubles 或實數。dbl 代表 doubles 或實數。chr 代表字元向量或字串。chr 代表字元向量或字串。dttm 代表日期時間（date-times）。dttm 代表日期時間（date-times）。lgl 代表 logical，即 TRUE 或 FALSE 的向量。lgl 代表 logical，即 TRUE 或 FALSE 的向量。fctr 代表 factors，即類別變數。fctr 代表 factors，即類別變數。date 代表時間。date 代表時間。","code":"\nflights## # A tibble: 336,776 × 19\n##     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n##    <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n##  1  2013     1     1      517            515         2      830            819\n##  2  2013     1     1      533            529         4      850            830\n##  3  2013     1     1      542            540         2      923            850\n##  4  2013     1     1      544            545        -1     1004           1022\n##  5  2013     1     1      554            600        -6      812            837\n##  6  2013     1     1      554            558        -4      740            728\n##  7  2013     1     1      555            600        -5      913            854\n##  8  2013     1     1      557            600        -3      709            723\n##  9  2013     1     1      557            600        -3      838            846\n## 10  2013     1     1      558            600        -2      753            745\n## # … with 336,766 more rows, and 11 more variables: arr_delay <dbl>,\n## #   carrier <chr>, flight <int>, tailnum <chr>, origin <chr>, dest <chr>,\n## #   air_time <dbl>, distance <dbl>, hour <dbl>, minute <dbl>, time_hour <dttm>"},{"path":"dplyr.html","id":"基礎-dplyr","chapter":"6 以 dplyr 轉換資料","heading":"6.1.3 基礎 dplyr","text":"本章將會簡介 6 個 dplyr 函數，即：在節 6.2 以 filter() 選取某些觀察值。在節 6.2 以 filter() 選取某些觀察值。在節 6.3 以 arrange() 重新排列 rows。在節 6.3 以 arrange() 重新排列 rows。在節 6.4 以 select() 選取變數。在節 6.4 以 select() 選取變數。在節 6.5 以 mutate() 與現存變數的函數創造新的變數。在節 6.5 以 mutate() 與現存變數的函數創造新的變數。在節 6.6 以 summarize() 摘要資料。在節 6.6 以 summarize() 摘要資料。以 group_by() 比較群組之間的關係。以 group_by() 比較群組之間的關係。我們的工作就是在第一個引數丟入一個 data frame，並在第二個引數描述要對其做什麼，然後得到一個新的 data frame。","code":""},{"path":"dplyr.html","id":"filter","chapter":"6 以 dplyr 轉換資料","heading":"6.2 Filter Rows with filter()","text":"我們可以用 filter 來選取某些觀察值，例如：因為 filter() 會創造一個新的 data frame，而不會更動原先輸入的那個 data frame，所以","code":"\nfilter(flights, month == 1, day == 1)## # A tibble: 842 × 19\n##     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n##    <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n##  1  2013     1     1      517            515         2      830            819\n##  2  2013     1     1      533            529         4      850            830\n##  3  2013     1     1      542            540         2      923            850\n##  4  2013     1     1      544            545        -1     1004           1022\n##  5  2013     1     1      554            600        -6      812            837\n##  6  2013     1     1      554            558        -4      740            728\n##  7  2013     1     1      555            600        -5      913            854\n##  8  2013     1     1      557            600        -3      709            723\n##  9  2013     1     1      557            600        -3      838            846\n## 10  2013     1     1      558            600        -2      753            745\n## # … with 832 more rows, and 11 more variables: arr_delay <dbl>, carrier <chr>,\n## #   flight <int>, tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>,\n## #   distance <dbl>, hour <dbl>, minute <dbl>, time_hour <dttm>"},{"path":"dplyr.html","id":"比較","chapter":"6 以 dplyr 轉換資料","heading":"6.2.1 比較","text":"我們可以用比較運算子，如 >=、<、<=、!= 或 == 等來選取觀察值。","code":""},{"path":"dplyr.html","id":"邏輯運算子","chapter":"6 以 dplyr 轉換資料","heading":"6.2.2 邏輯運算子","text":"我們也可以運用邏輯運算子，如 & 即 “”，| 即 “” 而 ! 即 “”（切記不要用成 && 或 ||！）。例如我們可以透過以下的程式碼找出 month 恰等於 11 或 12 的觀察值：上述的程式碼也有一種簡寫，即 x %% y，將會選出所有 x 等於其中一個 y 的觀察值。上述的程式碼因此可以寫成：我們如果想要找到 arr_delay 不超過 120 且 dep_delay 也不超過 120 的觀察值，下面兩行等價的程式碼都能達成：","code":"\nfilter(flights, month == 11 | month == 12)## # A tibble: 55,403 × 19\n##     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n##    <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n##  1  2013    11     1        5           2359         6      352            345\n##  2  2013    11     1       35           2250       105      123           2356\n##  3  2013    11     1      455            500        -5      641            651\n##  4  2013    11     1      539            545        -6      856            827\n##  5  2013    11     1      542            545        -3      831            855\n##  6  2013    11     1      549            600       -11      912            923\n##  7  2013    11     1      550            600       -10      705            659\n##  8  2013    11     1      554            600        -6      659            701\n##  9  2013    11     1      554            600        -6      826            827\n## 10  2013    11     1      554            600        -6      749            751\n## # … with 55,393 more rows, and 11 more variables: arr_delay <dbl>,\n## #   carrier <chr>, flight <int>, tailnum <chr>, origin <chr>, dest <chr>,\n## #   air_time <dbl>, distance <dbl>, hour <dbl>, minute <dbl>, time_hour <dttm>\nfilter(flights, month %in% c(11, 12))\nfilter(flights, !(arr_delay > 120 | dep_delay > 120))\nfilter(flights, arr_delay <= 120, dep_delay <= 120)"},{"path":"dplyr.html","id":"缺漏值","chapter":"6 以 dplyr 轉換資料","heading":"6.2.3 缺漏值","text":"filter() 只會選取邏輯判斷為 TRUE 的觀察值，而排除 FALSE 或 NA。如果也想選取 NA，則要明白地寫出來：","code":"\ndf <- tibble(x = c(1, NA, 3))\nfilter(df, x > 1)## # A tibble: 1 × 1\n##       x\n##   <dbl>\n## 1     3\nfilter(df, is.na(x) | x > 1)## # A tibble: 2 × 1\n##       x\n##   <dbl>\n## 1    NA\n## 2     3"},{"path":"dplyr.html","id":"arrange","chapter":"6 以 dplyr 轉換資料","heading":"6.3 Arrange Rows with arrange()","text":"使用 arrange() 可以改變觀察值的排列順序。使用 desc() 可以製造由大至小的排列，如：缺漏值永遠排在最後，無論採用由小至大或由大至小的排列方式：","code":"\narrange(flights, year, month, day)  # 先排前面的引數，由小至大排列## # A tibble: 336,776 × 19\n##     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n##    <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n##  1  2013     1     1      517            515         2      830            819\n##  2  2013     1     1      533            529         4      850            830\n##  3  2013     1     1      542            540         2      923            850\n##  4  2013     1     1      544            545        -1     1004           1022\n##  5  2013     1     1      554            600        -6      812            837\n##  6  2013     1     1      554            558        -4      740            728\n##  7  2013     1     1      555            600        -5      913            854\n##  8  2013     1     1      557            600        -3      709            723\n##  9  2013     1     1      557            600        -3      838            846\n## 10  2013     1     1      558            600        -2      753            745\n## # … with 336,766 more rows, and 11 more variables: arr_delay <dbl>,\n## #   carrier <chr>, flight <int>, tailnum <chr>, origin <chr>, dest <chr>,\n## #   air_time <dbl>, distance <dbl>, hour <dbl>, minute <dbl>, time_hour <dttm>\narrange(flights, desc(dep_time), day)## # A tibble: 336,776 × 19\n##     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n##    <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n##  1  2013     4     2     2400           2359         1      339            343\n##  2  2013     9     2     2400           2359         1      411            340\n##  3  2013     4     4     2400           2355         5      347            345\n##  4  2013    12     5     2400           2359         1      427            440\n##  5  2013     2     7     2400           2359         1      432            436\n##  6  2013     2     7     2400           2359         1      443            444\n##  7  2013     7     7     2400           1950       250      107           2130\n##  8  2013    12     9     2400           2359         1      432            440\n##  9  2013    12     9     2400           2250        70       59           2356\n## 10  2013     8    10     2400           2245        75      110              1\n## # … with 336,766 more rows, and 11 more variables: arr_delay <dbl>,\n## #   carrier <chr>, flight <int>, tailnum <chr>, origin <chr>, dest <chr>,\n## #   air_time <dbl>, distance <dbl>, hour <dbl>, minute <dbl>, time_hour <dttm>\ndf <- tibble(x = c(5, 2, NA))\narrange(df, x)## # A tibble: 3 × 1\n##       x\n##   <dbl>\n## 1     2\n## 2     5\n## 3    NA\narrange(df, desc(x))## # A tibble: 3 × 1\n##       x\n##   <dbl>\n## 1     5\n## 2     2\n## 3    NA"},{"path":"dplyr.html","id":"select","chapter":"6 以 dplyr 轉換資料","heading":"6.4 Select Columns with select()","text":"filter() 與 arrange() 處理的對象是 rows，而 select() 處理的則是 columns。我們可以透過 select()，快速地選取指定的變數，如：或者：","code":"\nselect(flights, year, month, day)## # A tibble: 336,776 × 3\n##     year month   day\n##    <int> <int> <int>\n##  1  2013     1     1\n##  2  2013     1     1\n##  3  2013     1     1\n##  4  2013     1     1\n##  5  2013     1     1\n##  6  2013     1     1\n##  7  2013     1     1\n##  8  2013     1     1\n##  9  2013     1     1\n## 10  2013     1     1\n## # … with 336,766 more rows\nselect(flights, year:day)  # 選擇 year 至 day 之間所有的 columns\nselect(flights, -(year:day))  # 選擇 year 至 day 以外的所有 columns"},{"path":"dplyr.html","id":"常用的-5-個函數","chapter":"6 以 dplyr 轉換資料","heading":"6.4.1 常用的 5 個函數","text":"select() 之中還有幾個常用的函數可用，如：start_with(\"abc\")：選取名稱以 “abc” 開頭的變數。start_with(\"abc\")：選取名稱以 “abc” 開頭的變數。ends_with(\"abc\")：選取名稱以 “abc” 結尾的變數。ends_with(\"abc\")：選取名稱以 “abc” 結尾的變數。contains(\"abc\")：選取名稱中包含 “abc” 的變數。contains(\"abc\")：選取名稱中包含 “abc” 的變數。matches(\"abc$\")：選取名稱符合正規表示式的變數，此例中為名稱以 “abc” 結尾的變數。正規表示式將會在第 12 章介紹。matches(\"abc$\")：選取名稱符合正規表示式的變數，此例中為名稱以 “abc” 結尾的變數。正規表示式將會在第 12 章介紹。num_range(\"x\", 1:3)：選取名為 x1、x2、x3 的變數。num_range(\"x\", 1:3)：選取名為 x1、x2、x3 的變數。以下為範例：","code":"\nselect(flights, starts_with(\"d\"))  # 選取名稱以 \"d\" 開頭的變數## # A tibble: 336,776 × 5\n##      day dep_time dep_delay dest  distance\n##    <int>    <int>     <dbl> <chr>    <dbl>\n##  1     1      517         2 IAH       1400\n##  2     1      533         4 IAH       1416\n##  3     1      542         2 MIA       1089\n##  4     1      544        -1 BQN       1576\n##  5     1      554        -6 ATL        762\n##  6     1      554        -4 ORD        719\n##  7     1      555        -5 FLL       1065\n##  8     1      557        -3 IAD        229\n##  9     1      557        -3 MCO        944\n## 10     1      558        -2 ORD        733\n## # … with 336,766 more rows\nselect(flights, ends_with(\"t\"))  # 選取名稱以 \"t\" 結尾的變數## # A tibble: 336,776 × 2\n##    flight dest \n##     <int> <chr>\n##  1   1545 IAH  \n##  2   1714 IAH  \n##  3   1141 MIA  \n##  4    725 BQN  \n##  5    461 ATL  \n##  6   1696 ORD  \n##  7    507 FLL  \n##  8   5708 IAD  \n##  9     79 MCO  \n## 10    301 ORD  \n## # … with 336,766 more rows\nselect(flights, contains(\"ep\"))  # 選取名稱中包含 \"ep\" 的變數## # A tibble: 336,776 × 3\n##    dep_time sched_dep_time dep_delay\n##       <int>          <int>     <dbl>\n##  1      517            515         2\n##  2      533            529         4\n##  3      542            540         2\n##  4      544            545        -1\n##  5      554            600        -6\n##  6      554            558        -4\n##  7      555            600        -5\n##  8      557            600        -3\n##  9      557            600        -3\n## 10      558            600        -2\n## # … with 336,766 more rows\nselect(flights, matches(\"time$\"))  # 選取名稱以 \"time\" 結尾的變數## # A tibble: 336,776 × 5\n##    dep_time sched_dep_time arr_time sched_arr_time air_time\n##       <int>          <int>    <int>          <int>    <dbl>\n##  1      517            515      830            819      227\n##  2      533            529      850            830      227\n##  3      542            540      923            850      160\n##  4      544            545     1004           1022      183\n##  5      554            600      812            837      116\n##  6      554            558      740            728      150\n##  7      555            600      913            854      158\n##  8      557            600      709            723       53\n##  9      557            600      838            846      140\n## 10      558            600      753            745      138\n## # … with 336,766 more rows"},{"path":"dplyr.html","id":"重新命名rename","chapter":"6 以 dplyr 轉換資料","heading":"6.4.2 重新命名：rename()","text":"有兩種重新命名變數的方法：使用 select(資料, 新變數名稱 = 舊變數名稱, everything())。之所以要加 everything 是因為如果不加，select() 將會丟棄其他所有變數，而 everything() 的用途即在補上其他 columns。使用 select(資料, 新變數名稱 = 舊變數名稱, everything())。之所以要加 everything 是因為如果不加，select() 將會丟棄其他所有變數，而 everything() 的用途即在補上其他 columns。使用 rename(資料, 新變數名稱 = 舊變數名稱)。使用 rename(資料, 新變數名稱 = 舊變數名稱)。此外，因為 everything() 可以補上其他沒有選到的 columns，所以也可以用來移動變數的順序，如我們想要把 dep_time 與 arr_time 移到前面的話，即：","code":"\nselect(flights, dep_time, arr_time, everything())## # A tibble: 336,776 × 19\n##    dep_time arr_time  year month   day sched_dep_time dep_delay sched_arr_time\n##       <int>    <int> <int> <int> <int>          <int>     <dbl>          <int>\n##  1      517      830  2013     1     1            515         2            819\n##  2      533      850  2013     1     1            529         4            830\n##  3      542      923  2013     1     1            540         2            850\n##  4      544     1004  2013     1     1            545        -1           1022\n##  5      554      812  2013     1     1            600        -6            837\n##  6      554      740  2013     1     1            558        -4            728\n##  7      555      913  2013     1     1            600        -5            854\n##  8      557      709  2013     1     1            600        -3            723\n##  9      557      838  2013     1     1            600        -3            846\n## 10      558      753  2013     1     1            600        -2            745\n## # … with 336,766 more rows, and 11 more variables: arr_delay <dbl>,\n## #   carrier <chr>, flight <int>, tailnum <chr>, origin <chr>, dest <chr>,\n## #   air_time <dbl>, distance <dbl>, hour <dbl>, minute <dbl>, time_hour <dttm>"},{"path":"dplyr.html","id":"mutate","chapter":"6 以 dplyr 轉換資料","heading":"6.5 Add New Variables with mutate()","text":"我們還會想新增 columns 為既有 columns 的函數，那就要使用 mutate()。我們先新建一個小一點的表格，方便查看結果，然後新增兩個 columns，其一為 gain，為 arr_delay 減去 ep_delay；其一為 speed，為 distance 除以 air_time 再乘以 60：也可以在後面的引數中，使用前面的引數剛新增出來的 columns，如：只想要保存新變數的話，可以用 transmute()，如：而如果新建的變數名稱與既有的變數名稱相同，則會覆蓋之，即既有的變數值被替換成 mutate() 中所指定的運算方法所得的變數值。","code":"\nflights_sml <- select(flights, year:day, ends_with(\"delay\"), distance, air_time)\n\nmutate(flights_sml,\n       gain = arr_delay - dep_delay,\n       speed = distance / air_time * 60)## # A tibble: 336,776 × 9\n##     year month   day dep_delay arr_delay distance air_time  gain speed\n##    <int> <int> <int>     <dbl>     <dbl>    <dbl>    <dbl> <dbl> <dbl>\n##  1  2013     1     1         2        11     1400      227     9  370.\n##  2  2013     1     1         4        20     1416      227    16  374.\n##  3  2013     1     1         2        33     1089      160    31  408.\n##  4  2013     1     1        -1       -18     1576      183   -17  517.\n##  5  2013     1     1        -6       -25      762      116   -19  394.\n##  6  2013     1     1        -4        12      719      150    16  288.\n##  7  2013     1     1        -5        19     1065      158    24  404.\n##  8  2013     1     1        -3       -14      229       53   -11  259.\n##  9  2013     1     1        -3        -8      944      140    -5  405.\n## 10  2013     1     1        -2         8      733      138    10  319.\n## # … with 336,766 more rows\nmutate(flights_sml,\n       gain = arr_delay - dep_delay,\n       hours = air_time / 60,\n       gain_per_hour = gain / hours)\ntransmute(flights_sml,\n       gain = arr_delay - dep_delay,\n       hours = air_time / 60,\n       gain_per_hour = gain / hours)## # A tibble: 336,776 × 3\n##     gain hours gain_per_hour\n##    <dbl> <dbl>         <dbl>\n##  1     9 3.78           2.38\n##  2    16 3.78           4.23\n##  3    31 2.67          11.6 \n##  4   -17 3.05          -5.57\n##  5   -19 1.93          -9.83\n##  6    16 2.5            6.4 \n##  7    24 2.63           9.11\n##  8   -11 0.883        -12.5 \n##  9    -5 2.33          -2.14\n## 10    10 2.3            4.35\n## # … with 336,766 more rows"},{"path":"dplyr.html","id":"useful-creation-functions","chapter":"6 以 dplyr 轉換資料","heading":"6.5.1 Useful Creation Functions","text":"創建新 columns 有一些常用的、有用的運算子或函數：Arithmetic operators. +, -, *, /, ^.Arithmetic operators. +, -, *, /, ^.Modular arithmetic. %/% %%.\n%/% 為整數除法，而 %% 為餘數。\n如：30 %/% 4 等於 4；3 %% 2 等於 1。\nModular arithmetic. %/% %%.%/% 為整數除法，而 %% 為餘數。%/% 為整數除法，而 %% 為餘數。如：30 %/% 4 等於 4；3 %% 2 等於 1。如：30 %/% 4 等於 4；3 %% 2 等於 1。Logs. log(), log2(), log10()Logs. log(), log2(), log10()Logical comparisons. <, <=, >, >=, !=.Logical comparisons. <, <=, >, >=, !=.Offsets. lead() lag().\nlead() 可以用來指涉 leading values，而 lag() 可以用來指涉 lagging values。與 group_by() 一起使用有很大的用處。\n例如 x <- 1 : 10。lead(x) 會是 2 3 4 5 6 7 8 9 10 NA，而 lag(x) 會是 NA 1 2 3 4 5 6 7 8 9。\nOffsets. lead() lag().lead() 可以用來指涉 leading values，而 lag() 可以用來指涉 lagging values。與 group_by() 一起使用有很大的用處。lead() 可以用來指涉 leading values，而 lag() 可以用來指涉 lagging values。與 group_by() 一起使用有很大的用處。例如 x <- 1 : 10。lead(x) 會是 2 3 4 5 6 7 8 9 10 NA，而 lag(x) 會是 NA 1 2 3 4 5 6 7 8 9。例如 x <- 1 : 10。lead(x) 會是 2 3 4 5 6 7 8 9 10 NA，而 lag(x) 會是 NA 1 2 3 4 5 6 7 8 9。Logical comparisons. <, <=, >, >=, !=.Logical comparisons. <, <=, >, >=, !=.Ranking. min_rank(), row_number(), dense_rank(), percent_rank(), cume_dist(), ntile().\nmin_rank()：依序輸入的向量中的元素依序報出向量各元素的大小排名（由小而大），重複的順序將會跳號。如 y <- c(3, 4, 5, 2, 1)，第一個元素是第 3 小，第二個元素是第 4 小，第三個元素是第 5 小，第四個元素是第 2 小，第五個元素最小，因此回傳 3 4 5 2 1。而我們也可以搭配使用 desc()，則第一個元素是第 3 大，第二個元素是第 2 大，以此類推，將會回傳 3 2 1 4 5。\nrow_number：類似 min_rank()，但如果有重複的元素，將會把較前面的排的比較小。例如 z <- c(1, 1, 0, 2, 3)，輸入 min_rank() 將會回傳 2 2 1 4 5；而輸入 row_number() 將會回傳 2 3 1 4 5。\ndense_rank()：類似 min_rank()，但重複的順序不會跳號，如 z <- c(1, 1, 0, 2, 3)，輸入 dense_rank() 將會回傳 2 2 1 3 4。\npercent_rank(y)：min_rank() 的百分比版本。\ncume_dist(y)：min_rank() 的累積版本。\nRanking. min_rank(), row_number(), dense_rank(), percent_rank(), cume_dist(), ntile().min_rank()：依序輸入的向量中的元素依序報出向量各元素的大小排名（由小而大），重複的順序將會跳號。如 y <- c(3, 4, 5, 2, 1)，第一個元素是第 3 小，第二個元素是第 4 小，第三個元素是第 5 小，第四個元素是第 2 小，第五個元素最小，因此回傳 3 4 5 2 1。而我們也可以搭配使用 desc()，則第一個元素是第 3 大，第二個元素是第 2 大，以此類推，將會回傳 3 2 1 4 5。min_rank()：依序輸入的向量中的元素依序報出向量各元素的大小排名（由小而大），重複的順序將會跳號。如 y <- c(3, 4, 5, 2, 1)，第一個元素是第 3 小，第二個元素是第 4 小，第三個元素是第 5 小，第四個元素是第 2 小，第五個元素最小，因此回傳 3 4 5 2 1。而我們也可以搭配使用 desc()，則第一個元素是第 3 大，第二個元素是第 2 大，以此類推，將會回傳 3 2 1 4 5。row_number：類似 min_rank()，但如果有重複的元素，將會把較前面的排的比較小。例如 z <- c(1, 1, 0, 2, 3)，輸入 min_rank() 將會回傳 2 2 1 4 5；而輸入 row_number() 將會回傳 2 3 1 4 5。row_number：類似 min_rank()，但如果有重複的元素，將會把較前面的排的比較小。例如 z <- c(1, 1, 0, 2, 3)，輸入 min_rank() 將會回傳 2 2 1 4 5；而輸入 row_number() 將會回傳 2 3 1 4 5。dense_rank()：類似 min_rank()，但重複的順序不會跳號，如 z <- c(1, 1, 0, 2, 3)，輸入 dense_rank() 將會回傳 2 2 1 3 4。dense_rank()：類似 min_rank()，但重複的順序不會跳號，如 z <- c(1, 1, 0, 2, 3)，輸入 dense_rank() 將會回傳 2 2 1 3 4。percent_rank(y)：min_rank() 的百分比版本。percent_rank(y)：min_rank() 的百分比版本。cume_dist(y)：min_rank() 的累積版本。cume_dist(y)：min_rank() 的累積版本。Cumulative rolling aggregates. cumsum(), cumprod(), cummin(), cummax(), cummean().\n前四者為 R 本身提供，cummean() 為 dplyr 所提供。\n分別可以計算 running sums、products、mins、maxes 與 cumulative means，例如：\nCumulative rolling aggregates. cumsum(), cumprod(), cummin(), cummax(), cummean().前四者為 R 本身提供，cummean() 為 dplyr 所提供。前四者為 R 本身提供，cummean() 為 dplyr 所提供。分別可以計算 running sums、products、mins、maxes 與 cumulative means，例如：分別可以計算 running sums、products、mins、maxes 與 cumulative means，例如：","code":"\ny<-c(1, 2, 2, NA, 3, 4)\nmin_rank(y)\n# [1]  1  2  2 NA  4  5\nrow_number(y)\n# [1]  1  2  3 NA  4  5\nrow_number(y)\n# [1]  1  2  3 NA  4  5\ndense_rank(y)\n# [1]  1  2  2 NA  3  4\npercent_rank(y)\n# [1] 0.00 0.25 0.25   NA 0.75 1.00\ncume_dist(y)\n# [1] 0.2 0.6 0.6  NA 0.8 1.0\nx <- 1 : 10\ncumsum(x)\n#  [1]  1  3  6 10 15 21 28 36 45 55\ncumprod(x)\n#  [1]       1       2       6      24     120     720    5040   40320  362880\n# [10] 3628800\ncummin(x)\n#  [1] 1 1 1 1 1 1 1 1 1 1\ncummax(x)\n#  [1]  1  2  3  4  5  6  7  8  9 10\ncummean(x)\n#  [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5"},{"path":"dplyr.html","id":"summarize","chapter":"6 以 dplyr 轉換資料","heading":"6.6 Grouped Summaries with summarize()","text":"summarize() 會把整個表格整理成單一個 row。我們可以使用 summarize() 來計算全部航班的 dep_delay 的平均值：其中，使用 na.rm = TRUE 的原因在避免計算出一大堆 NA，見節 6.6.2。但 summarize() 要搭配上 group_by() 才顯得更強大。如果我們想要知道每天的 dep_delay 的平均到底是多少與每天有多少個航班，我們可以使用 group_by()，將 flights 這個 dataset 依照 year、month、day 分組，然後指派給變數 by_day。接著，我們就可以使用 summarize()，並定義兩個新變數欄位為 delay 與 count，如：","code":"\nsummarize(flights, delay = mean(dep_delay, na.rm = TRUE))## # A tibble: 1 × 1\n##   delay\n##   <dbl>\n## 1  12.6\nby_day <- group_by(flights, year, month, day)\nsummarize(by_day, delay = mean(dep_delay, na.rm = TRUE), count = n())## `summarise()` has grouped output by 'year', 'month'. You can override using the `.groups` argument.## # A tibble: 365 × 5\n## # Groups:   year, month [12]\n##     year month   day delay count\n##    <int> <int> <int> <dbl> <int>\n##  1  2013     1     1 11.5    842\n##  2  2013     1     2 13.9    943\n##  3  2013     1     3 11.0    914\n##  4  2013     1     4  8.95   915\n##  5  2013     1     5  5.73   720\n##  6  2013     1     6  7.15   832\n##  7  2013     1     7  5.42   933\n##  8  2013     1     8  2.55   899\n##  9  2013     1     9  2.28   902\n## 10  2013     1    10  2.84   932\n## # … with 355 more rows"},{"path":"dplyr.html","id":"以-pipe-結合多重運算","chapter":"6 以 dplyr 轉換資料","heading":"6.6.1 以 Pipe 結合多重運算","text":"如果我們想知道距離與每個地點的平均延誤的關係，我們可以：使用 group_by，依據 dest（終點）來分類 flights。使用 group_by，依據 dest（終點）來分類 flights。使用 summarize() 製造一個新的 tibble，列出各個 dest 的次數（count）、平均距離（dist）與平均抵達延誤（delay）。使用 summarize() 製造一個新的 tibble，列出各個 dest 的次數（count）、平均距離（dist）與平均抵達延誤（delay）。使用 filter()，第一個引數放入剛剛新建的表格，然後移除 noise（出現次數小於 20 次者），並移除 “HNL” 這個終點站。使用 filter()，第一個引數放入剛剛新建的表格，然後移除 noise（出現次數小於 20 次者），並移除 “HNL” 這個終點站。上面的步驟正如：但這種撰寫程式碼的方式稍嫌惱人，因為我們還要幫中間的 data frame 取名字。使用 pipe %>% 可以解決此問題：%>% 可以讀成 “”，即我們先使用 group_by 分組，然後使用 summarize() 計算次數與平均數，然後使用 filter() 過濾掉噪點與不想要的觀察值。這背後的邏輯就是 x %>% f(y) 即 f(x, y)，而 x %>% f(y) %>% g(z) 即 g(f(x, y), z)。","code":"\nby_dest <- group_by(flights, dest)\ndelay <- summarize(by_dest, count = n(), dist = mean(distance, na.rm = TRUE),\n                   delay = mean(arr_delay, na.rm = TRUE))  # 整理資料\n\ndelay <- filter(delay, count > 20, dest != \"HNL\")  # 移除噪點\n\nggplot(data = delay, mapping = aes(x = dist, y = delay)) +\n  geom_point(aes(size = count), alpha = 1/3) +\n  geom_smooth(method = 'loess', formula = \"y ~ x\", se = FALSE)  # 繪圖\ndelays <- flights %>%\n  group_by(dest) %>%\n  summarize(count = n(),\n            dist = mean(distance, na.rm = TRUE),\n            delay = mean(arr_delay, na.rm = TRUE)) %>%\n  filter(count > 20, dest != \"HNL\")"},{"path":"dplyr.html","id":"missingvaluesdplyr","chapter":"6 以 dplyr 轉換資料","heading":"6.6.2 缺漏值","text":"前開使用的 na.rm 引數的功能即決定要不要在計算前移除掉 NA。如果我們沒有設定 na.rm = TRUE，則我們將會製造出一大堆 NA，因為 NA 無論做什麼運算都會得到 NA，所以只要有其中一個觀察值的 dep_delay 為 NA，那一整天的平均就會是 NA，如：我們可以發現製造了 358 個 NA！以下就不會產生上面的問題了：在此，NA 代表航班取消；我們也可以先把 NA 的地方去除掉，如：","code":"\nflights %>%\n  group_by(year, month, day) %>%\n  summarize(mean = mean(dep_delay)) %>%\n  group_by(mean) %>%\n  summarize(count = n())## `summarise()` has grouped output by 'year', 'month'. You can override using the `.groups` argument.## # A tibble: 8 × 2\n##     mean count\n##    <dbl> <int>\n## 1  0.145     1\n## 2  0.241     1\n## 3  1.61      1\n## 4  3.53      1\n## 5  6.06      1\n## 6  7.78      1\n## 7  7.93      1\n## 8 NA       358\nflights %>%\n  group_by(year, month, day) %>%\n  summarize(mean = mean(dep_delay, na.rm = TRUE))\nnot_cancelled <- flights %>%\n  filter(!is.na(dep_delay), !is.na(arr_delay))\n\nnot_cancelled %>%\n  group_by(year, month, day) %>%\n  summarize(mean = mean(dep_delay))## `summarise()` has grouped output by 'year', 'month'. You can override using the `.groups` argument.## # A tibble: 365 × 4\n## # Groups:   year, month [12]\n##     year month   day  mean\n##    <int> <int> <int> <dbl>\n##  1  2013     1     1 11.4 \n##  2  2013     1     2 13.7 \n##  3  2013     1     3 10.9 \n##  4  2013     1     4  8.97\n##  5  2013     1     5  5.73\n##  6  2013     1     6  7.15\n##  7  2013     1     7  5.42\n##  8  2013     1     8  2.56\n##  9  2013     1     9  2.30\n## 10  2013     1    10  2.84\n## # … with 355 more rows"},{"path":"dplyr.html","id":"計數","chapter":"6 以 dplyr 轉換資料","heading":"6.6.3 計數","text":"我們可以加入計數（n()）或非缺漏值的計數（sum(!.na(x))），避免我們從很小的樣本得出結論。我們可以發現，有些航班甚至可以延遲超過 300 秒！但我們如果畫出散佈圖就會發現，如果只有少數幾個航班的日子，取平均以後其變異就會非常大，即樣本越大，變異越小（類似大數法則中，當樣本越來越大，估計參數會機率收斂到母體參數的概念），如：所以我們其實可以移除掉樣本過小的日期，如：我們接下來使用 Lahman 這個套件中的 Batting 這個 data frame 來討論棒球比賽中打擊者的表現與擊球次數的關係。我們可以發現，打擊次數越多的球員，打擊率也就越高，兩者有正向的關係；這可能是因為球隊會讓能打球的球員上場。","code":"\ndelays <- not_cancelled %>%\n  group_by(tailnum) %>%\n  summarize(delay = mean(arr_delay))\n\nggplot(data = delays, mapping = aes(x = delay)) +\n  geom_freqpoly(binwidth = 10)\ndelays <- not_cancelled %>%\n  group_by(tailnum) %>%\n  summarize(delay = mean(arr_delay, na.rm = TRUE),n=n())\n\nggplot(data = delays, mapping = aes(x = n, y = delay)) +\n  geom_point(alpha = 1/10)\ndelays %>%\n  filter(n > 25) %>%\n  ggplot(mapping = aes(x = n, y = delay)) + geom_point(alpha = 1/10)\nlibrary(Lahman)  # 載入 Lahman\nbatting <- as_tibble(Lahman::Batting)  # 將 Batting 轉換成 tibble 型態\n\nbatters <- batting %>%\n  group_by(playerID) %>%\n  summarize(ba = sum(H, na.rm = TRUE) / sum(AB, na.rm = TRUE),\n            ab = sum(AB, na.rm = TRUE) )\n\n# ba 為 batting average，即打擊率，衡量打擊的能力\n# ab 為 at bat，即上場打擊的機會\n\nbatters %>%\n  filter(ab > 100) %>%\n  ggplot(mapping = aes(x = ab, y = ba)) + geom_point() +\n    geom_smooth(se = FALSE)## `geom_smooth()` using method = 'gam' and formula 'y ~ s(x, bs = \"cs\")'"},{"path":"dplyr.html","id":"有用的歸納函數","chapter":"6 以 dplyr 轉換資料","heading":"6.6.4 有用的歸納函數","text":"Measures location: mean(x), median(x).Measures spread: sd(x), IQR(x), mad(x).\n標準差、四分位距（interquartile range）與絕對中位差（median absolute deviation，即原數據減去中位數所得的新數據的絕對值的中位數）。\n\\(\\mbox{MAD} = \\mbox{median}(|X_i - \\mbox{median}|)\\).\nMeasures spread: sd(x), IQR(x), mad(x).標準差、四分位距（interquartile range）與絕對中位差（median absolute deviation，即原數據減去中位數所得的新數據的絕對值的中位數）。\\(\\mbox{MAD} = \\mbox{median}(|X_i - \\mbox{median}|)\\).Measures rank: min(x), quantile(x, 0.25), max(x).\nquantile(x, 0.25) 即大於 25 % 的樣本但小於剩餘的 75 % 者。\nMeasures rank: min(x), quantile(x, 0.25), max(x).quantile(x, 0.25) 即大於 25 % 的樣本但小於剩餘的 75 % 者。Measures position: first(x), nth(x, 2), last(x).Counts: n(), sum(!.na(x)), n_distinct(x):.\nsum(!.na(x)): non-missing values.\nn_distinct(x): number distinct (unique) values.\nCounts: n(), sum(!.na(x)), n_distinct(x):.sum(!.na(x)): non-missing values.n_distinct(x): number distinct (unique) values.Counts proportions logical values: sum(x > 10), mean(y == 0).\n如果這些邏輯判斷式為真，那就會回傳 TRUE，反之則回傳 FALSE。\n據此，我們可以使用 sum() 來得知符合這些條件的有多少，而使用 mean() 來得知符合條件的比例。\nCounts proportions logical values: sum(x > 10), mean(y == 0).如果這些邏輯判斷式為真，那就會回傳 TRUE，反之則回傳 FALSE。據此，我們可以使用 sum() 來得知符合這些條件的有多少，而使用 mean() 來得知符合條件的比例。","code":"\nnot_cancelled %>%\n  group_by(year, month, day) %>%\n  summarize(\n    # average delay:\n    avg_delay1 = mean(arr_delay),\n    # average positive delay:\n    avg_delay2 = mean(arr_delay[arr_delay > 0])\n)## `summarise()` has grouped output by 'year', 'month'. You can override using the `.groups` argument.## # A tibble: 365 × 5\n## # Groups:   year, month [12]\n##     year month   day avg_delay1 avg_delay2\n##    <int> <int> <int>      <dbl>      <dbl>\n##  1  2013     1     1     12.7         32.5\n##  2  2013     1     2     12.7         32.0\n##  3  2013     1     3      5.73        27.7\n##  4  2013     1     4     -1.93        28.3\n##  5  2013     1     5     -1.53        22.6\n##  6  2013     1     6      4.24        24.4\n##  7  2013     1     7     -4.95        27.8\n##  8  2013     1     8     -3.23        20.8\n##  9  2013     1     9     -0.264       25.6\n## 10  2013     1    10     -5.90        27.3\n## # … with 355 more rows\n# 算出不同目的地的距離標準差，並降冪排列\nnot_cancelled %>%\n  group_by(dest) %>%\n  summarize(distance_sd = sd(distance)) %>%\n  arrange(desc(distance_sd))## # A tibble: 104 × 2\n##    dest  distance_sd\n##    <chr>       <dbl>\n##  1 EGE         10.5 \n##  2 SAN         10.4 \n##  3 SFO         10.2 \n##  4 HNL         10.0 \n##  5 SEA          9.98\n##  6 LAS          9.91\n##  7 PDX          9.87\n##  8 PHX          9.86\n##  9 LAX          9.66\n## 10 IND          9.46\n## # … with 94 more rows\n# 算出每天第一班與最後一班班機\nnot_cancelled %>%\n  group_by(year, month, day) %>%\n  summarize(\n    first = min(dep_time),\n    last = max(dep_time)\n  )## `summarise()` has grouped output by 'year', 'month'. You can override using the `.groups` argument.## # A tibble: 365 × 5\n## # Groups:   year, month [12]\n##     year month   day first  last\n##    <int> <int> <int> <int> <int>\n##  1  2013     1     1   517  2356\n##  2  2013     1     2    42  2354\n##  3  2013     1     3    32  2349\n##  4  2013     1     4    25  2358\n##  5  2013     1     5    14  2357\n##  6  2013     1     6    16  2355\n##  7  2013     1     7    49  2359\n##  8  2013     1     8   454  2351\n##  9  2013     1     9     2  2252\n## 10  2013     1    10     3  2320\n## # … with 355 more rows\n# 找出每天第一班與最後一班班機\nnot_cancelled %>%\n  group_by(year, month, day) %>%\n  summarize(\n    first = min(dep_time),\n    last = max(dep_time)\n  )## `summarise()` has grouped output by 'year', 'month'. You can override using the `.groups` argument.## # A tibble: 365 × 5\n## # Groups:   year, month [12]\n##     year month   day first  last\n##    <int> <int> <int> <int> <int>\n##  1  2013     1     1   517  2356\n##  2  2013     1     2    42  2354\n##  3  2013     1     3    32  2349\n##  4  2013     1     4    25  2358\n##  5  2013     1     5    14  2357\n##  6  2013     1     6    16  2355\n##  7  2013     1     7    49  2359\n##  8  2013     1     8   454  2351\n##  9  2013     1     9     2  2252\n## 10  2013     1    10     3  2320\n## # … with 355 more rows\nnot_cancelled %>%\n  group_by(year, month, day) %>%\n  mutate(r = min_rank(desc(dep_time))) %>%\n  filter(r %in% range(r))## # A tibble: 770 × 20\n## # Groups:   year, month, day [365]\n##     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n##    <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n##  1  2013     1     1      517            515         2      830            819\n##  2  2013     1     1     2356           2359        -3      425            437\n##  3  2013     1     2       42           2359        43      518            442\n##  4  2013     1     2     2354           2359        -5      413            437\n##  5  2013     1     3       32           2359        33      504            442\n##  6  2013     1     3     2349           2359       -10      434            445\n##  7  2013     1     4       25           2359        26      505            442\n##  8  2013     1     4     2358           2359        -1      429            437\n##  9  2013     1     4     2358           2359        -1      436            445\n## 10  2013     1     5       14           2359        15      503            445\n## # … with 760 more rows, and 12 more variables: arr_delay <dbl>, carrier <chr>,\n## #   flight <int>, tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>,\n## #   distance <dbl>, hour <dbl>, minute <dbl>, time_hour <dttm>, r <int>\nnot_cancelled %>%\n  group_by(dest) %>%\n  summarize(carriers = n_distinct(carrier)) %>%\n  arrange(desc(carriers))## # A tibble: 104 × 2\n##    dest  carriers\n##    <chr>    <int>\n##  1 ATL          7\n##  2 BOS          7\n##  3 CLT          7\n##  4 ORD          7\n##  5 TPA          7\n##  6 AUS          6\n##  7 DCA          6\n##  8 DTW          6\n##  9 IAD          6\n## 10 MSP          6\n## # … with 94 more rows\n# 因為 count() 太常用了\n# 所以甚至不用 summerize() 就可以直接使用\nnot_cancelled %>%\n  count(dest)\n# 甚至可以在引數 wt 加上權重\n# 如下算出各飛機的總里程\nnot_cancelled %>%\n  count(tailnum, wt = distance)## # A tibble: 4,037 × 2\n##    tailnum      n\n##    <chr>    <dbl>\n##  1 D942DN    3418\n##  2 N0EGMQ  239143\n##  3 N10156  109664\n##  4 N102UW   25722\n##  5 N103US   24619\n##  6 N104UW   24616\n##  7 N10575  139903\n##  8 N105UW   23618\n##  9 N107US   21677\n## 10 N108UW   32070\n## # … with 4,027 more rows\n# 如果我們想得知每天離開時間小於 500 的班次數目，可以如下\nnot_cancelled %>%\n  group_by(year, month, day) %>%\n  summarize(n_early = sum(dep_time < 500))## `summarise()` has grouped output by 'year', 'month'. You can override using the `.groups` argument.## # A tibble: 365 × 4\n## # Groups:   year, month [12]\n##     year month   day n_early\n##    <int> <int> <int>   <int>\n##  1  2013     1     1       0\n##  2  2013     1     2       3\n##  3  2013     1     3       4\n##  4  2013     1     4       3\n##  5  2013     1     5       3\n##  6  2013     1     6       2\n##  7  2013     1     7       2\n##  8  2013     1     8       1\n##  9  2013     1     9       3\n## 10  2013     1    10       3\n## # … with 355 more rows\n# 如果我們想得知每天延誤超過一小時的航班的比例，可以如下\nnot_cancelled %>%\n  group_by(year, month, day) %>%\n  summarize(hour_perc = mean(arr_delay > 60))## `summarise()` has grouped output by 'year', 'month'. You can override using the `.groups` argument.## # A tibble: 365 × 4\n## # Groups:   year, month [12]\n##     year month   day hour_perc\n##    <int> <int> <int>     <dbl>\n##  1  2013     1     1    0.0722\n##  2  2013     1     2    0.0851\n##  3  2013     1     3    0.0567\n##  4  2013     1     4    0.0396\n##  5  2013     1     5    0.0349\n##  6  2013     1     6    0.0470\n##  7  2013     1     7    0.0333\n##  8  2013     1     8    0.0213\n##  9  2013     1     9    0.0202\n## 10  2013     1    10    0.0183\n## # … with 355 more rows"},{"path":"dplyr.html","id":"依據多變數分組","chapter":"6 以 dplyr 轉換資料","heading":"6.6.5 依據多變數分組","text":"像撥洋蔥一樣，但不太可能適用於有牽涉到排序的統計量，如中位數。","code":"\ndaily <- group_by(flights, year, month, day)\n(per_day <-summarize(daily,flights=n()))## `summarise()` has grouped output by 'year', 'month'. You can override using the `.groups` argument.## # A tibble: 365 × 4\n## # Groups:   year, month [12]\n##     year month   day flights\n##    <int> <int> <int>   <int>\n##  1  2013     1     1     842\n##  2  2013     1     2     943\n##  3  2013     1     3     914\n##  4  2013     1     4     915\n##  5  2013     1     5     720\n##  6  2013     1     6     832\n##  7  2013     1     7     933\n##  8  2013     1     8     899\n##  9  2013     1     9     902\n## 10  2013     1    10     932\n## # … with 355 more rows\n(per_month <- summarize(per_day, flights = sum(flights)))## `summarise()` has grouped output by 'year'. You can override using the `.groups` argument.## # A tibble: 12 × 3\n## # Groups:   year [1]\n##     year month flights\n##    <int> <int>   <int>\n##  1  2013     1   27004\n##  2  2013     2   24951\n##  3  2013     3   28834\n##  4  2013     4   28330\n##  5  2013     5   28796\n##  6  2013     6   28243\n##  7  2013     7   29425\n##  8  2013     8   29327\n##  9  2013     9   27574\n## 10  2013    10   28889\n## 11  2013    11   27268\n## 12  2013    12   28135\n(per_year <- summarize(per_month, flights = sum(flights)))## # A tibble: 1 × 2\n##    year flights\n##   <int>   <int>\n## 1  2013  336776"},{"path":"dplyr.html","id":"取消分組","chapter":"6 以 dplyr 轉換資料","heading":"6.6.6 取消分組","text":"使用 ungroup() 可以取消分組，如下：","code":"\ndaily %>%\n  ungroup() %>% # no longer grouped by date\n  summarize(flights = n())## # A tibble: 1 × 1\n##   flights\n##     <int>\n## 1  336776"},{"path":"dplyr.html","id":"grouped-mutates-and-filters","chapter":"6 以 dplyr 轉換資料","heading":"6.7 Grouped Mutates (and Filters)","text":"除了與 summarize() 共同使用，group_by 與 mutate() 及 filter() 共同使用也很方便，例如：找每組最差的成員：找到所有大於某個閾值的組別：標準化：","code":"\nflights_sml %>%\n  group_by(year, month, day) %>%\n  filter(rank(desc(arr_delay)) < 10)## # A tibble: 3,306 × 7\n## # Groups:   year, month, day [365]\n##     year month   day dep_delay arr_delay distance air_time\n##    <int> <int> <int>     <dbl>     <dbl>    <dbl>    <dbl>\n##  1  2013     1     1       853       851      184       41\n##  2  2013     1     1       290       338     1134      213\n##  3  2013     1     1       260       263      266       46\n##  4  2013     1     1       157       174      213       60\n##  5  2013     1     1       216       222      708      121\n##  6  2013     1     1       255       250      589      115\n##  7  2013     1     1       285       246     1085      146\n##  8  2013     1     1       192       191      199       44\n##  9  2013     1     1       379       456     1092      222\n## 10  2013     1     2       224       207      550       94\n## # … with 3,296 more rows\npopular_dests <- flights %>%\n  group_by(dest) %>%\n  filter(n() > 365)\npopular_dests## # A tibble: 332,577 × 19\n## # Groups:   dest [77]\n##     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n##    <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n##  1  2013     1     1      517            515         2      830            819\n##  2  2013     1     1      533            529         4      850            830\n##  3  2013     1     1      542            540         2      923            850\n##  4  2013     1     1      544            545        -1     1004           1022\n##  5  2013     1     1      554            600        -6      812            837\n##  6  2013     1     1      554            558        -4      740            728\n##  7  2013     1     1      555            600        -5      913            854\n##  8  2013     1     1      557            600        -3      709            723\n##  9  2013     1     1      557            600        -3      838            846\n## 10  2013     1     1      558            600        -2      753            745\n## # … with 332,567 more rows, and 11 more variables: arr_delay <dbl>,\n## #   carrier <chr>, flight <int>, tailnum <chr>, origin <chr>, dest <chr>,\n## #   air_time <dbl>, distance <dbl>, hour <dbl>, minute <dbl>, time_hour <dttm>\npopular_dests %>%\n  filter(arr_delay > 0) %>%\n  mutate(prop_delay = arr_delay / sum(arr_delay)) %>%\n  select(year:day, dest, arr_delay, prop_delay)## # A tibble: 131,106 × 6\n## # Groups:   dest [77]\n##     year month   day dest  arr_delay prop_delay\n##    <int> <int> <int> <chr>     <dbl>      <dbl>\n##  1  2013     1     1 IAH          11  0.000111 \n##  2  2013     1     1 IAH          20  0.000201 \n##  3  2013     1     1 MIA          33  0.000235 \n##  4  2013     1     1 ORD          12  0.0000424\n##  5  2013     1     1 FLL          19  0.0000938\n##  6  2013     1     1 ORD           8  0.0000283\n##  7  2013     1     1 LAX           7  0.0000344\n##  8  2013     1     1 DFW          31  0.000282 \n##  9  2013     1     1 ATL          12  0.0000400\n## 10  2013     1     1 DTW          16  0.000116 \n## # … with 131,096 more rows"},{"path":"EDA.html","id":"EDA","chapter":"7 探索性資料分析","heading":"7 探索性資料分析","text":"本章為 Wickham Grolemund (2016) 第 5 章內容。資料一拿來就先跑跑看長什麼樣子！","code":""},{"path":"EDA.html","id":"事前準備","chapter":"7 探索性資料分析","heading":"7.1 事前準備","text":"探索性資料分析（Exploratory Data Analysis, EDA）的目標就是要更了解資料，而步驟可以為：構思關於這筆資料的問題。構思關於這筆資料的問題。透過視覺化、轉換和建模，試著尋找答案。透過視覺化、轉換和建模，試著尋找答案。經由所得的結果，重整原先的問題，或者構思、增加新的問題。經由所得的結果，重整原先的問題，或者構思、增加新的問題。","code":""},{"path":"EDA.html","id":"問題","chapter":"7 探索性資料分析","heading":"7.2 問題","text":"Far better approximate answer right question, often vague, exact answer wrong question, can always made precise.—John Tukey你可以問這兩類的問題：type variation occurs within variables?type variation occurs within variables?type covariation occurs variables?type covariation occurs variables?","code":""},{"path":"EDA.html","id":"variation","chapter":"7 探索性資料分析","heading":"7.3 Variation","text":"Variation 即每次測量變數值所得的趨勢（tendency）。每個變數都有自己的 variation，而要看出 variation，最好的方法是視覺化變數值的分配。","code":""},{"path":"EDA.html","id":"視覺化分配","chapter":"7 探索性資料分析","heading":"7.3.1 視覺化分配","text":"如果是類別變數，我們可以使用 bar chart 來視覺化，因為它只有一小組變數值，而存成 factors 或 characters 的向量，如：也可以使用 dplyr 的 count() 來計算究竟各種品質的鑽石有多少，如：如果是連續變數，例如數字與日期時間，我們則要使用 histogram，如：我們也可以用 count() 來計算，如：如果想要重疊多個直方圖，使用 geom_frepoly() 而非 geom_histogram()。兩者的算法一樣，但前者以線來呈現，後者以直方來呈現，如：","code":"\nggplot(data = diamonds) +\n  geom_bar(mapping = aes(x = cut))\ndiamonds %>%\n  count(cut)## # A tibble: 5 × 2\n##   cut           n\n##   <ord>     <int>\n## 1 Fair       1610\n## 2 Good       4906\n## 3 Very Good 12082\n## 4 Premium   13791\n## 5 Ideal     21551\n# binwidth 引數即直方圖的直方寬度\nggplot(data = diamonds) +\n  geom_histogram(mapping = aes(x = carat), binwidth = 0.5)\ndiamonds %>%\n  count(cut_width(carat, 0.5))## # A tibble: 11 × 2\n##    `cut_width(carat, 0.5)`     n\n##    <fct>                   <int>\n##  1 [-0.25,0.25]              785\n##  2 (0.25,0.75]             29498\n##  3 (0.75,1.25]             15977\n##  4 (1.25,1.75]              5313\n##  5 (1.75,2.25]              2002\n##  6 (2.25,2.75]               322\n##  7 (2.75,3.25]                32\n##  8 (3.25,3.75]                 5\n##  9 (3.75,4.25]                 4\n## 10 (4.25,4.75]                 1\n## 11 (4.75,5.25]                 1\nggplot(data = diamonds, mapping = aes(x = carat, color = cut)) +\n  geom_freqpoly(binwidth = 0.1)"},{"path":"EDA.html","id":"代表性的變數值","chapter":"7 探索性資料分析","heading":"7.3.2 代表性的變數值","text":"哪些是變數值經常出現？哪些變數值很少出現？其中有什麼規律？為何克拉數為整數與某些常見的有理數的觀察值特別多？為何每個高峰的右側都比左側更緩？為何超過 3 克拉的鑽石很稀有？類似的值的群集（cluster）通常意味著資料中有子群（subgroup）。我們可以質問幾個問題：每個 subgroup 中的觀察值與其他 subgroups 之間有何相異或相似？每個 subgroup 中的觀察值與其他 subgroups 之間有何相異或相似？如何描述或解釋群集？如何描述或解釋群集？為何群集的外觀可能產生誤導？為何群集的外觀可能產生誤導？","code":"\nggplot(data = diamonds, mapping = aes(x = carat)) +\n  geom_histogram(binwidth = 0.01)"},{"path":"EDA.html","id":"不尋常的變數值","chapter":"7 探索性資料分析","heading":"7.3.3 不尋常的變數值","text":"Outliers 即不尋常的變數值，可能源自資料輸入錯誤，也可能是一些不一樣的東西。要注意的是，當樣本很大時，使用直方圖很難看出 outliers；例如上一張圖中，事實上 3 克拉到 5 克拉之間都還有觀察值，可是從直方圖幾乎看不出來。我們可以透過 coord_cartesian()，來改變 y 軸的上下限，這樣就可以辨識稀有的觀察值了，如：或者，我們也可以使用 dplyr，列出寬度小於 3 mm 或超過 20 mm 的觀察值：我們可以發現，寬度等於 0 mm 的鑽石根本不可能存在，顯然是打錯了；而寬度為 31.8 mm 與 58.9 mm 那兩個觀察值的價格也不合理。此種錯誤（像是輸入錯誤）所出現的 outliers 就該丟掉。但也不是逢 outliers 就該丟掉，如果其有真實的意義，那還是必須保留。","code":"\nggplot(diamonds) +\n  geom_histogram(mapping = aes(x = y), binwidth = 0.5) +\n  coord_cartesian(ylim = c(0, 50))\nunusual <- diamonds %>%\n  filter(y < 3 | y > 20) %>%\n  arrange(y)\n\nunusual## # A tibble: 9 × 10\n##   carat cut       color clarity depth table price     x     y     z\n##   <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n## 1  1    Very Good H     VS2      63.3    53  5139  0      0    0   \n## 2  1.14 Fair      G     VS1      57.5    67  6381  0      0    0   \n## 3  1.56 Ideal     G     VS2      62.2    54 12800  0      0    0   \n## 4  1.2  Premium   D     VVS1     62.1    59 15686  0      0    0   \n## 5  2.25 Premium   H     SI2      62.8    59 18034  0      0    0   \n## 6  0.71 Good      F     SI2      64.1    60  2130  0      0    0   \n## 7  0.71 Good      F     SI2      64.1    60  2130  0      0    0   \n## 8  0.51 Ideal     E     VS1      61.8    55  2075  5.15  31.8  5.12\n## 9  2    Premium   H     SI2      58.9    57 12210  8.09  58.9  8.06"},{"path":"EDA.html","id":"missing-value","chapter":"7 探索性資料分析","heading":"7.4 Missing Value","text":"","code":""},{"path":"EDA.html","id":"替換掉-outliers","chapter":"7 探索性資料分析","heading":"7.4.1 替換掉 Outliers","text":"遇到 outliers，有兩種做法：丟棄有奇怪的變數值的觀察值。可是，其中一個變數輸入錯誤不代表其他變數就也輸入錯誤。而且如果資料品質不良，可能最後什麼都不剩。（推薦）把 outliers 的變數值換成 NA。我們可以使用 mutate() 與 ifelse()，如：","code":"\n# 丟棄有奇怪的變數值的觀察\ndiamonds2 <- diamonds %>%\n  filter(between(y, 3, 20))\n# 把 outliers 的變數值換成 NA\ndiamonds2 <- diamonds %>%\n  mutate(y = ifelse(y < 3 | y > 20, NA, y))\n# 這樣畫出來的散佈圖就不會是 y 的 outliers\nggplot(data = diamonds2, mapping = aes(x = x, y = y)) +\n  geom_point(na.rm = TRUE)  # 注意：設定 na.rm = TRUE，忽略掉 NA"},{"path":"EDA.html","id":"比較-na-與否","chapter":"7 探索性資料分析","heading":"7.4.2 比較 NA 與否","text":"有時候我們想了解具有 NA 的觀察值與有變數值的觀察值有何區別，那我們就可以使用 mutate() 與 .na() 來記錄。在 nycflights13 的 flights 中，dep_time 如果是 NA，那表示航班取消。當我們想要比較取消航班與為取消航班之間的預計離開時間的差別，我們可以：不過，因為未取消航班比取消的航班多太多了，因此下個章節我們要對此做些改進。","code":"\nnycflights13::flights %>%\n  mutate(\n    cancelled = is.na(dep_time),\n    sched_hour = sched_dep_time %/% 100,\n    sched_min = sched_dep_time %% 100,\n    sched_dep_time = sched_hour + sched_min / 60) %>%\n  ggplot(mapping = aes(sched_dep_time)) +\n  geom_freqpoly(mapping = aes(color = cancelled), binwidth = 1/4)"},{"path":"EDA.html","id":"covariation","chapter":"7 探索性資料分析","heading":"7.5 Covariation","text":"Covariation 即兩個或多個變數變動的關係。想要發覺 covariation，最好的辦法就是視覺化它。但如何視覺化則牽涉到變數型態的問題。","code":""},{"path":"EDA.html","id":"類別與連續變數","chapter":"7 探索性資料分析","heading":"7.5.1 類別與連續變數","text":"為什麼我們剛剛所使用的 geom_freqpoly() 不太適合拿來「比較」變數？這是因為，geom_freqpoly() 的高度（縱軸）是出現次數，所以說如果有一組遠小於另一組，像剛剛的情況，那我們就很難看出其形狀的差異。以下還有另一個例子為比較不同品質的鑽石之間的價格差異：這種時候，我們可以把 \\(y\\) 軸從呈現 “count”，改成呈現 “density”，即經過標準化的 count，在每組的多邊形底下的面積都為 \\(1\\)，如：另一種把連續變數拆成類別變數然後呈現的方法是使用箱形圖（box plot），其可以把某些分佈的特徵給視覺化；即每個箱形圖中的箱子的底部都是 25 百分位，而頂部都是 75 百分位，箱子的中間則是中位數。我們可以大略看出分佈與偏態，而箱形圖中的點則是 outliers，線則是從箱子外延伸到非 outliers 的地方，如：看起來似乎 fair 的比較貴！為什麼？實際上是因為 fair 的鑽石相對比較大顆，如：類別變數經常是有序的（例如 cut），但也有些並不然。如果類別變數無序，我們又希望它按照一定的方式來排序呢？可以使用 reorder()。例如，在 mpg 這個 dataset 中，class 其實是無序的，我們想知道各種 class 的 hwy 的話，以箱形圖描繪，就如：那如果我們想要依照中位數來排序 class 的變數值的話，根據說明文檔，reorder 的語法如：因此可以：也可以仿效節 (coordinatedsystem) 的作法，加上 coord_flip()，將箱形圖旋轉 90 度，如：","code":"\nggplot(data = diamonds, mapping = aes(x = price)) +\n  geom_freqpoly(mapping = aes(color = cut), binwidth = 500)\nggplot(data = diamonds, mapping = aes(x = price, y = ..density..)) +\n  geom_freqpoly(mapping = aes(color = cut), binwidth = 500)\nggplot(data = diamonds, mapping = aes(x = cut, y = price)) +\n  geom_boxplot()\nggplot(data = diamonds, mapping = aes(x = cut, y = carat)) +\n  geom_boxplot()\nggplot(data = mpg, mapping = aes(x = class, y = hwy)) +\n  geom_boxplot()\nreorder(x, X, FUN = mean, ...,\n        order = is.ordered(x))\nggplot(data = mpg) +\n  geom_boxplot(mapping = aes(\n    x = reorder(class, hwy, FUN = median),\n    y = hwy\n  ))\nggplot(data = mpg) +\n  geom_boxplot(mapping = aes(\n    x = reorder(class, hwy, FUN = median),\n    y = hwy\n  )) + coord_flip()"},{"path":"EDA.html","id":"兩個類別變數","chapter":"7 探索性資料分析","heading":"7.5.2 兩個類別變數","text":"要視覺化兩個類別變數之間的 covariation，我們要計算各種組合有多少觀察值，如使用 geom_count()：或者以 dplyr 來計算：這也可以接著以 geom_title() 來視覺化，如：而如果類別變數是無序的，我們可能會需要使用 seration 套件來同時重新排序 rows 與 columns；如果想要畫更大的熱圖，可能會需要使用 d3heatmap 或 heatmaply 套件。","code":"\nggplot(data = diamonds) +\n  geom_count(mapping = aes(x = cut, y = color))\ndiamonds %>%\n  count(color, cut)## # A tibble: 35 × 3\n##    color cut           n\n##    <ord> <ord>     <int>\n##  1 D     Fair        163\n##  2 D     Good        662\n##  3 D     Very Good  1513\n##  4 D     Premium    1603\n##  5 D     Ideal      2834\n##  6 E     Fair        224\n##  7 E     Good        933\n##  8 E     Very Good  2400\n##  9 E     Premium    2337\n## 10 E     Ideal      3903\n## # … with 25 more rows\ndiamonds %>%\n  count(color, cut) %>%\n  ggplot(mapping = aes(x = color, y = cut)) +\n  geom_tile(mapping = aes(fill = n))"},{"path":"EDA.html","id":"兩個連續變數","chapter":"7 探索性資料分析","heading":"7.5.3 兩個連續變數","text":"要視覺化兩個連續變數的可以 geom_point() 畫出散佈圖，如：不過 overplot 的情況在小克拉的鑽石有點嚴重，因此我們可以更改透明度，如：但其實在很大的 dataset 中，更改透明度也不見得是好辦法。除了單純描繪散佈圖以外，另一個方法是使用 bin。以前的 geom_histogram() 與 geom_freqpoly() 為單向度的 bin，我們現在要使用 geom_bin2d() 與 geom_hex() 來描繪兩個向度的 bin。geom_bin2d() 與 geom_hex() 所繪製出來的圖形樣式相似，都是有二維的 bins，而使用 fill 來表示數量，差別在 geom_bin2d() 繪製出來的是矩形，而 geom_hex() 繪製出來的是六邊形，如：還有一種方式是把連續變數用 bin 拆成類別變數，然後繪製箱形圖，如下把克拉拆成類別變數：但我們如果使用箱形圖的話，要怎麼看出各個 bin 的觀察值數量呢？我們可以設置 varwidth = TRUE，這會讓箱子的寬度與觀察值的數量成比例，如：另一個看出觀察值數量的方法是使用 cut_number()，這會讓每個 bin 所包含的觀察值數量相當，以下圖而言，即克拉數大的鑽石很少：","code":"\nggplot(data = diamonds) +\n  geom_point(mapping = aes(x = carat, y = price))\nggplot(data = diamonds) +\n  geom_point(mapping = aes(x = carat, y = price),\n             alpha = 1/100)\nggplot(data = diamonds) +\n  geom_bin2d(mapping = aes(x = carat, y = price))\n# install.packages(\"hexbin\")\nlibrary(hexbin)\nggplot(data = diamonds) +\n  geom_hex(mapping = aes(x = carat, y = price))\nggplot(data = diamonds, mapping = aes(x = carat, y = price)) +\n  geom_boxplot(mapping = aes(group = cut_width(carat, 0.3)))\nggplot(data = diamonds, mapping = aes(x = carat, y = price)) +\n  geom_boxplot(mapping = aes(group = cut_width(carat, 0.3)), varwidth = TRUE)\nggplot(data = diamonds, mapping = aes(x = carat, y = price)) +\n  geom_boxplot(mapping = aes(group = cut_number(carat, 20)))"},{"path":"EDA.html","id":"模式與模型","chapter":"7 探索性資料分析","heading":"7.6 模式與模型","text":"模式（patterns）為兩個變數之間系統性的關係，如：我們可以看出，等待時間越長伴隨著更長時間的爆發。模型（models）則是從資料中萃取出 patterns 的工具。例如以 diamonds 資料集來說，我們很難弄清楚 cut 與 price 之間的關係，因為「cut 與 carat」及「carat 與 price」之間都密切相關。我們如果能使用模型移除掉 price 與 carat 之間的關係，那我們就能更清楚 cut 與 price 之間的關係。以下的程式碼就是先算出 carat 對 price 的效果，而其無法解釋的部份就在殘差項。我們能說，殘差項就撇除了 carat 對 price 的效果，那很有可能就是 cut 對 price 的效果，如：在我們移除了 carat 對 price 的效果後，很清楚地，可以看出 cut 與 price 之間的關係；即給定鑽石大小，品質越好的鑽石越貴！（非常符合直覺）我們也能從箱形圖看「品質越好的鑽石越貴」這一現象：本書之後會更深入探討關於模型的問題。","code":"\nggplot(data = faithful) +\n  geom_point(mapping = aes(x = eruptions, y = waiting))\nlibrary(modelr)\nmod <- lm(log(price) ~ log(carat), data = diamonds)\n\ndiamonds2 <- diamonds %>%\n  add_residuals(mod) %>%\n  mutate(resid = exp(resid))\n\nggplot(data = diamonds2) +\n  geom_point(mapping = aes(x = carat, y = resid))\nggplot(data = diamonds2) +\n  geom_boxplot(mapping = aes(x = cut, y = resid))"},{"path":"tibble.html","id":"tibble","chapter":"8 以 tibble 處理 Tibbles","heading":"8 以 tibble 處理 Tibbles","text":"本章為 Wickham Grolemund (2016) 第 7 章內容。本部分（第 8、9、10、11、12、13、14 章）要談的是資料整理（data wrangling）。\nFigure 8.1: Data wrangling.\n","code":""},{"path":"tibble.html","id":"創建-tibbles","chapter":"8 以 tibble 處理 Tibbles","heading":"8.1 創建 Tibbles","text":"","code":""},{"path":"tibble.html","id":"把-data-frames-轉換-tibbles","chapter":"8 以 tibble 處理 Tibbles","heading":"8.1.1 把 Data Frames 轉換 Tibbles","text":"Tibbles 也是一種 data frames。要把 data frames 轉換成 tibbles 很簡單，只要使用 as_tibble() 函數即可，如：","code":"\nas_tibble(iris)## # A tibble: 150 × 5\n##    Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n##           <dbl>       <dbl>        <dbl>       <dbl> <fct>  \n##  1          5.1         3.5          1.4         0.2 setosa \n##  2          4.9         3            1.4         0.2 setosa \n##  3          4.7         3.2          1.3         0.2 setosa \n##  4          4.6         3.1          1.5         0.2 setosa \n##  5          5           3.6          1.4         0.2 setosa \n##  6          5.4         3.9          1.7         0.4 setosa \n##  7          4.6         3.4          1.4         0.3 setosa \n##  8          5           3.4          1.5         0.2 setosa \n##  9          4.4         2.9          1.4         0.2 setosa \n## 10          4.9         3.1          1.5         0.1 setosa \n## # … with 140 more rows"},{"path":"tibble.html","id":"透過向量創建-tibbles","chapter":"8 以 tibble 處理 Tibbles","heading":"8.1.2 透過向量創建 Tibbles","text":"我們也可以透過向量來創建 tibbles，如：Tibbles 的 column 還可以取名為本來在 base R 的語法中不合法的變數名稱，即 nonsynaptic names，例如非字母開頭或者有特殊字元或空格，只要用兩個 \\ 包圍即可，而要使用這些變數的話同樣要以 \\ 來包圍，如：","code":"\ntibble(\n  x = 1 : 5,\n  y = 1,\n  z = x ^ 2 + y\n)## # A tibble: 5 × 3\n##       x     y     z\n##   <int> <dbl> <dbl>\n## 1     1     1     2\n## 2     2     1     5\n## 3     3     1    10\n## 4     4     1    17\n## 5     5     1    26\ntibble(\n  ` ` = 1 : 3,\n  `:)` = 1,\n  `2049` = ` ` ^ 2 + `:)`\n)## # A tibble: 3 × 3\n##     ` `  `:)` `2049`\n##   <int> <dbl>  <dbl>\n## 1     1     1      2\n## 2     2     1      5\n## 3     3     1     10"},{"path":"tibble.html","id":"以-transposed-tibble-tribble-創建-tibbles","chapter":"8 以 tibble 處理 Tibbles","heading":"8.1.3 以 Transposed Tibble tribble() 創建 Tibbles","text":"我們也可以 tribble()，即 transposed tribble 來創建 tibbles。使用 tribble() 的方式如下：事實上，#--/--/---- 並非必須的（也只是一個註解），但便於我們辨識變數與變數值。","code":"\ntribble(\n  ~x, ~y, ~z,\n  #--/--/----\n  \"a\", 2, 3.4,\n  \"s\", 4, NA\n)## # A tibble: 2 × 3\n##   x         y     z\n##   <chr> <dbl> <dbl>\n## 1 a         2   3.4\n## 2 s         4  NA"},{"path":"tibble.html","id":"tibbles-與-data-frames-的比較","chapter":"8 以 tibble 處理 Tibbles","heading":"8.2 Tibbles 與 Data Frames 的比較","text":"","code":""},{"path":"tibble.html","id":"printing","chapter":"8 以 tibble 處理 Tibbles","heading":"8.2.1 Printing","text":"印出 tibbles 時，預設只會印出前 10 個 rows，而每個 column 之下都會印出其型態。那如果我們想要同時看到更多觀察值怎麼辦？有以下幾種做法：使用 print()，決定要印出多少 rows 與 columns；其中，n = 2 代表印出 2 個 rows，而 width = Inf 代表印出所有 columns，如：或者使用 options(tibble.print_max = n, tibble.print_min = m)：如果有超過 m 個 rows，則只印出 n 個 rows。所以如果 tibble.print_min 設置為 Inf 則會印出所有的 rows；而 options(tibble.width = Inf) 會印出所有的 columns。或者使用 options(tibble.print_max = n, tibble.print_min = m)：如果有超過 m 個 rows，則只印出 n 個 rows。所以如果 tibble.print_min 設置為 Inf 則會印出所有的 rows；而 options(tibble.width = Inf) 會印出所有的 columns。使用 View()，最容易閱讀的方式。使用 View()，最容易閱讀的方式。","code":"\ntibble(\n  a = lubridate::now() + runif(1e3) * 86400,\n  b = lubridate::today() + runif(1e3) * 30,\n  c = 1:1e3,\n  d = runif(1e3),\n  e = sample(letters, 1e3, replace = TRUE)\n)## # A tibble: 1,000 × 5\n##    a                   b              c      d e    \n##    <dttm>              <date>     <int>  <dbl> <chr>\n##  1 2021-09-02 05:25:52 2021-09-15     1 0.944  l    \n##  2 2021-09-01 14:36:20 2021-09-05     2 0.0545 o    \n##  3 2021-09-01 13:31:45 2021-09-27     3 0.298  p    \n##  4 2021-09-01 23:00:22 2021-09-13     4 0.0660 e    \n##  5 2021-09-02 07:03:56 2021-09-05     5 0.0678 s    \n##  6 2021-09-01 16:26:15 2021-09-15     6 0.0475 x    \n##  7 2021-09-01 22:06:04 2021-09-27     7 0.683  t    \n##  8 2021-09-01 11:02:17 2021-09-29     8 0.990  o    \n##  9 2021-09-01 12:12:29 2021-09-22     9 0.455  n    \n## 10 2021-09-01 18:22:52 2021-09-23    10 0.679  t    \n## # … with 990 more rows\nnycflights13::flights %>%\n  print(n = 2, width = Inf)## # A tibble: 336,776 × 19\n##    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n##   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n## 1  2013     1     1      517            515         2      830            819\n## 2  2013     1     1      533            529         4      850            830\n##   arr_delay carrier flight tailnum origin dest  air_time distance  hour minute\n##       <dbl> <chr>    <int> <chr>   <chr>  <chr>    <dbl>    <dbl> <dbl>  <dbl>\n## 1        11 UA        1545 N14228  EWR    IAH        227     1400     5     15\n## 2        20 UA        1714 N24211  LGA    IAH        227     1416     5     29\n##   time_hour          \n##   <dttm>             \n## 1 2013-01-01 05:00:00\n## 2 2013-01-01 05:00:00\n## # … with 336,774 more rows"},{"path":"tibble.html","id":"subsetting","chapter":"8 以 tibble 處理 Tibbles","heading":"8.2.2 Subsetting","text":"如果我們要取出 tibble 的某個變數，我們需要使用 $ 與 [[，前者可以使我們取出指定的變數名稱的變數；後者除了可以使我們取出指定的變數名稱的變數以外，還能取出指定位置的變數，如新增一個 tibble：想要在此時使用 pipe 的話要記得加上 .，如：","code":"\ndf <- tibble(\n  x = runif(5),  # x 為均勻分配的 5 個數字\n  y = rnorm(5)   # y 為常態分配的 5 個數字\n)\n# Extract by name\ndf$x  # [1] 0.1552525 0.2570212 0.2929349 0.7355940 0.3282747\ndf[[\"x\"]]  # [1] 0.1552525 0.2570212 0.2929349 0.7355940 0.3282747\n\n# Extract by position\ndf[[1]]  # [1] 0.1552525 0.2570212 0.2929349 0.7355940 0.3282747\ndf %>% .$x  # [1] 0.1552525 0.2570212 0.2929349 0.7355940 0.3282747\ndf %>% .[[\"x\"]]  # [1] 0.1552525 0.2570212 0.2929349 0.7355940 0.3282747"},{"path":"tibble.html","id":"古老的程式碼","chapter":"8 以 tibble 處理 Tibbles","heading":"8.3 古老的程式碼","text":"有些古老的函數無法使用 tibble，這時候我們需要使用 .data.frame() 將 tibble 轉換回 data frame。如果 tibble 不相容於某古老的函數，那很有可能是因為 [（即 subsetting）的函數。在 tidyverse 中，多半可以不用 [，而透過 dplyr::filter() 與 dplyr::select() 來達到類似的結果。此外，在 base R 中，使用 [ 有時候會回傳一個 data frame，而有時會回傳一個向量；不過在 tibbles 中，使用 [ 都會回傳 tibble。","code":""},{"path":"readr.html","id":"readr","chapter":"9 以 readr 匯入資料","heading":"9 以 readr 匯入資料","text":"本章為 Wickham Grolemund (2016) 第 7 章內容。","code":""},{"path":"readr.html","id":"簡介","chapter":"9 以 readr 匯入資料","heading":"9.1 簡介","text":"本章要使用 tidyverse 中的 readr 來匯入資料。使用 read_csv() 可以匯入 .csv 檔，或是直接匯入 inline 的 csv 檔，如：要注意的是，read_csv 會把第一行的資料當成 column 的名稱，所以我們可以看到上面的 tibble 中，column 的名稱分別是 、b 與 c。如果我們不想要這樣的話，可以透過幾種方式：如果情況是檔案的前幾行不希望匯入的話，可以透過引數 skip = n，而或者指定 comment = \"#\" 直接註解掉，如：如果是因為資料沒有 column name 的話，可以使用 col_names = FALSE，這樣 read_csv() 就不會把第一行當作是 column names，而是使用 X1、X2、⋯⋯；所以反過來說，也可以使用 col_names 來指定 column names，如：此外，如果資料中的變數值有 NA，但以其他方式表示怎麼辦？我們可以使用引數 na 來指定資料中所用以表示缺漏值的符號，讀入時就將其轉換成 NA，如以下的資料將 NA 用 . 來表示：","code":"\nread_csv(\"a,b,c\n1,2,3\n4,5,6\")\n## # A tibble: 2 × 3\n##       a     b     c\n##   <dbl> <dbl> <dbl>\n## 1     1     2     3\n## 2     4     5     6\nread_csv(\"不想讀入第一行\n  第二行也不想\n  x,y,z\n  1,2,3\", skip = 2)\n\nread_csv(\"#不想讀入第一行\n  #第二行也不想\n  x,y,z\n  1,2,3\", comment = \"#\")\n\n# 以上兩種做法都會得到\n## # A tibble: 1 × 3\n##       x     y     z\n##   <dbl> <dbl> <dbl>\n## 1     1     2     3\nread_csv(\"1,2,3\\n4,5,6\", col_names = FALSE)\n## # A tibble: 2 × 3\n##      X1    X2    X3\n##   <dbl> <dbl> <dbl>\n## 1     1     2     3\n## 2     4     5     6\n\nread_csv(\"1,2,3\\n4,5,6\", col_names = c(\"A\", \"B\", \"C\"))\n## # A tibble: 2 × 3\n##      A     B     C\n##  <dbl> <dbl> <dbl>\n## 1     1     2     3\n## 2     4     5     6\nread_csv(\"a,b,c\\n1,2,.\", na = \".\")\n## # A tibble: 1 x 3\n##       a     b c    \n##   <dbl> <dbl> <lgl>\n## 1     1     2 NA"},{"path":"readr.html","id":"與-base-r-比較","chapter":"9 以 readr 匯入資料","heading":"9.1.1 與 base R 比較","text":"為何不用 base R 的 read.csv()？readr 中的 read_csv() 速度快上 10 倍。單純追求速度的話可以使用 data.table 套件（可見節 4.1），速度更快，但跟 tidyverse 就有一點點不搭。readr 中的 read_csv() 速度快上 10 倍。單純追求速度的話可以使用 data.table 套件（可見節 4.1），速度更快，但跟 tidyverse 就有一點點不搭。直接讀入成為 tibbles、不會把 character vectors 轉成 factors、不會使用 row names、不會破壞 column names。直接讀入成為 tibbles、不會把 character vectors 轉成 factors、不會使用 row names、不會破壞 column names。更可複製（reproducible）。更可複製（reproducible）。","code":""},{"path":"readr.html","id":"parsing-a-vector","chapter":"9 以 readr 匯入資料","heading":"9.2 Parsing a Vector","text":"parse_*() 函數可以幫助我們把字母向量轉成特定型態的向量，如 logical、integer 或 date，其中，第一個引數為要 parse 的字母向量：如果有 parsing failures，我們可以透過 problem() 來檢視出問題的地方。常用的 parse_*() 如下：parse_logical()：用來 parse logical。parse_logical()：用來 parse logical。parse_integer()、parse_double() 與 parse_number()：看似類似，實則大相徑庭。parse_integer() 已經示範過了，即用來 parse 整數；parse_double() 用來 parse 實數；parse_number() 則會丟掉數字前後的非數字字元，如 $1000 就會變成 1000，euro1,000 就會變成 1000，詳細的使用方法與範例可以參見節 9.2.1 或 Parse numbers, flexibly。parse_integer()、parse_double() 與 parse_number()：看似類似，實則大相徑庭。parse_integer() 已經示範過了，即用來 parse 整數；parse_double() 用來 parse 實數；parse_number() 則會丟掉數字前後的非數字字元，如 $1000 就會變成 1000，euro1,000 就會變成 1000，詳細的使用方法與範例可以參見節 9.2.1 或 Parse numbers, flexibly。parse_chracter()：看似非必要，卻還是有其用處，見節 9.2.2。parse_chracter()：看似非必要，卻還是有其用處，見節 9.2.2。parse_factor()：用來 parse factors，見節 9.2.3。parse_factor()：用來 parse factors，見節 9.2.3。parse_date()、parse_datetime() 與 parse_time()：用來 parse 日期時間，見節 9.2.4。parse_date()、parse_datetime() 與 parse_time()：用來 parse 日期時間，見節 9.2.4。","code":"\nstr(parse_logical(c(\"TRUE\", \"FALSE\", \"NA\")))\n# logi [1:3] TRUE FALSE NA\nstr(parse_integer(c(\"3\", \"5\", \"6\")))\n# int [1:3] 3 5 6\nstr(parse_date(c(\"2020-11-03\", \"2000-04-23\")))\n# Date[1:2], format: \"2020-11-03\" \"2000-04-23\"\n# 注意：date 預設格式為 yyyy-mm-dd\n# 也可以使用 na =\nparse_integer(c(\"1\", \"231\", \".\", \"456\"), na = \".\")\n# [1]   1 231  NA 456\n# 當然，如果輸入錯的格式就會得到 warning"},{"path":"readr.html","id":"parsenumber","chapter":"9 以 readr 匯入資料","heading":"9.2.1 Numbers","text":"之所以 parse 數字會成為問題，是因為數字有非常多種不同的寫法。readr 為了解決這個問題，有引數 locale，可以用來指定 parsing options。","code":""},{"path":"readr.html","id":"小數點","chapter":"9 以 readr 匯入資料","heading":"9.2.1.1 小數點","text":"一般而言，我們熟知的小數點是 .，但也是有人會寫成 ,。parse_double() 中，預設就是 .，但如果是 , 或其他符號怎麼辦？要處理這個問題，我們可以在 locale 的設定中，使用引數 decimal_mark，如：","code":"\nparse_double(\"1.23\")\n# [1] 1.23\nparse_double(\"1,23\", locale = locale(decimal_mark = \",\"))\n# # [1] 1.23"},{"path":"readr.html","id":"數字前後有非數字的字母","chapter":"9 以 readr 匯入資料","heading":"9.2.1.2 數字前後有非數字的字母","text":"有時候，數字前後就是有非數字的字母，例如 $1000 或 20% 或 1,300，那怎麼辦？我們可以改用 parse_number()。此外，美國通常以 , 作為 grouping mark，像是 20000 會寫成 20,000；但歐洲各國並不一定，因此我們也可以在 locale 中設置引數 grouping_mark，如：","code":"\nparse_number(\"20,044,620\")\n# [1] 20044620\nparse_number(\"20%\")\n# [1] 20\nparse_number(\"#20\")\n# [1] 20\nparse_number(\"It costs $817.\")\n# [1] 817\nparse_number(\"552.255.123\", locale = locale(grouping_mark = \".\"))\n# [1] 552255123\nparse_number(\"552'255'123\", locale = locale(grouping_mark = \"'\"))\n# [1] 552255123\nparse_number(\"33.457,32\", locale = locale(decimal_mark = \",\", grouping_mark = \".\"))\n# [1] 33457.32"},{"path":"readr.html","id":"parsestring","chapter":"9 以 readr 匯入資料","heading":"9.2.2 Strings","text":"貌似無用的函數，其實不然。問題在，同樣的字串也有許多種不同的表示方式。例如我們使用 chatToRaw() 函數，如：這種編碼（encoding）方式即 ASCII，每 byte 的資訊，都會被表成十六進位的數字，如 50 即 P、6f 即 o 等。ASCII 用來表示英文字母是不錯，但問題在對其他的語言顯然力不從心。今日，多數的編碼方式都是 UTF-8，可以表示各種語言，甚至表情符號。因此，readr 也是使用 UTF-8，即假設資料是以 UTF-8 的方式來編碼。可是又會反過來遇到一個問題，即如果我們的資料是由古老的電腦系統所生成，並非以 UTF-8 來編碼的話，那怎麼辦？這時候 parse_character() 就派上用場了。我們可以在引數 locale 中指定編碼的格式，如：下一個問題又來了：如果我們不知道它的編碼格式，那怎麼辦？我們可以使用 guess_encoding() 函數","code":"\ncharToRaw(\"Politics\")\n# [1] 50 6f 6c 69 74 69 63 73\nparse_character(\"El Ni\\xf1o was particularly bad this year\", locale = locale(encoding = \"Latin1\"))\n# [1] \"El Niño was particularly bad this year\""},{"path":"readr.html","id":"parsefactor","chapter":"9 以 readr 匯入資料","heading":"9.2.3 Factors","text":"","code":""},{"path":"readr.html","id":"parsedatetime","chapter":"9 以 readr 匯入資料","heading":"9.2.4 Dates, Date-Times, and Times","text":"","code":""},{"path":"readr.html","id":"parsing-a-file","chapter":"9 以 readr 匯入資料","heading":"9.3 Parsing a File","text":"","code":""},{"path":"readr.html","id":"策略","chapter":"9 以 readr 匯入資料","heading":"9.3.1 策略","text":"","code":""},{"path":"readr.html","id":"問題-1","chapter":"9 以 readr 匯入資料","heading":"9.3.2 問題","text":"","code":""},{"path":"readr.html","id":"其他策略","chapter":"9 以 readr 匯入資料","heading":"9.3.3 其他策略","text":"","code":""},{"path":"readr.html","id":"寫入檔案","chapter":"9 以 readr 匯入資料","heading":"9.4 寫入檔案","text":"","code":""},{"path":"readr.html","id":"其他類型的資料","chapter":"9 以 readr 匯入資料","heading":"9.5 其他類型的資料","text":"表格類型的資料可以使用：haven：用於讀取 SPSS、Stata 與 SAS 檔。haven：用於讀取 SPSS、Stata 與 SAS 檔。readxl：用以讀取 Excel 檔（.xls 與 .xlsx 檔）。readxl：用以讀取 Excel 檔（.xls 與 .xlsx 檔）。DBI：與 RMySQL、RSQLite 或 RPostgreSQL 配合使用，可以跑 SQL queries，然後從資料庫回傳一個 data frame。DBI：與 RMySQL、RSQLite 或 RPostgreSQL 配合使用，可以跑 SQL queries，然後從資料庫回傳一個 data frame。階層資料（hierarchical data）可以使用：jsonlite：用以讀取 JSON 檔。jsonlite：用以讀取 JSON 檔。xml2：用以讀取 XML 檔。xml2：用以讀取 XML 檔。其他類型的檔案，可以參考 R Data Import/Export 或 rio。","code":""},{"path":"tidyr.html","id":"tidyr","chapter":"10 以 tidyr 整理資料","heading":"10 以 tidyr 整理資料","text":"本章為 Wickham Grolemund (2016) 第 9 章內容。","code":""},{"path":"dplyr2.html","id":"dplyr2","chapter":"11 以 dplyr 處理關聯性資料","heading":"11 以 dplyr 處理關聯性資料","text":"本章為 Wickham Grolemund (2016) 第 10 章內容。","code":""},{"path":"stringr.html","id":"stringr","chapter":"12 以 stringr 處理字串","heading":"12 以 stringr 處理字串","text":"本章為 Wickham Grolemund (2016) 第 11 章內容。","code":""},{"path":"forcats.html","id":"forcats","chapter":"13 以 forcats 處理 Factors","heading":"13 以 forcats 處理 Factors","text":"本章為 Wickham Grolemund (2016) 第 12 章內容。","code":""},{"path":"lubridate.html","id":"lubridate","chapter":"14 以 lubridate 處理日期時間","heading":"14 以 lubridate 處理日期時間","text":"本章為 Wickham Grolemund (2016) 第 13 章內容。","code":""},{"path":"以-magrittr-使用-pipes.html","id":"以-magrittr-使用-pipes","chapter":"15 以 magrittr 使用 Pipes","heading":"15 以 magrittr 使用 Pipes","text":"","code":""},{"path":"singlereg.html","id":"singlereg","chapter":"16 單變數迴歸","heading":"16 單變數迴歸","text":"Lucky able understand causes things.— Virgil (29 BC)本部分將探討社會科學計量。本章為 Ismay Kim (2019) 第 5 章內容。","code":""},{"path":"singlereg.html","id":"需要的套件","chapter":"16 單變數迴歸","heading":"需要的套件","text":"其中，moderndive 使用 tidyverse style 編寫，可以從事基本的線性迴歸；skimr 則可以幫助我們快速地計算敘述統計。","code":"\nlibrary(tidyverse)\nlibrary(moderndive)\nlibrary(skimr)\nlibrary(gapminder)"},{"path":"singlereg.html","id":"解釋變數為連續變數","chapter":"16 單變數迴歸","heading":"16.1 解釋變數為連續變數","text":"以下，我們想了解的是老師的外貌與其教學評鑑的分數有關係嗎？是什麼關係？因此，解釋變數（explanatory variable） \\(x\\) 為老師的外貌分數，而結果變數（outcome variable）為老師的教學評鑑分數。","code":""},{"path":"singlereg.html","id":"探索性資料分析","chapter":"16 單變數迴歸","heading":"16.1.1 探索性資料分析","text":"在 moderdive 中，有一 data frame 為 evals，其包含了 UT Austin 的 463 門課程。我們使用 select() 選取我們接下來將要使用的變數，包括 ID、score 與 bty_avg，並且存在名為 evals_ch5 裡頭。回憶第 7 章所提及的，當我們拿到資料要分析或建模之前，第一件事情就是進行探索性資料分析，即 EDA。EDA 讓我們了解個別變數的分配、變數之間是否有潛在的關係與是否有 outliers 或缺漏值。EDA 常見的三個步驟：5觀察原始資料的值。觀察原始資料的值。計算概括的統計量，如平均數、中位數或四分位距等。計算概括的統計量，如平均數、中位數或四分位距等。資料視覺化。資料視覺化。","code":"\nevals_ch5 <- evals %>%\n  select(ID, score, bty_avg)"},{"path":"singlereg.html","id":"eda觀察原始資料的值","chapter":"16 單變數迴歸","heading":"16.1.1.1 EDA：觀察原始資料的值","text":"我們可以使用 tibble 中的 glimpse() 查看資料，如：也能使用 dplyr 中的 sample_n() 函數，隨機挑選給定數量的觀察值，如：由上，我們可知有 463 個觀察值。其中，各個變數分別代表：ID：在這份資料中用以編號觀察值的變數。ID：在這份資料中用以編號觀察值的變數。score：連續變數；老師的平均教學評鑑分數；最高 5 分，最低 1 分；為我們所關切的結果變數 \\(y\\)。score：連續變數；老師的平均教學評鑑分數；最高 5 分，最低 1 分；為我們所關切的結果變數 \\(y\\)。bty_avg：連續變數；老師的平均外貌分數，最高 10 分，最低 1 分；為我們所關切的解釋變數 \\(x\\)。bty_avg：連續變數；老師的平均外貌分數，最高 10 分，最低 1 分；為我們所關切的解釋變數 \\(x\\)。","code":"\nglimpse(evals_ch5)## Rows: 463\n## Columns: 3\n## $ ID      <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,…\n## $ score   <dbl> 4.7, 4.1, 3.9, 4.8, 4.6, 4.3, 2.8, 4.1, 3.4, 4.5, 3.8, 4.5, 4.…\n## $ bty_avg <dbl> 5.000, 5.000, 5.000, 5.000, 3.000, 3.000, 3.000, 3.333, 3.333,…\nevals_ch5 %>%\n  sample_n(size = 5)## # A tibble: 5 × 3\n##      ID score bty_avg\n##   <int> <dbl>   <dbl>\n## 1   257   3.8    3.17\n## 2    56   4.6    5.5 \n## 3   357   4.5    3.33\n## 4   266   4.9    5.83\n## 5   179   4      4.33"},{"path":"singlereg.html","id":"eda簡單的敘述統計","chapter":"16 單變數迴歸","heading":"16.1.1.2 EDA：簡單的敘述統計","text":"既然 score 與 bty_avg 是連續的數值變數，那我們可以計算他們的平均值與中位數，如：不過，如果要使用 summarize 來計算標準差、極值與分量的話，並非不可，只是比較麻煩。我們可以使用套件 skimr 中的 skim() 函數。把 data frame 丟入這個函數，將會回傳常用的敘述統計量，如：其中，回傳的有：missing：缺漏值的數量。missing：缺漏值的數量。complete：非缺漏值的數量。complete：非缺漏值的數量。n：所有值變數值的數量。n：所有值變數值的數量。mean：平均值。mean：平均值。sd：標準差（standard deviation）。sd：標準差（standard deviation）。p0：0th 分量，即最小值。p0：0th 分量，即最小值。p25：25th 分量。p25：25th 分量。p50：50th 分量。p50：50th 分量。p75：75th 分量。p75：75th 分量。p100：100th 分量，即最大值。p100：100th 分量，即最大值。不過，skim() 回傳的這些都是所謂的 univariate summary statistics。但我們還會想知道 binary summary statistics。例如，如果兩個變數都是數值變數，那我們可以計算相關係數（correlation coefficients） 。想要計算相關係數的話，我們有兩種方式。使用 moderndive 中的 get_correlation() 函數，使用 formula ~，把解釋變數放在 ~ 右邊，結果變數放在 ~ 左邊，如：使用 summarize() 中的 cor 函數，如：","code":"\nevals_ch5 %>%\n  summarise(mean_score = mean(score),\n            mean_bty_avg = mean(bty_avg),\n            median_score = median(score),\n            median_bty_avg = median(bty_avg))## # A tibble: 1 × 4\n##   mean_score mean_bty_avg median_score median_bty_avg\n##        <dbl>        <dbl>        <dbl>          <dbl>\n## 1       4.17         4.42          4.3           4.33\nevals_ch5 %>% select(score, bty_avg) %>% skim()── Data Summary ────────────────────────\n                           Values    \nName                       Piped data\nNumber of rows             463       \nNumber of columns          2         \n_______________________              \nColumn type frequency:               \n  numeric                  2         \n________________________             \nGroup variables            None      \n\n── Variable type: numeric ───────────────────────────────────────────────────────────────────\n  skim_variable n_missing complete_rate  mean    sd    p0   p25   p50   p75  p100 hist \n1 score                 0             1  4.17 0.544  2.3   3.8   4.3    4.6  5    ▁▁▅▇▇\n2 bty_avg               0             1  4.42 1.53   1.67  3.17  4.33   5.5  8.17 ▃▇▇▃▂\nevals_ch5 %>%\n  get_correlation(formula = score ~ bty_avg)## # A tibble: 1 × 1\n##     cor\n##   <dbl>\n## 1 0.187\nevals_ch5 %>%\n  summarise(correlation = cor(score, bty_avg))## # A tibble: 1 × 1\n##   correlation\n##         <dbl>\n## 1       0.187"},{"path":"singlereg.html","id":"eda視覺化","chapter":"16 單變數迴歸","heading":"16.1.1.3 EDA：視覺化","text":"加上 position = \"jitter\"（或者不用 geom_point()，改用 hgeom_jitter()）如同第 5 章所說的，是為了避免 overplotting 的情況。我們也可以使用 geom_smooth(method = \"lm\")，就能以最小平方法來適配模型，並畫出迴歸線（regression line），如：事實上，藍色線段的斜率恰等於上節所算出的相關係數 0.0187。不過，雖然相關係數與迴歸線的斜率的正負號通常相同，但其值通常不同。","code":"\nevals_ch5 %>%\n  ggplot(aes(x = bty_avg, y = score)) +\n  geom_point(position = \"jitter\") +\n  labs(x = \"Beauty Score\",\n       y = \"Teaching Score\",\n       title = \"Scatterplot of realtionship of traching and beauty scores\")\nevals_ch5 %>%\n  ggplot(aes(x = bty_avg, y = score)) +\n  geom_jitter() +\n  geom_smooth(method = \"lm\", se = FALSE, formula = 'y ~ x') +\n  labs(x = \"Beauty Score\",\n       y = \"Teaching Score\",\n       title = \"Relationship between teaching and beauty scores\")"},{"path":"singlereg.html","id":"簡單線性迴歸","chapter":"16 單變數迴歸","heading":"16.1.2 簡單線性迴歸","text":"如何進行簡單線性回歸？定義一迴歸線 \\(\\hat{y} = \\hat{b}_0 + \\hat{b}_1\\cdot x\\)，我們可以：使用 lm() 函數適配迴歸模型，然後存在 score_model 中。使用 lm() 函數適配迴歸模型，然後存在 score_model 中。把 score_model 丟到套件 moderndive 中的 get_regression_table() 函數得到 regression table。把 score_model 丟到套件 moderndive 中的 get_regression_table() 函數得到 regression table。簡而言之，我們適配出的迴歸模型即\n\\[\n\\begin{aligned}\n\\hat{y} &= \\hat{b}_0 +\\hat{b}_1  \\cdot x\\\\\n\\widehat{\\rm score} &= 3.88 + 0.067 \\cdot {\\rm bty\\_avg}\n\\end{aligned}\n\\]\n這說明了，當 bty_avg 每增加 1 單位，score 平均會增加 0.067 單位。不過要注意的是，這是相關，而不是因果；即這是 associated increase，而非 causal increase。","code":"\nscore_model <- lm(score ~ bty_avg, data = evals_ch5)\nget_regression_table(score_model)## # A tibble: 2 × 7\n##   term      estimate std_error statistic p_value lower_ci upper_ci\n##   <chr>        <dbl>     <dbl>     <dbl>   <dbl>    <dbl>    <dbl>\n## 1 intercept    3.88      0.076     51.0        0    3.73     4.03 \n## 2 bty_avg      0.067     0.016      4.09       0    0.035    0.099"},{"path":"singlereg.html","id":"observedfitted-values-and-residuals","chapter":"16 單變數迴歸","heading":"16.1.3 Observed/fitted values and residuals","text":"如果我們想看個別的點的預測值與殘差呢？我們可以 get_regression_points() 來完成這件事，如：","code":"\nregression_points <- get_regression_points(score_model)\nhead(regression_points)## # A tibble: 6 × 5\n##      ID score bty_avg score_hat residual\n##   <int> <dbl>   <dbl>     <dbl>    <dbl>\n## 1     1   4.7       5      4.21    0.486\n## 2     2   4.1       5      4.21   -0.114\n## 3     3   3.9       5      4.21   -0.314\n## 4     4   4.8       5      4.21    0.586\n## 5     5   4.6       3      4.08    0.52 \n## 6     6   4.3       3      4.08    0.22"},{"path":"singlereg.html","id":"解釋變數為類別變數","chapter":"16 單變數迴歸","heading":"16.2 解釋變數為類別變數","text":"世界上各國的預期壽命有什麼差異？各個大陸的人的預期壽命之間有何差異？同個大陸之間，預期壽命的分佈又是如何呢？我們可以使用套件 gapminder 中的 gapminder 這個 data frame 來嘗試回答這個問題。其中，結果變數 \\(y\\) 是國家的預期壽命，一個連續變數；解釋變數 \\(x\\) 是國家屬於哪大洲，一個類別變數。資料詳情可以參照套件說明。","code":""},{"path":"singlereg.html","id":"探索性資料分析-1","chapter":"16 單變數迴歸","heading":"16.2.1 探索性資料分析","text":"首先載入資料。我們觀察的焦點放在 2007 年的狀況，並且我們需要 country、lifeExp、continent 的資料。","code":"\nlibrary(gapminder)\ngapminder2007 <- gapminder %>%\n  filter(year == 2007) %>%\n  select(continent, country, lifeExp)"},{"path":"singlereg.html","id":"eda觀察原始資料","chapter":"16 單變數迴歸","heading":"16.2.1.1 EDA：觀察原始資料","text":"","code":"\nglimpse(gapminder2007)## Rows: 142\n## Columns: 3\n## $ continent <fct> Asia, Europe, Africa, Africa, Americas, Oceania, Europe, Asi…\n## $ country   <fct> \"Afghanistan\", \"Albania\", \"Algeria\", \"Angola\", \"Argentina\", …\n## $ lifeExp   <dbl> 43.828, 76.423, 72.301, 42.731, 75.320, 81.235, 79.829, 75.6…\ngapminder2007 %>% sample_n(size = 5)## # A tibble: 5 × 3\n##   continent country     lifeExp\n##   <fct>     <fct>         <dbl>\n## 1 Africa    Libya          74.0\n## 2 Africa    Niger          56.9\n## 3 Americas  El Salvador    71.9\n## 4 Asia      China          73.0\n## 5 Europe    Sweden         80.9"},{"path":"singlereg.html","id":"eda簡單的敘述統計-1","chapter":"16 單變數迴歸","heading":"16.2.1.2 EDA：簡單的敘述統計","text":"","code":"\ngapminder2007 %>%\n  select(lifeExp, continent) %>%\n  skim()── Data Summary ────────────────────────\n                           Values    \nName                       Piped data\nNumber of rows             142       \nNumber of columns          2         \n_______________________              \nColumn type frequency:               \n  factor                   1         \n  numeric                  1         \n________________________             \nGroup variables            None      \n\n── Variable type: factor ───────────────────────────────────────────────────────────────────\n  skim_variable n_missing complete_rate ordered n_unique top_counts                        \n1 continent             0             1 FALSE          5 Afr: 52, Asi: 33, Eur: 30, Ame: 25\n\n── Variable type: numeric ──────────────────────────────────────────────────────────────────\n  skim_variable n_missing complete_rate  mean    sd    p0   p25   p50   p75  p100 hist \n1 lifeExp               0             1  67.0  12.1  39.6  57.2  71.9  76.4  82.6 ▂▃▃▆▇"},{"path":"singlereg.html","id":"線性迴歸","chapter":"16 單變數迴歸","heading":"16.2.2 線性迴歸","text":"","code":""},{"path":"singlereg.html","id":"observedfitted-values-and-residuals-1","chapter":"16 單變數迴歸","heading":"16.2.3 Observed/fitted values and residuals","text":"","code":""},{"path":"multireg.html","id":"multireg","chapter":"17 多變數迴歸","heading":"17 多變數迴歸","text":"本章為 Ismay Kim (2019) 第 6 章內容。","code":""},{"path":"IV.html","id":"IV","chapter":"18 工具變數","heading":"18 工具變數","text":"","code":""},{"path":"邊界估計.html","id":"邊界估計","chapter":"19 邊界估計","heading":"19 邊界估計","text":"","code":""},{"path":"縱貫資料.html","id":"縱貫資料","chapter":"20 縱貫資料","heading":"20 縱貫資料","text":"","code":""},{"path":"合成控制.html","id":"合成控制","chapter":"21 合成控制","heading":"21 合成控制","text":"","code":""},{"path":"探索性因素分析.html","id":"探索性因素分析","chapter":"22 探索性因素分析","heading":"22 探索性因素分析","text":"","code":""},{"path":"驗證性因素分析.html","id":"驗證性因素分析","chapter":"23 驗證性因素分析","heading":"23 驗證性因素分析","text":"","code":""},{"path":"html.html","id":"html","chapter":"24 HTML","heading":"24 HTML","text":"本章為 Munzert et al. (2014) 第 2 章內容。HTML 為 HyperText Markup Language 的縮寫。在節 24.1，將會使用瀏覽器呈現網頁原始碼（source code），並查看特定的 HTML 元素。在節 24.1，將會使用瀏覽器呈現網頁原始碼（source code），並查看特定的 HTML 元素。在節 24.2，將會介紹標記語言的邏輯與 HTML 的語法規則。在節 24.2，將會介紹標記語言的邏輯與 HTML 的語法規則。在節 24.3，將會呈現 HTML 最重要的詞彙。在節 24.3，將會呈現 HTML 最重要的詞彙。在節 24.4，將會討論重構 HTML 結構及語法的過程，即解析（parsing），與其如何幫助我們從網頁文檔提取資訊。在節 24.4，將會討論重構 HTML 結構及語法的過程，即解析（parsing），與其如何幫助我們從網頁文檔提取資訊。","code":""},{"path":"html.html","id":"sourcecode","chapter":"24 HTML","heading":"24.1 瀏覽器呈現與原始碼","text":"HTML 檔為純文字檔（plain text file）。HTML markup 可以用來定義文檔哪些部分該是標題、連結、表格，或其他格式。這些標記會告訴瀏覽器文檔如何組織，與其各部分的功能。我們在網頁瀏覽器中所看到過的是轉譯過的 HTML 檔，例如網頁 http://www.r-datacollection.com/materials/html/OurFirstHTML.html ，呈現在我們眼前的是一句話：“first HTML-file!”，而實際上有如此的原始碼：","code":"<!DOCTYPE html>\n <html>\n   <head>\n     <title>First HTML<\/title>  <!-- 此網頁的 title -->  \n   <\/head>\n   <body>\n     I am your first HTML-file!\n   <\/body>\n <\/html>"},{"path":"html.html","id":"htmlsyntax","chapter":"24 HTML","heading":"24.2 語法規則","text":"","code":""},{"path":"html.html","id":"標籤元素與屬性","chapter":"24 HTML","heading":"24.2.1 標籤、元素與屬性","text":"透過可以被瀏覽器讀懂的標籤（tags），純文字檔可以變成 HTML 文件。標籤由 < 與 > 包著，分成兩種，其一為 start tags，又稱為 opening tags，例如 <title>；其二為 end tags，又稱為 closing tags，與 start tags 不同的是多了 /，如 <\/title>。元素（elements）則包含 start tags、contents 與 end tags，6如：不過，並非所有的元素都會有一個 start tag 與一個 end tag。例如 <br> 意思是換行，就不會有另一個 <\/br> 為 end tag。如果元素形為 <body/>，在 start tag 中就以 / 結束，則稱為空元素，因為沒有任何 content。HTML 的標籤的大小寫並不重要，因此 <tagNAME>、<TAGNAME> 或 <tagname> 都是等價的，但一般我們會寫成全部都是小寫的形式。此外，標籤還有一特色為屬性（attributes），通常放在 start tag 的標籤名稱之後。一個屬性會有一個屬性名稱與一個值，例如：其中的 href=\"http://www.r-datacollection.com/\"就是指定 anchor <> 的屬性，而 href 就是屬性名稱，以單引號或雙引號包著的 \"http://www.r-datacollection.com/\" 即是屬性的值。標籤也能有多個屬性，只要用空格隔開即可。","code":"<title>First HTML<\/title><a href=\"http://www.r-datacollection.com/\">Link to Homepage<\/a>"},{"path":"html.html","id":"樹結構","chapter":"24 HTML","heading":"24.2.2 樹結構","text":"以上述範例而言，html 包著 <head> 與 <body>，<head> 則包著 <title>，就像樹結構（tree structure）一樣，如圖 24.1。\nFigure 24.1: 樹結構。\n","code":"<!DOCTYPE html>\n <html>\n   <head>\n     <title>First HTML<\/title>\n   <\/head>\n   <body>\n     I am your first HTML-file!\n   <\/body>\n <\/html>"},{"path":"html.html","id":"註釋","chapter":"24 HTML","heading":"24.2.3 註釋","text":"HTML 可以加入註釋（comments），以 <!-- 開頭，--> 結尾，中間的文字會被忽略，不會被呈現在瀏覽器上，如：","code":"<!-- Hi, I am a comment.\nI can span several lines and I am able to store additional\n  content that is not displayed by the browser. -->"},{"path":"html.html","id":"保留與特殊字元","chapter":"24 HTML","heading":"24.2.4 保留與特殊字元","text":"HTML 的標籤使用 < 與 >，那我們要在正文使用 < 或 > 時怎麼辦？對於這些會在 HTML 語法中使用的字元，如果要在 content 中使用它們，就要透過對應的 character entities。Entities 以 & 開頭，以 ; 結尾。例如，如果我們希望瀏覽器可以顯示 “5 < 6 7 > 3”，不應該使用而應該使用Table 24.1:  HTML entities.","code":"<p>5 < 6 but 7 > 3 <\/p><p>5 &lt; 6 but 7 &gt; 3 <\/p>"},{"path":"html.html","id":"文件類型定義","chapter":"24 HTML","heading":"24.2.5 文件類型定義","text":"","code":""},{"path":"html.html","id":"空白與換行","chapter":"24 HTML","heading":"24.2.6 空白與換行","text":"","code":""},{"path":"html.html","id":"tagsattri","chapter":"24 HTML","heading":"24.3 標籤與屬性","text":"","code":""},{"path":"html.html","id":"the-anchor-tag-a","chapter":"24 HTML","heading":"24.3.1 The anchor tag <a>","text":"","code":""},{"path":"html.html","id":"the-metadata-tag-meta","chapter":"24 HTML","heading":"24.3.2 The metadata tag <meta>","text":"","code":""},{"path":"html.html","id":"the-external-reference-tag-link","chapter":"24 HTML","heading":"24.3.3 The external reference tag <link>","text":"","code":""},{"path":"html.html","id":"emphasizing-tags-b-i-strong","chapter":"24 HTML","heading":"24.3.4 Emphasizing tags <b>, <i>, <strong>","text":"","code":""},{"path":"html.html","id":"the-paragraphs-tag-p","chapter":"24 HTML","heading":"24.3.5 The paragraphs tag <p>","text":"","code":""},{"path":"html.html","id":"heading-tags-h1-h2-h3","chapter":"24 HTML","heading":"24.3.6 Heading tags <h1>, <h2>, <h3>,…","text":"","code":""},{"path":"html.html","id":"listing-content-with-ul-ol-and-dl","chapter":"24 HTML","heading":"24.3.7 Listing content with <ul>, <ol>, and <dl>","text":"","code":""},{"path":"html.html","id":"the-organizational-tags-div-and-span","chapter":"24 HTML","heading":"24.3.8 The organizational tags <div> and <span>","text":"","code":""},{"path":"html.html","id":"the-form-tag-and-its-companions","chapter":"24 HTML","heading":"24.3.9 The <form> tag and its companions","text":"","code":""},{"path":"html.html","id":"the-foreign-script-tag-script","chapter":"24 HTML","heading":"24.3.10 The foreign script tag <script>","text":"","code":""},{"path":"html.html","id":"table-tags-table-tr-td-and-th","chapter":"24 HTML","heading":"24.3.11 Table tags <table>, <tr>, <td>, and <th>","text":"","code":""},{"path":"html.html","id":"parsing","chapter":"24 HTML","heading":"24.4 解析","text":"","code":""},{"path":"html.html","id":"discarding-nodes","chapter":"24 HTML","heading":"24.4.1 Discarding nodes","text":"","code":""},{"path":"html.html","id":"提取資訊","chapter":"24 HTML","heading":"24.4.2 提取資訊","text":"","code":""},{"path":"xml-與-json.html","id":"xml-與-json","chapter":"25 XML 與 JSON","heading":"25 XML 與 JSON","text":"","code":""},{"path":"xpath.html","id":"xpath","chapter":"26 XPath","heading":"26 XPath","text":"","code":""},{"path":"http.html","id":"http","chapter":"27 HTTP","heading":"27 HTTP","text":"","code":""},{"path":"ajax.html","id":"ajax","chapter":"28 AJAX","heading":"28 AJAX","text":"","code":""},{"path":"sql-與關聯性資料庫.html","id":"sql-與關聯性資料庫","chapter":"29 SQL 與關聯性資料庫","heading":"29 SQL 與關聯性資料庫","text":"","code":""},{"path":"正規表達式.html","id":"正規表達式","chapter":"30 正規表達式","heading":"30 正規表達式","text":"","code":""},{"path":"網路爬蟲.html","id":"網路爬蟲","chapter":"31 網路爬蟲","heading":"31 網路爬蟲","text":"在節 3.2.3 已簡介過以 rvest 抓取網路資料的方式。本章","code":""},{"path":"語言與建模.html","id":"語言與建模","chapter":"32 語言與建模","heading":"32 語言與建模","text":"","code":""},{"path":"斷詞.html","id":"斷詞","chapter":"33 斷詞","heading":"33 斷詞","text":"","code":""},{"path":"ref.html","id":"ref","chapter":"參考文獻","heading":"參考文獻","text":"","code":""}]
