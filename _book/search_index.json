[["tidyr.html", "13 以 tidyr 整理資料 13.1 Tidy Data 13.2 Spreading and Gathering 13.3 Separating and Pull 13.4 Missing Values", " 13 以 tidyr 整理資料 本章為 Wickham and Grolemund (2016) 第 9 章內容。另外可參見 Wickham (2014) 作為本章補充。 Happy families are all alike; every unhappy family is unhappy in its own way. — Leo Tolstoy Tidy datasets are all alike, but every messy dataset is messy in its own way. — Hadley Wickham 需要的套件 library(tidyverse) ## ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ── ## ✓ ggplot2 3.3.5 ✓ purrr 0.3.4 ## ✓ tibble 3.1.3 ✓ dplyr 1.0.7 ## ✓ tidyr 1.1.3 ✓ stringr 1.4.0 ## ✓ readr 2.0.1 ✓ forcats 0.5.1 ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() 13.1 Tidy Data 一筆整潔的資料有三個彼此相關的規則： 每個變數都自成一行。 每個觀察值都自成一列。 每個變數值都自成一格。 因此，我們要做的事情就是： 把每筆資料都放在一個 tibble 中。 把每個變數都放在一行中。 以下有五筆資料，每筆都是相同的，但是只有 table1 是整潔的（tidy）的： table1 ## # A tibble: 6 × 4 ## country year cases population ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 table2 ## # A tibble: 12 × 4 ## country year type count ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 1999 cases 745 ## 2 Afghanistan 1999 population 19987071 ## 3 Afghanistan 2000 cases 2666 ## 4 Afghanistan 2000 population 20595360 ## 5 Brazil 1999 cases 37737 ## 6 Brazil 1999 population 172006362 ## 7 Brazil 2000 cases 80488 ## 8 Brazil 2000 population 174504898 ## 9 China 1999 cases 212258 ## 10 China 1999 population 1272915272 ## 11 China 2000 cases 213766 ## 12 China 2000 population 1280428583 table3 ## # A tibble: 6 × 3 ## country year rate ## * &lt;chr&gt; &lt;int&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745/19987071 ## 2 Afghanistan 2000 2666/20595360 ## 3 Brazil 1999 37737/172006362 ## 4 Brazil 2000 80488/174504898 ## 5 China 1999 212258/1272915272 ## 6 China 2000 213766/1280428583 table4a ## # A tibble: 3 × 3 ## country `1999` `2000` ## * &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 745 2666 ## 2 Brazil 37737 80488 ## 3 China 212258 213766 table4b ## # A tibble: 3 × 3 ## country `1999` `2000` ## * &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 19987071 20595360 ## 2 Brazil 172006362 174504898 ## 3 China 1272915272 1280428583 事實上，因為 dplyr 與 ggplot2，以及所有 tidyverse 的套件，甚至是多數的 R 套件都是為 tidy data 所設計，因此這個環節至關重要。 不過，有時候 nontidy data 也有其用處。例如可能效能較好，或佔據的空間更小；或者某些專業領域有其儲存資料的特殊傳統。詳情可以參見 Non-tidy data。 13.2 Spreading and Gathering 不整潔的資料，有兩類常見的問題： 一個變數存在多行中。 一個觀察值分散在好幾列中。 想要解決這兩種問題，我們可以使用 tidyr 所提供的 gather() 與 spread() 函數。 13.2.1 Gathering 以剛剛展示過的 table4a 而言，它行的名稱不是變數的名稱： table4a ## # A tibble: 3 × 3 ## country `1999` `2000` ## * &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 745 2666 ## 2 Brazil 37737 80488 ## 3 China 212258 213766 要整理這批資料，我們需要三種參數： 應該要是變數值而不是變數的行，即 1999 和 2000。 其值原本是行的名稱的新變數名稱，這裡將有變數值為 1999 和 2000 的變數稱為 year，搭配引數 key。 其值原本散落在格子內的新變數名稱，這裡稱呼為 cases，搭配引數 value。 所以，我們可以如此整理 table4a： table4a %&gt;% gather(`1999`, `2000`, key = &quot;year&quot;, value = &quot;cases&quot;) ## # A tibble: 6 × 3 ## country year cases ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 ## 2 Brazil 1999 37737 ## 3 China 1999 212258 ## 4 Afghanistan 2000 2666 ## 5 Brazil 2000 80488 ## 6 China 2000 213766 Figure 13.1: gather() 的運作方式。 我們可以依樣畫葫蘆地整理 table4b： table4b %&gt;% gather(`1999`, `2000`, key = &quot;year&quot;, value = &quot;population&quot;) ## # A tibble: 6 × 3 ## country year population ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 1999 19987071 ## 2 Brazil 1999 172006362 ## 3 China 1999 1272915272 ## 4 Afghanistan 2000 20595360 ## 5 Brazil 2000 174504898 ## 6 China 2000 1280428583 接下來，我們可以利用第 14 章會學到的 dplyr::left_join() 來合併這兩者： tidy4a &lt;- table4a %&gt;% gather(`1999`, `2000`, key = &quot;year&quot;, value = &quot;cases&quot;) tidy4b &lt;- table4b %&gt;% gather(`1999`, `2000`, key = &quot;year&quot;, value = &quot;population&quot;) left_join(tidy4a, tidy4b) ## # A tibble: 6 × 4 ## country year cases population ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Brazil 1999 37737 172006362 ## 3 China 1999 212258 1272915272 ## 4 Afghanistan 2000 2666 20595360 ## 5 Brazil 2000 80488 174504898 ## 6 China 2000 213766 1280428583 13.2.2 Spreading Spreading 與 gathering 恰好相反，所要處理的問題是觀察值分散在不同列裏，table2 就有這樣的問題： table2 ## # A tibble: 12 × 4 ## country year type count ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 1999 cases 745 ## 2 Afghanistan 1999 population 19987071 ## 3 Afghanistan 2000 cases 2666 ## 4 Afghanistan 2000 population 20595360 ## 5 Brazil 1999 cases 37737 ## 6 Brazil 1999 population 172006362 ## 7 Brazil 2000 cases 80488 ## 8 Brazil 2000 population 174504898 ## 9 China 1999 cases 212258 ## 10 China 1999 population 1272915272 ## 11 China 2000 cases 213766 ## 12 China 2000 population 1280428583 要處理這種問題，我們需要兩種參數： 包含變數名稱的行，此處即 type，搭配引數 key。 包含組成多個變數的變數值的行，此處即 count，搭配引數 value。 table2 %&gt;% spread(key = type, value = count) ## # A tibble: 6 × 4 ## country year cases population ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 Figure 13.2: spread() 的運作方式。 13.3 Separating and Pull 另外兩種問題是一行中有多個變數與一個變數分散在多行，我們可以使用 separate() 與 unite() 來解決這兩種問題。 13.3.1 Seperate table3 的問題就在有一行 rate，事實上裝了兩個變數： table3 ## # A tibble: 6 × 3 ## country year rate ## * &lt;chr&gt; &lt;int&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745/19987071 ## 2 Afghanistan 2000 2666/20595360 ## 3 Brazil 1999 37737/172006362 ## 4 Brazil 2000 80488/174504898 ## 5 China 1999 212258/1272915272 ## 6 China 2000 213766/1280428583 只要有分隔字元的話，seperate 可以把一行拉成兩行，如： table3 %&gt;% separate(rate, into = c(&quot;cases&quot;, &quot;population&quot;)) ## # A tibble: 6 × 4 ## country year cases population ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 Figure 13.3: separate() 的運作方式。 separate() 預設會將非數字或字母的字元當成分隔字元，然後拆開。不過，如果有特殊的需求，我們也可以引數 sep 來手動指定分隔符號，如： table3 %&gt;% separate(rate, into = c(&quot;cases&quot;, &quot;population&quot;), sep = &quot;/&quot;) sep 引數也不見得要丟入符號。我們可以在 sep 丟入數字，正值代表從字串左邊數來第 \\(n\\) 個處分隔，負值則為從右邊數來第 \\(n\\) 個處分隔，如： table3 %&gt;% separate(year, into = c(&quot;century&quot;, &quot;year&quot;), sep = 2) ## # A tibble: 6 × 4 ## country century year rate ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 19 99 745/19987071 ## 2 Afghanistan 20 00 2666/20595360 ## 3 Brazil 19 99 37737/172006362 ## 4 Brazil 20 00 80488/174504898 ## 5 China 19 99 212258/1272915272 ## 6 China 20 00 213766/1280428583 不過，事情還沒有結束。注意到上面的 cases 與 population，本應是數字，卻被記為字元。我們可以使用引數 convert 解決此問題： table3 %&gt;% separate( rate, into = c(&quot;cases&quot;, &quot;population&quot;), convert = TRUE ) ## # A tibble: 6 × 4 ## country year cases population ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 13.3.2 Unite unite() 與 separate() 恰好相反，即把數行合併成一行。我們可以把 table5 的 century 與 year 兩行合併成 new，其中還可以加上引數 sep，因為 unite() 合併時預設會加入 _，因此我們必須設置為 sep = \"\"，如： table5 ## # A tibble: 6 × 4 ## country century year rate ## * &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 19 99 745/19987071 ## 2 Afghanistan 20 00 2666/20595360 ## 3 Brazil 19 99 37737/172006362 ## 4 Brazil 20 00 80488/174504898 ## 5 China 19 99 212258/1272915272 ## 6 China 20 00 213766/1280428583 table5 %&gt;% unite(new, century, year, sep = &quot;&quot;) ## # A tibble: 6 × 3 ## country new rate ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745/19987071 ## 2 Afghanistan 2000 2666/20595360 ## 3 Brazil 1999 37737/172006362 ## 4 Brazil 2000 80488/174504898 ## 5 China 1999 212258/1272915272 ## 6 China 2000 213766/1280428583 Figure 13.4: unite() 的運作方式。 13.4 Missing Values 資料裡的缺漏值有兩種呈現形式： Explicit. 以 NA 表示。 Implicit. 單純地沒有紀錄變數值。 stocks &lt;- tibble( year = c(2015, 2015, 2015, 2015, 2016, 2016, 2016), qtr = c( 1, 2, 3, 4, 2, 3, 4), return = c(1.88, 0.59, 0.35, NA, 0.92, 0.17, 2.66)) 在以上的資料中，有兩個缺漏值： 2015 年的第四季的報酬為 NA（explicit）。 少了 2016 年第一季的資料（implicit）。 13.4.1 讓潛藏的缺漏值顯露出來 要如何讓潛藏的缺漏值顯露出來呢？ 使用 spread() 把 year 放到 column 去，再使用 gather() 把行的名稱變成變數的名稱，如： stocks %&gt;% spread(year, return) %&gt;% gather(year, return, `2015`:`2016`, na.rm = FALSE) ## # A tibble: 8 × 3 ## qtr year return ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 2015 1.88 ## 2 2 2015 0.59 ## 3 3 2015 0.35 ## 4 4 2015 NA ## 5 1 2016 NA ## 6 2 2016 0.92 ## 7 3 2016 0.17 ## 8 4 2016 2.66 使用 complete()，如： stocks %&gt;% complete(year, qtr) ## # A tibble: 8 × 3 ## year qtr return ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2015 1 1.88 ## 2 2015 2 0.59 ## 3 2015 3 0.35 ## 4 2015 4 NA ## 5 2016 1 NA ## 6 2016 2 0.92 ## 7 2016 3 0.17 ## 8 2016 4 2.66 13.4.2 自動填入 treatment &lt;- tribble( ~ person, ~ treatment, ~response, &quot;Derrick Whitmore&quot;, 1, 7, NA, 2, 10, NA, 3, 9, &quot;Katherine Burke&quot;, 1, 4 ) 使用 fill() 會自動填入最常見的非缺漏值： treatment %&gt;% fill(person) ## # A tibble: 4 × 3 ## person treatment response ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Derrick Whitmore 1 7 ## 2 Derrick Whitmore 2 10 ## 3 Derrick Whitmore 3 9 ## 4 Katherine Burke 1 4 參考文獻 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
