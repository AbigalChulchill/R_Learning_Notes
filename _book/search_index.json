[["index.html", "R 學習筆記 序言", " R 學習筆記 Ting-Chih Hung 2022-04-16 序言 本筆記為多本 R 語言書籍內容之抄錄、摘要與重新編排（也可謂之拙劣的再現），僅作為學習筆記之用，版權仍歸作者所有，並以 R 套件 knitr (Xie 2017) 與 bookdown (Xie 2016) 編譯而成。 參考文獻 "],["rlang.html", "1 R 資料結構 1.1 變數與基本的運算 1.2 向量 1.3 矩陣 1.4 Factors 1.5 Data Frames 1.6 Lists", " 1 R 資料結構 本章為 Zamora Saiz et al. (2020) 節 2.2 內容。 1.1 變數與基本的運算 以下分別是「加」、「減」、「乘」、「除」、「餘數除法」、與「整數除法」： 3 + 4 3 - 4 3 * 4 3 / 4 15 %% 2 # get &quot;1&quot; 15 %/% 2 # get &quot;7&quot; 我們可以 &lt;- 來指派值給變數： x &lt;- 3 * 4 y &lt;- 4 * 20 z &lt;- x + y z # get &quot;92&quot; 最基本的資料型態有三種：numeric、character 與 logical。numeric 即數字，character 即字串而 logical 即布林值 TRUE 或 FALSE。此外，使用 as.integer() 可以把 numeric 轉成型態 integer，1也另有複數為型態 complex。而我們可以使用 class() 來查看變數的資料型態，如： GPA &lt;- 4.3 class(GPA) # get &quot;&#39;numeric&#39;&quot; word &lt;- &quot;GPA&quot; class(word) # get &quot;&#39;character&#39;&quot; yes.no &lt;- TRUE class(yes.no) # get &quot;&#39;logical&#39;&quot; GTA &lt;- as.integer(5) class(GTA) # get &quot;&#39;integer&#39;&quot; complex.number &lt;- 2 + 5i class(complex.number) # get &quot;&#39;complex&#39;&quot; as.integer(TRUE) 我們也可以使用科學記號代表很大的數，如： 2.35e7 # get &quot;23500000&quot; Logical value 也可以進行運算，其中 TRUE 代表 1，而 FALSE 代表 0，如： TRUE + TRUE # get &quot;2&quot; TRUE + FALSE # get &quot;1&quot; TRUE * FALSE # get &quot;0&quot; FALSE * FALSE # get &quot;0&quot; 此外，還有兩種特殊的資料型態：NULL 與 NA。當我們指派一個 NULL 給一個變數時，會讓其變成一個空的物件。 null.object &lt;- NULL null.object # get &quot;NULL&quot; class(null.object) # get &quot;&#39;NULL&#39;&quot; 而 NA 的意思是 non-available，常常表示 missing data。但特別的是用 class() 檢視為 NA 的變數時會發現其為一 logical value。 missing &lt;- NA missing # get &quot;NA&quot; class(missing) # get &quot;&#39;NA&#39;&quot; NA 運算後也會產生 NA： 1 + NA # get &quot;NA&quot; TRUE - NA # get &quot;NA&quot; 1.2 向量 向量（vector）是一列元素。我們以 c() 可以創造向量，裡頭的元素可以是 numeric、character 或 logical 其中一種，或者混合，而之間須以逗號分隔；我們可以用 length() 來得知向量的長度；如果裡頭的元素都是 numeric、character 或 logical 其中一種，則該向量的型態即其元素的型態，如： vector.numbers &lt;- c(1, 2, 3, 4) vector.numbers # get &quot;1 2 3 4&quot; length(vector.numbers) # &quot;4&quot; class(vector.numbers) # get &quot;&#39;numeric&#39;&quot; vector.characters &lt;- c(&quot;R&quot;, &quot;is&quot;, &quot;cool&quot;) vector.characters # get &quot;&#39;R&#39; &#39;is&#39; &#39;cool&#39;&quot; class(vector.characters) # get &quot;&#39;character&#39;&quot; vector.logicals &lt;- c(TRUE, FALSE) vector.logicals # get &quot;TRUE FALSE&quot; class(vector.logicals) # get &quot;&#39;logical&#39;&quot; 但如果是向量內有不同種類的元素，那麼 R 會去讓向量裡的元素的型態變得更「一般」，即 character 優先於 numeric 又優先於 logical，就連 NA 都能被變成其他型態，如： c(&quot;I&quot;, &quot;am&quot;, 1) # get &quot;&#39;I&#39; &#39;am&#39; &#39;1&#39;&quot; class(c(&quot;I&quot;, &quot;am&quot;, 1)) # get &quot;&#39;character&#39;&quot; c(&quot;He&quot;, &quot;is&quot;, &quot;the&quot;, TRUE) # get &quot;&#39;He&#39; &#39;is&#39; &#39;the&#39; &#39;TRUE&#39;&quot; class(c(&quot;He&quot;, &quot;is&quot;, &quot;the&quot;, TRUE)) # get &quot;&#39;character&#39;&quot; c(1, FALSE) # get &quot;1 0&quot; class(c(1, FALSE)) # get &quot;&#39;numeric&#39;&quot; c(NA, &quot;1&quot;) # get &quot;NA &#39;1&#39;&quot; class(c(NA, &quot;1&quot;)) # get &quot;&#39;character&#39;&quot; c(NA, TRUE) # get &quot;NA TRUE&quot; class(c(NA, TRUE)) # get &quot;&#39;logical&#39;&quot; 1.2.1 創造向量的其他方法 如果我們要創造一個連續的向量，可以使用 a:b，如： 3:12 # get &quot;3 4 5 6 7 8 9 10 11 12&quot; class(3:12) # get &quot;&#39;numeric&#39;&quot; 如果我們想要重複（repeat）某個數字或某群數字好幾遍，可以使用 rep()，例如： rep(c(3, -1, 0.5), 3) # get &quot;3.0 -1.0 0.5 3.0 -1.0 0.5 3.0 -1.0 0.5&quot; rep(c(3, -1, 0.5), times=3) # get &quot;3.0 -1.0 0.5 3.0 -1.0 0.5 3.0 -1.0 0.5&quot; # 所以第二個 argument 預設是整串重複幾次的意思 # 但也能改成個別重複幾次，如下： rep(c(3, -1, 0.5), each=3) # get &quot;3.0 3.0 3.0 -1.0 -1.0 -1.0 0.5 0.5 0.5&quot; 或者，我們可以在第二個 argument 丟入一個向量，指定第一個 argument 的個別的向量分別要重覆幾次，但這時候會長得像在第二個 argument 丟入 each= 的樣子，如： rep(c(3, -1, 0.5), times=c(2, 1, 3)) # get &quot;3.0 3.0 -1.0 0.5 0.5 0.5&quot; 我們也可以在第二個 argument 丟入一個 length.out=，這會使第一個 argument 的向量重複，而直到長度與 length.out= 的值相當，如： rep(c(3, -1, 0.5), length.out=8) # get &quot;3.0 -1.0 0.5 3.0 -1.0 0.5 3.0 -1.0&quot; 除了手動輸入、使用 a:b 或者以 rep() 的方式產生向量，我們還可以使用 seq()，這可以創造出一個數列。seq() 有三個引數，第一個引數為起始值，第二個引數為結束值，第三個引述則為公差，如： seq(0, 10, 2.5) # get &quot;0.0 2.5 5.0 7.5 10.0&quot; seq(0, 10, 2.3) # get &quot;0.0 2.3 4.6 6.9 9.2&quot; 1.2.2 標籤 只要創建了向量，裡頭的元素就能以 name() 命名。在我們要指出向量中的特定元素時還蠻有用的。此功能也有點像 Python 裡頭的字典，如： temperatures &lt;- c(28, 29, 27, 27, 30) names(temperatures) &lt;- c(&quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;) temperatures ## Monday Tuesday Wednesday Thursday Friday ## 28 29 27 27 30 這時候，ouput 就不會有 [1] 了，而是變成結構性的帶有標籤的向量。此外，如果要新增一個有同樣多座標且標籤順序一致的向量，有兩種方法。第一種方法是直接把 names(標籤向量) 指派給 names(欲標籤的向量)，這樣會把前者的標籤貼到後者身上；或者，我們還是可以仿效原先的做法，再新創一個同等長度的字串向量，然後輸入 names(欲標籤的向量)，如下： # Method 1 rains &lt;- c(0, 5, 6, 0, 2) names(rains) &lt;- names(temperatures) rains ## Monday Tuesday Wednesday Thursday Friday ## 0 5 6 0 2 # Method 2 rains &lt;- rep(NULL, 5) # 先清空剛剛指派的 named num [1:5] rains &lt;- c(0, 5, 6, 0, 2) days &lt;- c(&quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;) names(rains) &lt;- days rains ## Monday Tuesday Wednesday Thursday Friday ## 0 5 6 0 2 1.2.3 向量的運算 而如果我們想要把向量中的每個數字都加上另一個數字，只要直接把兩個物件相加就行了（雖然這違反了數學邏輯的公理）；如果要把向量中的每個數字都乘上某個數字也是同理，如攝氏溫標轉換成凱式溫標與華氏溫標： # Kelvin degrees Ktemp &lt;- temperatures + 273.15 Ktemp ## Monday Tuesday Wednesday Thursday Friday ## 301.15 302.15 300.15 300.15 303.15 # Fahrenheit degrees Ftemp &lt;- temperatures * 1.8 + 32 Ftemp ## Monday Tuesday Wednesday Thursday Friday ## 82.4 84.2 80.6 80.6 86.0 減、除、次方也是類似的道理。 此外，sum() 可以將所有向量的座標加總，如： total.rains &lt;- sum(rains) total.rains # get &quot;13&quot; 1.2.4 存取向量中的元素 在 R 語言中，第一個位置是 1（而不像有些語言是從 0 開始），並依序下去。如果我們要存取一個向量中的元素，可以直接指定向量中的位置；若要存取多個元素，就要使用 變數[c(想指定的位置)]；存取連續的位置則依然可以使用 a:b；當然也可以丟等差數列 seq() 進去，如： # 存取一個元素 rains[2] ## Tuesday ## 5 # 存取多個元素 rains[c(2, 5)] ## Tuesday Friday ## 5 2 # 存取連續的元素 rains[2: 5] ## Tuesday Wednesday Thursday Friday ## 5 6 0 2 # 等差地存取元素 rains[seq(1, 5, 2)] ## Monday Wednesday Friday ## 0 6 2 除了以位置來存取，當然也可以標籤來存取向量中的元素，如： rains[c(&quot;Monday&quot;, &quot;Tuesday&quot;)] ## Monday Tuesday ## 0 5 1.2.5 關係 &lt;：小於。 &gt;：大於。 &lt;=：小於或等於。 &gt;=：大於或等於。 ==：相等。 !=：不相等。 在兩個值之間加入這些關係符號，會輸出一個布林值，描述兩者的關係是否符合輸入的關係，如： 4 &gt; 3 # get &quot;TRUE&quot; 4 != 4 # get &quot;FALSE&quot; 向量也能與一個數字比較，此時會依據向量裡頭的位置順序，連帶著標籤（如果有的話），輸出各個座標的布林值，如： rains &gt; 0 ## Monday Tuesday Wednesday Thursday Friday ## FALSE TRUE TRUE FALSE TRUE 也能考慮多重的關係。&amp; 代表的是「且」（and），而 | 代表的是「或」（or），而函數 xor() 在其中一者為真一者為假時會回傳真，在兩者皆真或皆假的情況會回傳假，如： 3 == 4 &amp; 3 == 3 # get &quot;FALSE&quot; 3 == 4 | 3 == 3 # get &quot;TRUE&quot; 3 &lt; 5 &amp; 4 &gt; 2 # get &quot;TRUE&quot; TRUE &amp; TRUE &amp; FALSE # get &quot;FALSE&quot; xor(3 &gt; 2, FALSE) # get &quot;TRUE&quot; xor(3 &gt; 2, TRUE) # get &quot;FALSE&quot; xor(3 &lt; 2, FALSE) # get &quot;FALSE&quot; 我們可以運用這些比較關係來確認向量裡頭的元素是否符合某個性質。例如是否下雨、是否溫度高於某個給定的溫度，即： # 沒下雨的日子 not.rainy.days &lt;- rains == 0 not.rainy.days ## Monday Tuesday Wednesday Thursday Friday ## TRUE FALSE FALSE TRUE FALSE # 炎熱的日子 hot.days &lt;- temperatures &gt;= 29 hot.days ## Monday Tuesday Wednesday Thursday Friday ## FALSE TRUE FALSE FALSE TRUE 還可以用剛剛新建的向量，來存取原先向量中的位置，如： # 在 hot.days 中，Tues. 與 Fri. 是真 # 所以 rains 中 Tues. 與 Fri. 標籤的位置的標籤與值會被叫出來 rains[hot.days] ## Tuesday Friday ## 5 2 此外，我們可以透過兩個函數來一次檢查向量中的元素與某個性質之間的關係，即 all() 與 any()。前者在都有滿足的情況下就會回傳 TRUE，反之則回傳 FALSE；後者在其中一個座標有滿足的情況下就會回傳 TRUE，反之則回傳 FALSE。例如以下分別為「如果所有日子氣溫都大於等於 28 度則回傳 TRUE」與「如果其中一天氣溫恰等於 30 度則回傳 TRUE」，即： all(temperatures &gt;= 28) # get &quot;FALSE&quot; any(temperatures &gt;= 30) # get &quot;TRUE&quot; 另外，which() 則可以找到滿足條件的位置，即回傳為 TRUE 的位置的標籤與索引值，如找出溫度恰等於 27 度的日子： which(temperatures == 27) ## Wednesday Thursday ## 3 4 1.2.6 排序 我們可以使用 order()，其引數為一個向量，而此函數會回傳此向量中的元素的索引值為一個向量，由原向量的元素由小到大排列。如下，order(some.vector) 回傳的向量的第一個元素為 5，這意味著原先的向量中最小的元素 2 其索引值為 5，而次小的元素 3 其索引值為 1，依此類推，最大的元素 9 其索引值為 3： some.vector &lt;- c(3, 7, 9, 6, 2, 8) order(some.vector) ## [1] 5 1 4 2 6 3 所以，將 order(some.vector) 作為 some.veector[] 的引數（回憶節 1.2.4），我們可以由小到大重新排列向量，即回傳一個向量，其第一個元素為原向量索引值 5 的元素，其值為 2，依此類推，如： some.vector[order(some.vector)] ## [1] 2 3 6 7 8 9 不過要把向量由小排到大也可以使用 sort() 就是了。此操作不會改變原本的向量的排序，但會回傳排序後的向量。不過與上面的方法不同的是，此方法無法知道這些值原先在什麼位置： some.vector &lt;- c(3, 7, 9, 6, 2, 8) sort(some.vector) ## [1] 2 3 6 7 8 9 1.2.7 其他操作 我們可以使用 sum() 將向量的所有元素的值加總；max() 與 min() 則分別會回傳其中最大與最小的值；range() 則將回傳向量中的元素的範圍（即同時回傳 min() 與 max()）；mean() 可以計算向量的算術平均，如： sum(some.vector) # get &quot;35&quot; max(some.vector) # get &quot;9&quot; min(some.vector) # get &quot;2&quot; range(some.vector) # get &quot;2 9&quot; mean(some.vector) # get &quot;5.833333&quot; 結合 which()（回傳為 TRUE 的位置的標籤與索引值）與 max()（找到氣溫最高的值），就可以找到氣溫最高的日子的標籤與索引值，如： temperatures ## Monday Tuesday Wednesday Thursday Friday ## 28 29 27 27 30 which(temperatures == min(temperatures)) ## Wednesday Thursday ## 3 4 max(temperatures) ## [1] 30 1.3 矩陣 1.3.1 創建矩陣 我們可以用 matrix() 來創建矩陣，其語法為： matrix(data = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL) 其中，data 為我們要放進矩陣的向量資料；nrow 為 row 的數量；ncol 為 column 的數量；byrow 為以 column 或 row 的方式填滿矩陣（預設為 FALSE，即以 column 的方式填滿矩陣）；dimnames 則可以添加一個 list 為 row 與 column 的名字到矩陣（見節 1.6）。 對於 byrow 的用法如下兩個例子： matrix(1:6, nrow = 2, byrow = TRUE) ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 matrix(1:6, nrow = 2, byrow = FALSE) # default argument ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 而如果我們以向量的資料填滿矩陣，只要丟入 nrow 或 ncol 其中一者的引數即可，R 會根據資料的長度，算出 column 或 row 該要是多少。但如果向量資料的長度無法非 nrow 或 ncol，就會出現 Warning。但 R 還是會像資料長度為 nrow 或 ncol 的因數的情況一樣，從頭開始以原本的向量把矩陣給填滿，如： matrix(1:11, nrow = 3) ## Warning in matrix(1:11, nrow = 3): data length [11] is not a sub-multiple or ## multiple of the number of rows [3] ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 1 矩陣也可以放以 character 或 logical 組成的向量資料，如： matrix(c(&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;), nrow = 4) ## [,1] [,2] [,3] ## [1,] &quot;January&quot; &quot;May&quot; &quot;September&quot; ## [2,] &quot;February&quot; &quot;June&quot; &quot;October&quot; ## [3,] &quot;March&quot; &quot;July&quot; &quot;November&quot; ## [4,] &quot;April&quot; &quot;August&quot; &quot;December&quot; matrix(c(TRUE, FALSE, TRUE, TRUE, FALSE, FALSE), nrow = 2) ## [,1] [,2] [,3] ## [1,] TRUE TRUE FALSE ## [2,] FALSE TRUE FALSE 我們可以 rownames() 與 colnames 為 row 與 column 加上名字，使用方法如： climate &lt;- matrix(c(temperatures, rains), byrow = TRUE, nrow = 2) rownames(climate) &lt;- c(&quot;Temperatures&quot;, &quot;Rains&quot;) colnames(climate) &lt;- days climate ## Monday Tuesday Wednesday Thursday Friday ## Temperatures 28 29 27 27 30 ## Rains 0 5 6 0 2 我們可以透過 dim(想得知的矩陣) 得知 row 與 column 的數量，如： dim(climate) # get &quot;2 5&quot; 1.3.2 合併矩陣與矩陣運算 我們可以透過 rbinds() 與 cbinds() 在矩陣新增 row 或 column，如： Winds &lt;- c(30, 25, 22, 24, 18) total.climate &lt;- rbind(climate, Winds) total.climate ## Monday Tuesday Wednesday Thursday Friday ## Temperatures 28 29 27 27 30 ## Rains 0 5 6 0 2 ## Winds 30 25 22 24 18 我們可以使用 rowSums() 或 colSums() 把各個 row 或 column 的值加起來。把各個 row 的值相加以後指派給變數 totals，然後與原先的 climate 合併，就如： totals &lt;- rowSums(total.climate) cbind(total.climate, totals) ## Monday Tuesday Wednesday Thursday Friday totals ## Temperatures 28 29 27 27 30 141 ## Rains 0 5 6 0 2 13 ## Winds 30 25 22 24 18 119 1.3.3 存取矩陣中的元素 存取矩陣的方式與向量類似，即 矩陣[row, col]，如： total.climate[2, 3] # get &quot;6&quot; 如果不輸入 row 的引數，則會列出該 column 所有的資料，如下列出了週三的氣溫、雨量及風速： total.climate[, 3] ## Temperatures Rains Winds ## 27 6 22 如果不輸入 column 的引數，則會列出該 row 所有的資料，如下列出了每日的雨量： total.climate[2, ] ## Monday Tuesday Wednesday Thursday Friday ## 0 5 6 0 2 另外，也可以直接指定某個 row 或 column 的名字來存取資料，如： total.climate[, &quot;Wednesday&quot;] ## Temperatures Rains Winds ## 27 6 22 total.climate[&quot;Rains&quot;,] ## Monday Tuesday Wednesday Thursday Friday ## 0 5 6 0 2 total.climate[&quot;Rains&quot;, &quot;Wednesday&quot;] ## [1] 6 1.3.4 矩陣的運算 我們可以用 mean() 計算向量的算術平均，我們也能以此計算矩陣的 column 或 row 的算術平均。例如想要計算每天的平均氣溫，可以如下： mean(total.climate[&quot;Temperatures&quot;, ]) ## [1] 28.2 矩陣也能像向量一般運算（回憶節 1.2.3），如： climate * 2 ## Monday Tuesday Wednesday Thursday Friday ## Temperatures 56 58 54 54 60 ## Rains 0 10 12 0 4 climate ^ 2 ## Monday Tuesday Wednesday Thursday Friday ## Temperatures 784 841 729 729 900 ## Rains 0 25 36 0 4 # 計算雨量與氣溫的比例 climate[2, ] / climate[1, ] ## Monday Tuesday Wednesday Thursday Friday ## 0.00000000 0.17241379 0.22222222 0.00000000 0.06666667 1.4 Factors 質性或類別變數（qualitative or categorical variable）的值即類別，而非數值。把向量丟到 factor() 中可以把向量轉換成 factor。 創建一個向量 sizes，如： sizes &lt;- c(&quot;Small&quot;, &quot;Big&quot;, &quot;Big&quot;, &quot;Medium&quot;, &quot;Medium&quot;, &quot;Small&quot;, &quot;Medium&quot;, &quot;Small&quot;, &quot;Small&quot;) sizes ## [1] &quot;Small&quot; &quot;Big&quot; &quot;Big&quot; &quot;Medium&quot; &quot;Medium&quot; &quot;Small&quot; &quot;Medium&quot; &quot;Small&quot; ## [9] &quot;Small&quot; 但這時候如果用 summary()，我們只看得到資料長度和他們的類別： summary(sizes) ## Length Class Mode ## 9 character character 此時，把向量丟到 fator() 中將會回傳不太一樣的結果，並且 summary() 將會回傳各個值出現的次數；levels() 則會回傳此 factor vector 中有哪些元素（重複的不計），如： factor.sizes &lt;- factor(sizes) factor.sizes ## [1] Small Big Big Medium Medium Small Medium Small Small ## Levels: Big Medium Small summary(factor.sizes) ## Big Medium Small ## 2 3 4 levels(factor.sizes) ## [1] &quot;Big&quot; &quot;Medium&quot; &quot;Small&quot; 類別變數可以分為無序（nominal）與有序（ordinal）兩種。前者如顏色，後者如尺寸。如果要讓變數是有序的，我們在 factor() 中須將引數 ordered 設置為 TRUE，並且以引數 levels = 向量 由小到大地來描述順序關係，如： sizes2 &lt;- c(&quot;Small&quot;, &quot;Big&quot;, &quot;Big&quot;, &quot;Medium&quot;, &quot;Medium&quot;, &quot;Small&quot;, &quot;Medium&quot;, &quot;Small&quot;, &quot;Small&quot;) factor.sizes2 &lt;- factor(sizes, ordered=TRUE, levels=c(&quot;Small&quot;, &quot;Medium&quot;, &quot;Big&quot;)) factor.sizes2 ## [1] Small Big Big Medium Medium Small Medium Small Small ## Levels: Small &lt; Medium &lt; Big 我們也可以把向量指派給 level(目標 factor)，來覆寫 factor 中的值，如： survey.vector &lt;- c(&quot;M&quot;, &quot;F&quot;, &quot;F&quot;, &quot;M&quot;, &quot;M&quot;, &quot;F&quot;, &quot;M&quot;, &quot;M&quot;) factor.survey.vector &lt;- factor(survey.vector) # 此時儲存的順序是 &quot;F M&quot;，因此可以 c(&quot;Female&quot;, &quot;Male&quot;) 覆寫之 levels(factor.survey.vector) &lt;- c(&quot;Female&quot;, &quot;Male&quot;) factor.survey.vector ## [1] Male Female Female Male Male Female Male Male ## Levels: Female Male 無序的 factor 的元素無法比較，但有序的可以，如： factor.sizes2[1] &lt; factor.sizes2[2] # get &quot;TRUE&quot; factor.sizes2[2] == factor.sizes2[2] # get &quot;TRUE&quot; factor.sizes2[2] != factor.sizes2[3] # get &quot;FALSE&quot; 1.5 Data Frames 在 vectors 與 matrices 中，資料都會儲存成一樣的型態。但進行資料分析時，我們會同時處理不同型態的資料。此時我們需要 data frames 來儲存資料表。與矩陣不同的是， data frames 可以儲存不同型態的資料。R 有內置的 datasets，可以使用以下指令查看其資訊： ?datasets library(help=&quot;datasets&quot;) 我們也可以使用 data() 查看電腦內現有的 datasets。 我們可以使用其中一個現成的 dataset OrchardSprays。輸入 OrchardSprays 可以查看整個表。我們可以發現有四個變數，分別是 decrease、rowpos、colpos 與 treatmenet。decrease 為對處置的反應，以數值記載；rowpos 與 colpos 分別代表其 design 的 row 與 column；treatment 則為 A 至 H 的類別變數。以 head(OrchardSprays) 可以查看表格的前六個 rows。以 str() 可以獲知表格的資訊，如： str(OrchardSprays) ## &#39;data.frame&#39;: 64 obs. of 4 variables: ## $ decrease : num 57 95 8 69 92 90 15 2 84 6 ... ## $ rowpos : num 1 2 3 4 5 6 7 8 1 2 ... ## $ colpos : num 1 1 1 1 1 1 1 1 2 2 ... ## $ treatment: Factor w/ 8 levels &quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,..: 4 5 2 8 7 6 3 1 3 2 ... 我們可以用 dataframe() 來創建 data frames。其中的引數放入向量，而依序構成該 data frames 的各個 columns，如： name &lt;- c(&quot;Alfonso&quot;, &quot;Carlos&quot;, &quot;Lluis&quot;, &quot;Diego&quot;) last.name &lt;- c(&quot;Zamora&quot;, &quot;Quesada&quot;, &quot;Hurtado&quot;, &quot;Mondejar&quot;) second.last.name &lt;- c(&quot;Saiz&quot;, &quot;Gonzalez&quot;, &quot;Gil&quot;, &quot;Ruiz&quot;) age &lt;- c(33, 32, 30, 37) phd &lt;- c(&quot;math&quot;, &quot;math&quot;, &quot;physics&quot;, &quot;math&quot;) office &lt;- c(4, 14, 6, 8) from.madrid &lt;- c(FALSE, TRUE, FALSE, TRUE) professors &lt;- data.frame(name, last.name, second.last.name, age, phd, office, from.madrid) str(professors) ## &#39;data.frame&#39;: 4 obs. of 7 variables: ## $ name : chr &quot;Alfonso&quot; &quot;Carlos&quot; &quot;Lluis&quot; &quot;Diego&quot; ## $ last.name : chr &quot;Zamora&quot; &quot;Quesada&quot; &quot;Hurtado&quot; &quot;Mondejar&quot; ## $ second.last.name: chr &quot;Saiz&quot; &quot;Gonzalez&quot; &quot;Gil&quot; &quot;Ruiz&quot; ## $ age : num 33 32 30 37 ## $ phd : chr &quot;math&quot; &quot;math&quot; &quot;physics&quot; &quot;math&quot; ## $ office : num 4 14 6 8 ## $ from.madrid : logi FALSE TRUE FALSE TRUE 1.5.1 存取 data frames 中的元素與 subset 想要選取 data frames 中的元素，就像選取矩陣中的元素一樣，即 dataframes[row, col]，如： professors[2, 3] professors[1, ] # 顯示第一個 row professors[, 2] # 顯示第二個 column professors[1 : 2, ] # 選擇頭兩個 rows 要注意的是，data frames 的 column 的名字是來自 column vector 的名字，所以我們也可以用 $ 來存取特定的 column vector，如： professors$phd ## [1] &quot;math&quot; &quot;math&quot; &quot;physics&quot; &quot;math&quot; professors$phd[3] ## [1] &quot;physics&quot; 我們還可以用 logical 的方式來叫出 data frames 的 subset，例如要叫出 from.madrid 為 TRUE 的兩個 rows，即： madrileans &lt;- professors$from.madrid professors[madrileans, ] ## name last.name second.last.name age phd office from.madrid ## 2 Carlos Quesada Gonzalez 32 math 14 TRUE ## 4 Diego Mondejar Ruiz 37 math 8 TRUE 以指令 subset(data_frame, subset=logical_condition) 也能做到類似的事，如： subset(professors, subset=age &gt; 31) ## name last.name second.last.name age phd office from.madrid ## 1 Alfonso Zamora Saiz 33 math 4 FALSE ## 2 Carlos Quesada Gonzalez 32 math 14 TRUE ## 4 Diego Mondejar Ruiz 37 math 8 TRUE subset(professors, subset=phd == &quot;math&quot;) ## name last.name second.last.name age phd office from.madrid ## 1 Alfonso Zamora Saiz 33 math 4 FALSE ## 2 Carlos Quesada Gonzalez 32 math 14 TRUE ## 4 Diego Mondejar Ruiz 37 math 8 TRUE 1.5.2 排序 想要以某個特定的變數的順序整理 data frames，可以使用 order()，如： positions &lt;- order(professors$age) professors[positions, ] ## name last.name second.last.name age phd office from.madrid ## 3 Lluis Hurtado Gil 30 physics 6 FALSE ## 2 Carlos Quesada Gonzalez 32 math 14 TRUE ## 1 Alfonso Zamora Saiz 33 math 4 FALSE ## 4 Diego Mondejar Ruiz 37 math 8 TRUE 1.5.3 其他操作 我們可以 as.data.frame() 把矩陣轉為 data frames。 1.6 Lists Lists 就像向量，但其元素可以有不同的長度、大小、型態。我們可以用 list() 創建 lists，如： new.list &lt;- list(days, factor.sizes, climate) new.list ## [[1]] ## [1] &quot;Monday&quot; &quot;Tuesday&quot; &quot;Wednesday&quot; &quot;Thursday&quot; &quot;Friday&quot; ## ## [[2]] ## [1] Small Big Big Medium Medium Small Medium Small Small ## Levels: Big Medium Small ## ## [[3]] ## Monday Tuesday Wednesday Thursday Friday ## Temperatures 28 29 27 27 30 ## Rains 0 5 6 0 2 我們也可以選取 lists 中的元素，如： new.list[1] # 第一個元素 new.list[[1]][3] # 第一個元素中的第三個元素 new.list[[3]][1, 2:5] # 第三個元素中的第一個 row 的第二至五個的元素 我們也可以為 list 中的元素命名，如將第一個元素命名為 the.days、第二個元素命名為 the.factors、將第三個元素命名為 the.data： new.list &lt;- list(the.days=days, the.factors=factor.sizes, the.data=climate) new.list ## $the.days ## [1] &quot;Monday&quot; &quot;Tuesday&quot; &quot;Wednesday&quot; &quot;Thursday&quot; &quot;Friday&quot; ## ## $the.factors ## [1] Small Big Big Medium Medium Small Medium Small Small ## Levels: Big Medium Small ## ## $the.data ## Monday Tuesday Wednesday Thursday Friday ## Temperatures 28 29 27 27 30 ## Rains 0 5 6 0 2 這樣就可以用 $名字 來存取 list 中的元素，如： new.list$the.factors new.list$the.data[2, 5] new.list[&quot;the.data&quot;] 如果要新增元素到 list，可以 list_name[[\"名字\"]] &lt;- 要輸入的物件 指令，其中名字當然是選擇性的，也能空下來；此外，如果要刪除 list 中的成份，只要指派 NULL 給它就行，如： new.list[[&quot;professors&quot;]] &lt;- professors # 新增第四個元素，名為 &quot;professors&quot; 的 data frames new.list[[&quot;&quot;]] &lt;- positions # 新增第五個元素，無名的向量 new.list[[5]] &lt;- NULL # 刪除第五個元素 new.list[[&quot;professors&quot;]] &lt;- NULL # 刪除名為 &quot;professors&quot; 的元素 我們也可以用 str() 來查看 lists 的資訊，如： str(new.list) 參考文獻 "],["control.html", "2 控制結構與函數 2.1 Conditionals 2.2 Loops 2.3 Functions and Operators", " 2 控制結構與函數 本章為 Zamora Saiz et al. (2020) 節 2.3 與 2.4 內容。 2.1 Conditionals 條件句的語法如下： if (&quot;condition is satisfied&quot;) { &quot;do something&quot; } 例如： x &lt;- 3 if (x &gt; 0) { print(&quot;Positive&quot;) } ## [1] &quot;Positive&quot; 如果我們希望在條件沒有滿足時執行其他動作，就得使用 else，其語法如： if (&quot;condition is satisfied&quot;){ &quot;do something&quot; } else { &quot;otherwise do something else&quot; } 例如： x &lt;- 0 if (x &gt; 0) { print(&quot;Positive&quot;) } else { print(&quot;Negative&quot;) } 上述的 codes 其實在邏輯上是正確的，但顯然與我們希望電腦能做的事有落差（\\(x=0\\) 非正也非負才對）。所以，如果有好幾個條件要確認，也能多用幾個 else blocks，如： x &lt;- 0 if (x &gt; 0) { print(&quot;Positive&quot;) } else if (x &lt; 0) { print(&quot;Negative&quot;) } else { print(&quot;Zero&quot;) } 不過，要注意的是上述的結構在 R 的運行速度較慢，不如以 ifelse() 函數，把上述的結構寫成一行，其語法即： ifelse(&quot;condition&quot;, &quot;task if TRUE&quot;, &quot;task if FALSE&quot;) 前開判別變數為正或負的條件結構也能寫成： x &lt;- 9 ifelse(x &gt; 0, &quot;Positive&quot;, &quot;Negative&quot;) ## [1] &quot;Positive&quot; 只要在向量使用 binary operator，同樣的條件就也可以被確認多次。例如如果要確認向量中的元素是否小於 5，我們可以寫成： ifelse((1 : 10) &lt; 5, &quot;Fail&quot;, &quot;Pass&quot;) ## [1] &quot;Fail&quot; &quot;Fail&quot; &quot;Fail&quot; &quot;Fail&quot; &quot;Pass&quot; &quot;Pass&quot; &quot;Pass&quot; &quot;Pass&quot; &quot;Pass&quot; &quot;Pass&quot; 2.2 Loops for 用於重複次數預先指定的時候，while 則反之，將持續運行直到條件無法滿足。 2.2.1 for 迴圈 for 迴圈的語法為： for (&quot;counter&quot; in &quot;vector of indices&quot;) { &quot;do something&quot; } 例如印出 1–10 可以如此： for (i in 1 : 10) { print(i) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 因為 [1] 出現了十次，我們可知這段程式碼有十次輸出，每次輸出包含一個 row，顯然這是 print(i) 運行十次的結果。在此迴圈中，每次執行都會使 i 的值增加，所以如果我們此時在 console 輸入 i，將會回傳 10，顯示 i 作為一個變數，其值已經變成 10 了。 那如果我們要把連續的整數和存成一個向量該怎麼做呢？ v &lt;- c() s &lt;- 0 for (i in 1 : 10) { s &lt;- s + i v[i] &lt;- s } v ## [1] 1 3 6 10 15 21 28 36 45 55 其中，s 的作用就是在迴圈結束後儲存剛剛的結果，以便與下一個數相加。如此，可以依序將 \\(1\\)、\\(1+2\\)、\\(1+2+3\\)、\\(\\cdots{}\\)、\\(1+\\cdots{}+10\\) 存到向量 v 並印出。 以下還有幾個 for 迴圈運作的簡單範例。例如印出 1–19 的奇數，可以： odd &lt;- 2 * (1 : 10) - 1 for (i in odd) { print(i) } ## [1] 1 ## [1] 3 ## [1] 5 ## [1] 7 ## [1] 9 ## [1] 11 ## [1] 13 ## [1] 15 ## [1] 17 ## [1] 19 我們也可以把 for 迴圈與 if 條件句結合，要把某個向量中低於某個數字的元素印出 FAIL，如： for (i in 1 : 10) { if (i &lt; 5) { print(&quot;Fail&quot;) } else { print(&quot;Pass&quot;) } } ## [1] &quot;Fail&quot; ## [1] &quot;Fail&quot; ## [1] &quot;Fail&quot; ## [1] &quot;Fail&quot; ## [1] &quot;Pass&quot; ## [1] &quot;Pass&quot; ## [1] &quot;Pass&quot; ## [1] &quot;Pass&quot; ## [1] &quot;Pass&quot; ## [1] &quot;Pass&quot; 2.2.2 while 迴圈 除了 for 迴圈以外，還有 while 迴圈，其語法為： while (&quot;condition holds&quot;) { &quot;do something&quot; } 以下為一個 while 迴圈的簡單範例： i &lt;- 0 while (i &lt; 10) { print(c(i,&quot;is less than 10&quot;)) i &lt;- i + 1 } ## [1] &quot;0&quot; &quot;is less than 10&quot; ## [1] &quot;1&quot; &quot;is less than 10&quot; ## [1] &quot;2&quot; &quot;is less than 10&quot; ## [1] &quot;3&quot; &quot;is less than 10&quot; ## [1] &quot;4&quot; &quot;is less than 10&quot; ## [1] &quot;5&quot; &quot;is less than 10&quot; ## [1] &quot;6&quot; &quot;is less than 10&quot; ## [1] &quot;7&quot; &quot;is less than 10&quot; ## [1] &quot;8&quot; &quot;is less than 10&quot; ## [1] &quot;9&quot; &quot;is less than 10&quot; 第一圈 i 為 0，運行到 print() 時將會印出包含 “0” 與 “is less than 10” 元素的向量，而 i &lt;- i + 1 相當於計數器，第一個迴圈結束後，變數 i 就會變成 1，以此類推。在第十個迴圈結束後，變數 i 將會變成 10，而就不符合 while 迴圈繼續執行的條件了，迴圈至此終止。 2.3 Functions and Operators 2.3.1 創建新函數 R 本身就有很多預設的函數，如 mean() 可以取平均，sum() 可以加總，sqrt() 可以計算數字的平方根，log() 與 exp() 可以計算數字的對數值與指數值，sin()、cos()、tan() 可以計算三角函數值，is.logical() 可以確認型態是否是 logical。 如果要創建我們自己的函數，其語法為： function.name &lt;- function(argument1, argument2,...) { &quot;body function&quot; } 函數的名字隨意，只要沒有與既存的函數同名或以某些不合法的方式命名即可；引述的數量可多可少；body function 則裝載執行程序，裡頭用的值由引數而來，最後一行命令則會回傳成輸出。 例如若想新建一個函數來協助計算 \\(f(x, y)=x^2 - \\frac{y}{5}\\) 的話，可以 f &lt;- function(x, y) { x ^ 2 - y / 5 # the output is the evaluation of last line } 或者我們也可以寫成： f &lt;- function(x, y) x ^ 2 - y / 5 執行的最後一行預設就是輸出了，我們不需要寫出 return，但也能把它寫出來，如： f &lt;- function(x, y) { return (x ^ 2 - y / 5) } 定義函數以後我們就可以使用此函數進行運算。 2.3.2 引數的預設值 函數不一定要輸入引數。如果引數有預設值，而未輸入引數的話，即隨預設值。創建一個有預設的引數的函數的語法，如： funtion.name &lt;- function(name.argument1=default.value1, name.argument2=default.value2,...) { &quot;body function&quot; } 以下是一個能輸出連續的數字為向量或矩陣的簡單範例： mat.vec &lt;- function(a, b=2, flag=FALSE){ if (flag) { matrix(1 : a, nrow=b) } else { 1:a } } 此函數有三個變數：a 指矩陣或向量的元素個數；b 為如果我們想輸出的是矩陣的話其 rows 的數量；flag 決定是輸出矩陣還是向量，若 flag=TRUE，將會輸出包含 \\(1\\)-至 \\(a\\)，而有 \\(b\\) 個 rows 的矩陣（預設為 b=2） ，若 flag=FALSE，將會輸出包含 \\(1\\) 至 \\(a\\) 的向量（預設為 flag=FALSE）。有預設的引數還有一個好處，即就算我們漏輸入了、忘記了有哪些引數，程式碼還是能正常運行，而不會報錯。 函數能輸出的就只有單一個物件。所以如果想要輸出多個元素，可以使用 lists。例如我們可以創建一個函數，其回傳三項資訊：資料長度、總和與平均值，即： items &lt;- function(x) list(len=length(x),total=sum(x), mean=mean(x)) 我們把向量 1:10 丟進此函數，可得： data &lt;- 1 : 10 result &lt;- items(data) result ## $len ## [1] 10 ## ## $total ## [1] 55 ## ## $mean ## [1] 5.5 如果我們想查看函數是如何構成的，可以直接輸入其名，如： log ## function (x, base = exp(1)) .Primitive(&quot;log&quot;) 如果想要套用函數在多個元素時，可以使用 lapply(list, function)，其會把函數套用到 vector 或 list 的所有元素。sapply() 則類似於 lapply()，不同的是會把輸出簡化成向量或矩陣，而不是元素。其使用範例如： salutation &lt;- function(x) print(&quot;Hello&quot;) # Note that this output does not depend on the value of x output &lt;- sapply(1 : 5, salutation) ## [1] &quot;Hello&quot; ## [1] &quot;Hello&quot; ## [1] &quot;Hello&quot; ## [1] &quot;Hello&quot; ## [1] &quot;Hello&quot; 或者也可以簡化成： output &lt;- sapply(1 : 5, function(x) print(&quot;Hello&quot;)) ## [1] &quot;Hello&quot; ## [1] &quot;Hello&quot; ## [1] &quot;Hello&quot; ## [1] &quot;Hello&quot; ## [1] &quot;Hello&quot; 以內建的 cars datasets 為例，其有兩個變數：speed 與 dist。當我們想要計算這兩者的算術平均，可以： lapply(cars, mean) ## $speed ## [1] 15.4 ## ## $dist ## [1] 42.98 或者： sapply(cars, mean) ## speed dist ## 15.40 42.98 參考文獻 "],["rdata.html", "3 R 的資料庫 3.1 資料來源、匯入與匯出 3.2 資料收集 3.3 小結", " 3 R 的資料庫 本章為 Zamora Saiz et al. (2020) 節 3.1 與 3.2 內容。 3.1 資料來源、匯入與匯出 3.1.1 Tabulated File Types 最簡單的表格檔就是每個 column 的資料由空格分開，而每個 row 的資料由換行分開。這種分隔符號（separator）方便卻有一個大問題，即兩個字的資訊無法儲存，例如 orange shirt 就會變成兩塊。 所以要解決這個問題，就是每個 column 的資料改由逗號分開。不過想當然耳，如果資料內有逗號，那儲存上也會出現問題。如果想解決這個問題，也能用分號分開每個 column。雖然使用到分號的機率低上許多，但還是沒辦法免於這種風險。所以說，分隔好的選擇其實沒有什麼放諸四海皆準的通則，只能多加注意。 表格檔可以儲存種許多種檔案格式，最常見的是 comma separated values format，即 .csv 檔。雖然它是如此稱呼，但我們在匯入與匯出資料時也都要敘明 seperator。 3.1.2 匯入與匯出 3.1.2.1 .csv 檔 要匯入 .csv 檔可以使用 read.csv()。其有多個引數，最重要的是以下的四個。 our.table &lt;- read.csv(&quot;myfilewithdata.csv&quot;, header=TRUE, sep=&quot;;&quot;, dec=&quot;.&quot;) 第一個引數指定要從哪裡讀取資料；第二個引數決定表格有無 header；第三個引數指定 separator 而第四個引數指定 decimal separator。 而以 write.csv() 可以匯出 data frames 成 .csv 檔。第一個引數指定要輸出的 data frames；第二個引數指定輸出的名稱；第三個與第四個引數分別指定有無包含 coloumn 與 row 的名字；第五個與第六個引數分別指定 separator 與 decimal separator。 write.csv(our.table, &quot;filetosave.csv&quot;, col.names=FALSE, row.names=TRUE, sep=&quot;;&quot;, dec=&quot;.&quot;) 除了 .csv 檔也還有其他資料類型，如 .txt 與 .dat 檔，分別可以 read.table() 與 read.delim() 讀取。不過，我們要匯出資料時最好還是匯出為 .csv 檔，因為它最通用。 但要注意的是，前開的 read.csv() 與 write.csv() 處理起大數據速度很慢。我們可以使用一個 R package data.table 來解決這個問題，只要在 console 輸入：library(data.table)，2並分別以 fread() 與 fwrite() 來讀取與輸出檔案，其中 f 為 “fast” 之義。除了處理速度大增，使用 fread() 與 fwrite() 還可以讀取 .csv 檔以外的檔案，也可以自動識別 separator，而資料將會開啟成 data.table 的型態（data.frame 的升級版），而非 data.frame。 3.1.2.2 .json 檔 除了表格檔，我們還會需要使用階層檔（hierarchical files）。標準的階層檔檔案格式為 JavaScript Object Notation，即 .json 檔，就像書目一樣儲存資訊。但我們要讀取這類的檔案無法直接為之，必須借助套件 jsonlite。想要匯入一個 .json 檔到 R 裡頭並轉成 data.frame 格式只要輸入： library(jsonlite) jsonastable &lt;- as.data.frame(fromJSON(&quot;ourjsonfile.json&quot;)) 3.1.2.3 .xls 與.xlsx 檔 除外，還有一種檔案格式為試算表（spreadsheets）。MS Excel 就是最受歡迎的試算表程式。試算表雖然在某些領域頗有用，但也有計算速度與檔案大小的限制：Excel 檔最多只能有 1,048,576 個 rows 與 16,384 個 columns。想要在 R 載入 Excel 檔（.xls 或 .xlsx 檔），可以使用套件 readxl。輸入： library(readxl) data &lt;- read_excel(&quot;file.xlsx&quot;, col_names=TRUE, col_types=c(&quot;numeric&quot;, &quot;numeric&quot;), sheet=2) 引數 col_types 指定每個 column 裡的資料型態，而引數 sheet 則選擇要匯入檔案中的哪張試算表。 3.2 資料收集 資料依據其結構化的程度分成： Fully Structured: 變數已經明確定義而為表格的形式的 datasets。不費吹灰之力就能轉換成 data frames。使用 APIs 或一些公開的資料來源可以取得此類型的資料。 Semi Structured: 變數也已經明確定義，但還沒有變成表格的形式，例如網頁。還需要經前處理。 Unstructured: 變數尚未明確定義，例如圖片、音樂或未經處理的文字。需要先經過其他前處理，才能轉換成可供分析的資料。 處理非結構化的資料需要足夠的數學基礎，此處將會專於前兩者。 3.2.1 Data Repositories 存取資料最簡單的方式是使用免費公開的資料庫，如 The World Data Bank、Eurostat、U.S. Government’s Open Data 等，或者其他商用的資料庫。此外，也有套件 mlbench，包含了 UCI Machine Learning Repository 的 datasets。如果要載入 Glass dataset，只要輸入： library(mlbench) data(Glass) 3.2.2 APIs Application Programming Interfaces (APIs) 使我們可以直接存取資訊，而不需要透過手動下載 datasets 的方式。APIs 是一種通訊協定（communication protocols），有清楚的結構，可以有效率的傳遞資訊。此外，還可以如果有需要限制下載量，或者確認憑證（credentials），或者分割過大的檔案。 3.2.2.1 REST APIs APIs 都會有文件說明如何使用，有些要以特定的程式語言才能存取，例如 Python 或 PHP。最常見的 APIs 為 Representational State Transfer APIs (REST APIs)，其透過 URLs 要求資料，而提供的資料都會是標準的結構化格式（standard structured formats）。 因為每個 REST API 組織用以存取資料的 URLs 的方式都不同，所以使用 REST APIs 前得要先閱讀文件，了解如何存取想要的文件，然後再透過 R 存取之，若有需要並將其轉換成 data frames。 3.2.2.2 OpenSky Network Example OpenSky Network 為一非營利組織，其透過 REST API 分享資料，旨在增進航空交通的安全與效率。我們要獲取當下的航班的狀態。第一步是閱讀其文件。因為其提供的文檔是 .json 檔，所以我們要載入 jsonlite： library(jsonlite) 然後透過所提供的 URL，請求檔案，並轉成 data frame： url &lt;- &quot;https://opensky-network.org/api/states/all&quot; flights &lt;- as.data.table(fromJSON(URLencode(url))) 第一行把 URL 指派給字串 url；而第二行中，fromJSON() 可以讀取 .json 檔，URLenconde() 則是要告訴 R，將要放進一個有 .json 檔的 URL，其說明可在 Console 輸入 ?URLencode 了解，然後以 as.data.frame() 將資料轉成 data frame，並存進變數 flights 中（也可以 as.data.table() 把資料轉成 data table 的型態） 另一方面，如果 APIs 提供的檔案是 .csv 檔，那我們可以直接使用 fread(URLencode(指定的url))，而毋需使用 jsonlite。 3.2.3 Web Scraping 至今，已有 rvest 已有更新，可見 https://www.tidyverse.org/blog/2021/03/rvest-1-0-0/。 從網頁抓取資料時，一般的流程為： 清楚定義要下載的資訊為何。 了解網頁的編碼方式。 以 R 選擇並下載之。 將其轉換為變數並組合成 data frame。 以下以兩個例子說明網頁抓取的流程。 3.2.3.1 TheSportsDB 雖說這個網頁有 API，但此僅作為範例。 每個網頁都有一個 robots.txt，在瀏覽器的網址列輸入 目標網頁/robots.txt 可以查看。以此處的 TheSportsDB 為例，即輸入 https://www.thesportsdb.com/robots.txt 就能查看之。其記載著： User-agent: * Disallow: User-agent: AhrefsBot Disallow: / 我們先從其第三、四行開始閱讀，其意指機器人 AhrefsBot 被禁止從網頁抓取任何東西，其中 / 為「任何東西」之義，Disallow: / 即禁止抓取任何東西。第一、二行則表示所有既存的機器人（表示為 *）沒有禁止，即存取是合法的。 我們想抓取的網頁是https://www.thesportsdb.com/season.php?l=4387&amp;s=2020-2021，即 NBA 2020–2021 年的球賽。多數的網頁是由 HyperText Markup Language (HTML) 編碼的。當我們連到上述的網頁，按下鍵盤 F12，並選取「元素」（Elements）的頁面標籤，可以開啟如圖 3.1 的畫面。 Figure 3.1: Inspection menu. 在 .html 檔中，所有元素的首尾都有一個 tag，即以 &lt;tag&gt; 為開頭（可能會包含屬性，如 &lt;tag attribute=value&gt;），而以 &lt;/tag&gt; 結尾。 在該網頁中，如圖 3.2，當我們把游標放到第一場球賽的結果時，右欄 &lt;td style=\"text-align:center; width:10%\"&gt;112 - 116&lt;/td&gt; 也會被強調。在這個 tag 中，描述了文字的對齊方式與要呈現哪些文字在螢幕上。 Figure 3.2: 第一場比賽的比分所對應到的程式碼。 了解我們所要的資訊所對應到的程式碼是哪部分以後，下一個步驟是用 R 打開網頁，並告訴它要存取哪部分的資料。接下來的流程是： 呼叫網頁，並將其存在變數中。 指定要抓取的部分。 轉換資訊成文字。 首先使用套件 rvest，用以擷取網頁資料。在 Console 輸入： library(rvest) 並以指令 read_html() 呼叫網頁，將其儲存在變數中，如： nbagames &lt;- read_html(&quot;https://www.thesportsdb.com/season.php?l=4387&amp;s=2020-2021&quot;) 輸入 nbagames 我們可以看到： {html_document} &lt;html&gt; [1] &lt;head&gt;\\n&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;\\n&lt;script type=&quot;text/ja ... [2] &lt;body class=&quot;homepage&quot;&gt;\\n\\n&lt;header id=&quot;header&quot;&gt;&lt;nav class=&quot;navbar navbar-inverse&quot; role=&quot;banner&quot;&gt;&lt;d ... 而我們可以利用 html_nodes() 指定要抓取的部分。此函數需要兩個引數，其一為網頁（剛剛把網頁存到的變數就要放在這裡），其二為我們所需要的 tag 的字串，因為我們需要 &lt;td&gt; 這個 tag，所以在這裡即輸入 \"td\"，如： games &lt;- html_nodes(nbagames,&quot;td&quot;) 此時，變數 games 儲存了： {xml_nodeset (7327)} [1] &lt;td&gt;&lt;br&gt;&lt;/td&gt;\\n [2] &lt;td style=&quot;text-align:left; width:20%&quot;&gt;12 Dec 2020&lt;/td&gt;\\n [3] &lt;td&gt;&lt;/td&gt;\\n ... 由此可見，匯入了所有 td tags，而儲存於 xml_nodeset，一種專為與 .html 互動而設計的資料型態。因為要轉換成 character 才能處理，所以我們要使用 html_text()，如： games &lt;- html_text(html_nodes(nbagames, &quot;td&quot;)) 此時，games 內儲存的就會是： [1] &quot;&quot; &quot;12 Dec 2020&quot; &quot;&quot; [4] &quot;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tr00 &quot; &quot;Atlanta Hawks&quot; &quot;112 - 116&quot; [7] &quot; Orlando Magic&quot; &quot;12 Dec 2020&quot; &quot;&quot; [10] &quot;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tr00 &quot; &quot;Detroit Pistons&quot; &quot;84 - 90&quot; [13] &quot; New York Knicks&quot; &quot;12 Dec 2020&quot; &quot;&quot; ... 可以發現，此時還是有一些空字串與 \\n（換新行）、\\t（表格）與 \\tr00 之類的字元。我們接下來的目標是把資訊拆開，存入不同的變數中。待到節 4 將會處理這些問題。 3.2.3.2 Goodreads 第二個任務是 Goodreads 網頁所列的 21 世紀最佳書籍，可以參見：https://www.goodreads.com/list/show/7.Best_Books_of_the_21st_Century。首先當然是查看 robots.txt。因此我們要連到 https://www.goodreads.com/robots.txt，可以發現有一大堆的 Disallow： # See http://www.robotstxt.org/robotstxt.html for documentation on how to use the robots.txt file User-agent: * Disallow: /about/team_member/ Disallow: /admin Disallow: /api Disallow: /blog/list_rss Disallow: /book/reviews/ Disallow: /book_link/follow/ ... 但並非什麼存取都是不被允許的（因為 / 沒有被 Disallow），且 /list/ 也沒有被 Disallow，所以還是可以抓取此網頁。而我們可以發現，第一本書的標題所對應的 .html 碼為 &lt;span itemprop=\"name\" role=\"heading\" aria-level=\"4\"&gt;Harry Potter and the Deathly Hallows (Harry Potter, #7)&lt;/span&gt;，而 span 這個 tag 就是對應到書名。因此我們似乎可以仿效之前的做法： goodreadsurl &lt;- &quot;https://www.goodreads.com/list/show/7.Best_Books_of_the_21st_Century&quot; goodreads &lt;- read_html(goodreadsurl) books &lt;- html_text(html_nodes(goodreads, &quot;span&quot;)) 但我們將會發現，存進 books 的卻是： [1] &quot;Browse ▾&quot; [2] &quot;Community ▾&quot; [3] &quot;&quot; [4] &quot;&quot; [5] &quot;&quot; [6] &quot;&quot; [7] &quot;Profile&quot; [8] &quot;Groups&quot; [9] &quot;Groups&quot; [10] &quot;Friends’ recommendations&quot; [11] &quot;Friends’ recommendations&quot; [12] &quot;Browse ▾&quot; [13] &quot;Community ▾&quot; [14] &quot;Harry Potter and the Deathly Hallows (Harry Potter, #7)&quot; ... 直到第 14 個元素，才抓到第一本書的書名。現在的問題就在，tag span 雖然有包含書名，但還有包含許多其他的資訊。要解決這個問題，我們可以發現 tag span 是在 tag a 的下層，而 tag a 有一屬性為 class=\"bookTitle\"。Class 在 HTML 中的用處就是用來分類 tags 的方式，所以我們可以有單一個 tag，但有不同種類的資訊。因此，我們可以把剛剛的程式碼改成： goodreadsurl &lt;- &quot;https://www.goodreads.com/list/show/7.Best_Books_of_the_21st_Century&quot; goodreads &lt;- read_html(goodreadsurl) books &lt;- html_text(html_nodes(goodreads, &quot;.bookTitle span&quot;)) 指涉 class 的時候，前面要加上 .，而我們可以在該引數中同時放入 classes 和 tags。上述的程式碼即選取所有有 class 為 bookTitle 的 nodes，而選取裡頭的 tag span。結果，books 會是： [1] &quot;Harry Potter and the Deathly Hallows (Harry Potter, #7)&quot; [2] &quot;The Hunger Games (The Hunger Games, #1)&quot; [3] &quot;The Kite Runner&quot; [4] &quot;The Book Thief&quot; [5] &quot;Harry Potter and the Half-Blood Prince (Harry Potter, #6)&quot; [6] &quot;Harry Potter and the Order of the Phoenix (Harry Potter, #5)&quot; [7] &quot;The Help&quot; ... 顯然，結果就正常許多。而我們也需要提取作者與評分的資訊，因此程式碼為： goodreads &lt;- read_html(goodreadsurl) book &lt;- html_text(html_nodes(goodreads, &quot;.bookTitle span&quot;)) author &lt;- html_text(html_nodes(goodreads, &quot;.authorName span&quot;)) rating &lt;- html_text(html_nodes(goodreads, &quot;.minirating&quot;)) topbooks &lt;- data.frame(book, author, rating) 這時候算是大致完成了，但評分的部分的格式還是不太行，有些多餘的 hyphen 或字詞，在節 4，將會處理這個問題。 3.2.3.3 臺大活動報名系統與 CSS 選擇器 想要找出網頁的 CSS 選擇器路徑，除了上述手動查看的方法以外，如果使用 Google chrome 系列的瀏覽器，更方便的做法是使用如 SelectorGadget 之類的外掛。安裝完成並開啟以後直接用滑鼠點選想要抓取的元素即可，如圖 3.3。而如果包含到不想要選取的元素，就點選使其變成紅色，未包含到想要選取的元素則亦再行點選之即可。之後，SelectorGadge 將會產生一組 CSS 選擇器。如我們要抓取活動的代碼，其 CSS 選擇器即 .actID。 Figure 3.3: 使用 SelectorGadget。 因此，我們可以如此抓取臺大活動系統之過期活動中 2021 年的活動清單，並製作成一張 data table： events.url &lt;- &quot;https://my.ntu.edu.tw/actregister/expiredActionList.aspx&quot; events &lt;- read_html(events.url) events.number &lt;- html_text(html_nodes(events, &quot;.actID&quot;)) events.name &lt;- html_text(html_nodes(events, &quot;.multiline&quot;)) events.time &lt;- html_text(html_nodes(events, &quot;.actTime&quot;)) events.state &lt;- html_text(html_nodes(events, &quot;#ulbox .floatRight&quot;)) events.table &lt;- data.table(events.number, events.name, events.time, events.state) 結果如圖 3.4。 Figure 3.4: 抓取臺大活動系統中 2021 年的過期活動的資訊。 3.2.3.4 臺大政治系專任教師資料簡表 library(data.table) polisci.prof.url &lt;- &quot;http://politics.ntu.edu.tw/?cat=8&quot; polisci.prof &lt;- read_html(polisci.prof.url) prof.name &lt;- html_text(html_nodes(polisci.prof, &quot;.name a&quot;)) prof.title &lt;- html_text(html_nodes(polisci.prof, &quot;.title&quot;)) prof.phone &lt;- html_text(html_nodes(polisci.prof, &quot;.tel&quot;)) prof.email &lt;- html_text(html_nodes(polisci.prof, &quot;.mail a&quot;)) prof.table &lt;- data.table(prof.name, prof.title, prof.email) prof.phone &lt;- append(prof.phone, NA, 13) # 蕭高彥沒有放電話 prof.table &lt;- cbind(prof.table, as.data.table(prof.phone)) ## Warning: Item 2 has 29 rows but longest item has 37; recycled with remainder. knitr::kable(prof.table, booktabs = TRUE, caption = &#39;臺大政治系專任教師資料簡表。&#39;) Table 3.1: 臺大政治系專任教師資料簡表。 prof.name prof.title prof.email prof.phone 張登及 教授兼系主任 tchang@ntu.edu.tw 3366-8320 陳思賢 教授 genesis@ntu.edu.tw 3366-8313 黃錦堂 教授 hwngntn@ntu.edu.tw 33668316 石之瑜 教授 cyshih@ntu.edu.tw 3366-8418 蘇彩足 教授 tsaitsu@ntu.edu.tw 3366-8397 朱雲漢 教授 yunhan@gate.sinica.edu.tw 3366-8381 吳玉山 教授 yushanwu@gate.sinica.edu.tw 3366-8357 王業立 教授 ylwang2008@ntu.edu.tw 3366-8419 蘇宏達 教授 hdsu@ntu.edu.tw 3366-8406 林俊宏 教授 demian@ntu.edu.tw 3366-8399 陳淳文 教授 chwenwen@ntu.edu.tw 3366-8355 徐斯勤 教授 schsu01@ntu.edu.tw 3366-8347 張佑宗 教授 yutzung@ntu.edu.tw 3366-8396 左正東 教授 ctso@ntu.edu.tw NA 蕭高彥 教授 carl@gate.sinica.edu.tw 3366-8403 黃長玲 教授 changling@ntu.edu.tw 3366-8382 黃旻華 教授 mhhuang5103@ntu.edu.tw 3366-8420 王宏文 教授 hongwung@ntu.edu.tw 3366-8350 劉康慧 教授 helenliu4@ntu.edu.tw 3366-8405 陶儀芬 副教授 yftao@ntu.edu.tw 3366-8321 陳世民 副教授 shihmin@ntu.edu.tw 3366-8323 林子倫 副教授 tllin@ntu.edu.tw 3366-8305 李鳳玉 副教授 fylee323@ntu.edu.tw 3366-8366 郭乃菱 副教授 nailing@ntu.edu.tw 3366-8402 唐欣偉 副教授 hsinweitang@ntu.edu.tw 3366-8304 蔡季廷 副教授 chiting@ntu.edu.tw 3366-8385 黃心怡 副教授 hsinihuang@ntu.edu.tw 3366-8325 童涵浦 副教授兼副主任 hanstung@ntu.edu.tw 3366-8309 洪美仁 副教授 meijhung@ntu.edu.tw 3366-8331 郭銘峰 副教授 mingfeng.kuo@gmail.com 3366-8320 黃凱苹 副教授 kaipinghuang@ntu.edu.tw 3366-8313 廖小娟 副教授 mandyliao@ntu.edu.tw 33668316 安井伸介 助理教授 anjing@ntu.edu.tw 3366-8418 郭銘傑 助理教授 jasonkuo@g.ntu.edu.tw 3366-8397 吳舜文 助理教授 shunwu@ntu.edu.tw 3366-8381 張貴閔 助理教授 changkueimin@ntu.edu.tw 3366-8357 蘇翊豪 助理教授 yihaosu@ntu.edu.tw 3366-8419 3.3 小結 此外，還有兩個抓取網頁上的困難，此處沒有提及： 有些網頁在點擊之後會產生改變，但其網址並不會改變。此外，有些資訊需要登入才能存取。而有些網頁在 html 之上又使用 javascript。上述的問題都無法透過 rvest 來解決。雖然有其他套件，如 rselenium 可以解決這些問題，但並不簡單。 此外，有些平臺不想讓資訊流出給外人使用，會去偵測並阻斷自動抓取，這時候就很難從中提取有用的資訊。 參考文獻 "],["preprocessing.html", "4 資料前處理 4.1 Data Tables 4.2 Merging 4.3 實例", " 4 資料前處理 本章為 Zamora Saiz et al. (2020) 節 3.3 內容。 在資料分析前，我們須先進行資料前處理（data preprocessing）。準備資料有以下幾個步驟（雖然並非都是永遠需要）： Cleaning: 改變 dataset 的變數的格式。例如清除節 3.2.3.2 中的 rating 變數中無用的字元。 Integration: 從不同處來的資訊，在清潔以後，要整合成一張 data frame。 Transformation: 創造一些需要的變數，重構 dataset 成為更便於分析的格式。 Reduction: 如果 dataset 很龐大，而要從事的分析只是一小部分的資料，就要刪除一些變數，以釋出記憶體。 此章將專於使用 base 與 data.table；當然，也可以使用 tidyr、dplyr、stringr 或 stringi；3本書第 9、13、15 章將會分別介紹 dplyr、tidyr 與 stringr。 4.1 Data Tables Data Tables 即 data frames 的改良版，效能更高、功能更多、速度更好。並且，一個 data.table 物件也同時是一個 data.frame 物件，所以前者也可以使用後者的語法。要將向量或矩陣轉換為 data table 可以使用 as.data.table()，即： our.matrix.DT &lt;- as.data.table(our.matrix) 而既存的 data frame 或 list 可以使用 setDT() 將其轉換成 data table（雖然也可以使用 as.data.table()，但前者使用較少記憶體，速度更快）。不過，data table 的 row 沒有名字，所以如果要把有名字的 data frame 轉換成 data table，要使用 keep.rownames=T 引數，新增一個名為 rn 的 column，例如： library(data.table) example &lt;- data.frame(info1 = c(1, 2), info2 = c(&quot;a&quot;, &quot;b&quot;)) row.names(example) &lt;- c(&quot;line1&quot;, &quot;line2&quot;) setDT(example, keep.rownames=T) class(example) ## [1] &quot;data.table&quot; &quot;data.frame&quot; 而 data.table 物件有如 example.data[i, j, by] 的格式，此三個引數分別代表 row、column 與「分類依據」。 4.1.1 排序 Ordering 要重新排序 data table 的 row 除了可以用節 1.5.2 的 data frame 的方法以外，還有更簡單、快速的語法。以內置的套件 datasets 中的 swiss 為例。為了避免與原本的 dataset 混淆，我們可以創建一個複本。然後將其轉換成 data table，並以城鎮名稱字母序排列（現在城鎮名為新創的 rn column）： DT.swiss &lt;- copy(swiss) setDT(DT.swiss, keep.rownames=T) DT.swiss[order(rn)] 我們也可以依據多個變數來排列。order() 中的第一個引數會優先排列，如果值相等，再依據第二個引數排列，依此類推。而 - 為降冪排列之義。 DT.swiss[order(Education, -Agriculture)] 4.1.2 子集 Subsetting 如節 1.5.1 一樣存取 data frame 中的元素，我們依樣畫葫蘆來存取 data table 內的元素。例如我們如果想要存取前三個 rows 與前三個 columns 的元素，可以： DT.swiss[1 : 3, 1 : 3] 也可以使用名字來選取，如： DT.swiss[1 : 3, &quot;rn&quot;] # 顯示第一至三個 rows 與名為 rn 的 column 或者使用 ! 來不選取某個名字的 column，如： DT.swiss[1 : 3, !&quot;Agriculture&quot;] # 顯示第一至三個 rows，不顯示名為 Agriculture 的 column 如果使用 - 在數字前，則可以選取那個 row 或 column，如： DT.swiss[-(2 : 47),] # 只會選取第一個 row DT.swiss[, -1] # 不選取第一個 column 或者以 c() 包裹的任何組合： DT.swiss[1 : 3, c(&quot;rn&quot;, &quot;Education&quot;, &quot;Catholic&quot;)] # 顯示第一至三個 rows，與名為 rn、Education、Catholic 的 columns 我們也可以使用 our.data[condition on certain variables] 來選取滿足條件的 rows（類似節 1.5.1 提及的 subset()，但以 data table 速度更快）。如要找到 Education 恰等於 9 的城鎮，可以： DT.swiss[Education == 9] 其結果為： rn Fertility Agriculture Examination Education Catholic Infant.Mortality 1: Delemont 83.1 45.1 6 9 84.84 22.2 2: Lavaux 65.1 73.0 19 9 2.84 20.0 3: St Maurice 65.0 75.9 9 9 99.06 17.8 或者要找到 Education 小於等於 2 的城鎮，可以： DT.swiss[Education &lt;= 2] 其結果為： rn Fertility Agriculture Examination Education Catholic Infant.Mortality 1: Echallens 68.3 72.6 18 2 24.20 21.2 2: Oron 72.5 71.2 12 1 2.40 21.0 3: Conthey 75.5 85.9 3 2 99.71 15.1 4: Herens 77.3 89.7 5 2 100.00 18.3 以邏輯條件選取 data table 中的元素時，也可以超過一個條件，如： mean.values &lt;- sapply(DT.swiss[, -1], mean) DT.swiss[Agriculture &gt; mean.values[2] &amp; Education &gt; mean.values[4]] 回憶節 2.3.2 所提及的，sapply(list, function) 可以套用函數在多個元素上，並輸出為向量或矩陣。sapply(DT.swiss[, -1], mean) 之義為套用 mean() 這個函數在 DT.swiss 中除了第一個 column 以外的其他 columns，即算出其平均值，並輸出成有標籤的向量。而我們將輸出的資料存入 mean.values 變數中。如此，我們就能找出同時滿足「Agriculure 與 Education 皆大於平均值」的 rows，即： rn Fertility Agriculture Examination Education Catholic Infant.Mortality 1: Aigle 64.1 62.0 21 12 8.52 16.5 2: Avenches 68.9 60.7 19 12 4.43 22.7 3: Nyone 56.6 50.9 22 12 15.14 16.7 4: Sion 79.3 63.1 13 13 96.83 18.1 另一個 data table 的優勢是第二個引數 j 其實可以傳入非索引值的物件，例如我們想知道 Catholic &gt; 50 的城鎮其 Education 的平均可以透過： DT.swiss[Catholic &gt; 50, mean(Education)] ## [1] 9.111111 也可以知道 Catholic &gt; 50 的城鎮其 Education 的平均是否大於整體的 Education 平均： DT.swiss[Catholic &gt; 50, mean(Education) &gt; mean.values[4]] ## Education ## FALSE 或者 Education 小於 10 的城鎮究竟有多少： DT.swiss[Education &lt; 10, length(Education)] ## [1] 28 4.1.3 加總 Aggregation 前面曾經提及，example.data[i, j, by] 中的引數 by 為分組依據。其使用要配合引數 j。例如我們想得知每一個 Education 的值所對應到的 Fertility 的平均值，並且依據 Education 降冪排列，可以： DT.swiss[order(-Education), mean(Fertility), by=Education] Education V1 1: 53 35.00000 2: 32 64.40000 3: 29 43.75000 4: 28 55.70000 5: 20 54.30000 ... 當使用 by 來分類時，在引數 j 就無法使用 length() 來計算出現次數了。這時候可以改用 .N 來計算各組的數字，如： DT.swiss[order(-Education), .N, by=Education] Education N 1: 53 1 2: 32 1 3: 29 2 4: 28 1 5: 20 1 ... 也可以與 maen() 結合起來，以下列出各 Education 程度的數量，並分別算出各 Education 程度的 Fertility 與 Catholic 的平均，而以 Education 降冪排列： DT.swiss[order(-Education), .(.N, mean(Fertility), mean(Catholic)), by=Education] Education N V2 V3 1: 53 1 35.00000 42.34000 2: 32 1 64.40000 16.92000 3: 29 2 43.75000 54.38000 4: 28 1 55.70000 12.11000 5: 20 1 54.30000 2.15000 ... 除此之外，by 也可以丟入邏輯式，如： DT.swiss[, .N, .(Education &lt; 15, Fertility &gt; 60)] Education Fertility N 1: TRUE TRUE 37 2: FALSE TRUE 2 3: FALSE FALSE 6 4: TRUE FALSE 2 我們可以得知，有 37 個城鎮的 Education 小於 15，且 Fertility 大於 60；2 個城鎮的 Education 不小於 15，且 Fertility 大於 60；有 6 個城鎮的 Education 不小於 15，且 Fertility 不大於 60；2 個城鎮的 Education 小於 15，且 Fertility 不大於 60。 4.1.4 Keying Keys 是另一個選取子集（subsetting）更快的方法。只要在 data table 的某個變數中設定了 key，表格在物理上就會重新排列記憶體與儲存的 rows 所分派的順序。設定 key 的指令為 setkey(data.table, key)，如： setkey(DT.swiss, Education) 之後，表格就會依據 Education 重新排列： rn Fertility Agriculture Examination Education Catholic Infant.Mortality 1: Oron 72.5 71.2 12 1 2.40 21.0 2: Echallens 68.3 72.6 18 2 24.20 21.2 3: Conthey 75.5 85.9 3 2 99.71 15.1 4: Herens 77.3 89.7 5 2 100.00 18.3 5: Moudon 65.0 55.1 14 3 4.52 22.4 6: Paysd&#39;enhaut 72.0 63.5 6 3 2.56 18.0 7: Monthey 79.4 64.9 7 3 98.22 20.2 ... 想要 subsetting keyed variable，可以使用 .()，如下列出 Education 等於 3 的 rows： DT.swiss[.(3)] ## rn Fertility Agriculture Examination Education Catholic ## 1: Moudon 65.0 55.1 14 3 4.52 ## 2: Paysd&#39;enhaut 72.0 63.5 6 3 2.56 ## 3: Monthey 79.4 64.9 7 3 98.22 ## 4: Sierre 92.2 84.6 3 3 99.46 ## Infant.Mortality ## 1: 22.4 ## 2: 18.0 ## 3: 20.2 ## 4: 16.3 也可以輸入向量，如下列出 Education 等於 3 或 5 的 rows： DT.swiss[.(c(3, 5))] ## rn Fertility Agriculture Examination Education Catholic ## 1: Moudon 65.0 55.1 14 3 4.52 ## 2: Paysd&#39;enhaut 72.0 63.5 6 3 2.56 ## 3: Monthey 79.4 64.9 7 3 98.22 ## 4: Sierre 92.2 84.6 3 3 99.46 ## 5: Franches-Mnt 92.5 39.7 5 5 93.40 ## 6: Cossonay 61.7 69.3 22 5 2.82 ## Infant.Mortality ## 1: 22.4 ## 2: 18.0 ## 3: 20.2 ## 4: 16.3 ## 5: 20.2 ## 6: 18.7 也可以與引數j 和 by 搭配使用，如： DT.swiss[.(1 : 2), !c(&quot;Agriculture&quot;, &quot;Infant.Mortality&quot;)] ## rn Fertility Examination Education Catholic ## 1: Oron 72.5 12 1 2.40 ## 2: Echallens 68.3 18 2 24.20 ## 3: Conthey 75.5 3 2 99.71 ## 4: Herens 77.3 5 2 100.00 與： DT.swiss[.(3 : 6), mean(Fertility), by=Education] ## Education V1 ## 1: 3 77.150 ## 2: NA NA ## 3: 5 77.100 ## 4: 6 71.075 4.1.5 編輯表格 Updating by Reference 那如何編輯表格呢？使用 :=，之前放 column 的名字，而之後放要指派的值。如果要新增兩個 column，可以： DT.swiss[, c(&quot;new.col.1&quot;, &quot;new.col.2&quot;):=list(1 : 47, 51 : 97)] 其結果為： rn Fertility Agriculture Examination Education Catholic Infant.Mortality new.col.1 new.col.2 1: Oron 72.5 71.2 12 1 2.40 21.0 1 51 2: Echallens 68.3 72.6 18 2 24.20 21.2 2 52 3: Conthey 75.5 85.9 3 2 99.71 15.1 3 53 4: Herens 77.3 89.7 5 2 100.00 18.3 4 54 5: Moudon 65.0 55.1 14 3 4.52 22.4 5 55 ... 46: Neuchatel 64.4 17.6 35 32 16.92 23.0 46 96 47: V. De Geneve 35.0 1.2 37 53 42.34 18.0 47 97 修改其值也如同剛才的做法： DT.swiss[, c(&quot;new.col.1&quot;, &quot;new.col.2&quot;):=list(101 : 147, 151 : 197)] 結果為： rn Fertility Agriculture Examination Education Catholic Infant.Mortality new.col.1 new.col.2 1: Oron 72.5 71.2 12 1 2.40 21.0 101 151 2: Echallens 68.3 72.6 18 2 24.20 21.2 102 152 3: Conthey 75.5 85.9 3 2 99.71 15.1 103 153 4: Herens 77.3 89.7 5 2 100.00 18.3 104 154 5: Moudon 65.0 55.1 14 3 4.52 22.4 105 155 ... 46: Neuchatel 64.4 17.6 35 32 16.92 23.0 146 196 47: V. De Geneve 35.0 1.2 37 53 42.34 18.0 147 197 如果要刪除既存的 column，則可以： DT.swiss[, c(&quot;new.col.1&quot;, &quot;new.col.2&quot;):=list(NULL, NULL)] 4.2 Merging 如果兩個 data table 有一樣的變數，那要合併可以使用 rbind()（row binding），如： dataset.1 &lt;- data.table(city=c(&quot;Large&quot;, &quot;Medium&quot;), population=c(1000000, 250000), km2=c(20, 7)) dataset.2 &lt;- data.table(city=c(&quot;Small&quot;), population=c(50000), km2=c(1)) dataset.final &lt;- rbind(dataset.1, dataset.2) dataset.final ## city population km2 ## 1: Large 1000000 20 ## 2: Medium 250000 7 ## 3: Small 50000 1 如果有相同多的觀察值，則使用 cbind()（column binding），例如： dataset.1 &lt;- data.table(city=c(&quot;Large&quot;, &quot;Medium&quot;, &quot;Small&quot;), population=c(1000000, 250000, 50000)) dataset.2 &lt;- data.table(km2=c(20, 7, 1)) dataset.final &lt;- cbind(dataset.1, dataset.2) dataset.final ## city population km2 ## 1: Large 1000000 20 ## 2: Medium 250000 7 ## 3: Small 50000 1 如果兩個表格共享某些 rows 與 columns，則可以使用 merge()，如： dataset.1 &lt;- data.table(city=c(&quot;city.1&quot;, &quot;city.2&quot;, &quot;city.3&quot;, &quot;city.4&quot;, &quot;city.5&quot;, &quot;city.6&quot;), population=c(10000, 20000, 100000, 5000, 30000, 65000), km2=c(1, 0.5, 0.9, 2, 1.2, 3)) dataset.2 &lt;- data.table(city=c(&quot;city.1&quot;, &quot;city.2&quot;, &quot;city.3&quot;, &quot;city.7&quot;), airport=c(FALSE, FALSE, TRUE, TRUE)) dataset.1 ## city population km2 ## 1: city.1 10000 1.0 ## 2: city.2 20000 0.5 ## 3: city.3 100000 0.9 ## 4: city.4 5000 2.0 ## 5: city.5 30000 1.2 ## 6: city.6 65000 3.0 dataset.2 ## city airport ## 1: city.1 FALSE ## 2: city.2 FALSE ## 3: city.3 TRUE ## 4: city.7 TRUE # inner join：包含所有 columns，但有缺漏值的 rows 會被跳過 merge(dataset.1, dataset.2) ## city population km2 airport ## 1: city.1 1e+04 1.0 FALSE ## 2: city.2 2e+04 0.5 FALSE ## 3: city.3 1e+05 0.9 TRUE # full join：包含所有 columns 與 rows merge(dataset.1, dataset.2, all = TRUE) ## city population km2 airport ## 1: city.1 10000 1.0 FALSE ## 2: city.2 20000 0.5 FALSE ## 3: city.3 100000 0.9 TRUE ## 4: city.4 5000 2.0 NA ## 5: city.5 30000 1.2 NA ## 6: city.6 65000 3.0 NA ## 7: city.7 NA NA TRUE # left join：包含所有 columns，但跳過第一個表格沒有的 rows merge(dataset.1, dataset.2, all.x = TRUE) ## city population km2 airport ## 1: city.1 10000 1.0 FALSE ## 2: city.2 20000 0.5 FALSE ## 3: city.3 100000 0.9 TRUE ## 4: city.4 5000 2.0 NA ## 5: city.5 30000 1.2 NA ## 6: city.6 65000 3.0 NA # right join：包含所有 columns，但跳過第二個表格沒有的 rows merge(dataset.1, dataset.2, all.y = TRUE) ## city population km2 airport ## 1: city.1 1e+04 1.0 FALSE ## 2: city.2 2e+04 0.5 FALSE ## 3: city.3 1e+05 0.9 TRUE ## 4: city.7 NA NA TRUE 4.3 實例 除了前章所介紹的指令，本節還會介紹用以： 資料清理的 na.omit()、duplicated()； 文字轉換的 substr()、tstrplit()、grepl()。 na.omit() 可以剔除表格中有 NA 的觀察值（rows）；duplicated() 則可以幫助我們刪除重複的觀察值。例如我們新建一個 data table： dupli.table &lt;- data.table(ID=c(&quot;E123456789&quot;, &quot;N123456789&quot;, &quot;N213456897&quot;, &quot;N123456789&quot;, &quot;A123456789&quot;, &quot;N213456897&quot;, &quot;E213456897&quot;), sex=c(&quot;M&quot;, &quot;M&quot;, &quot;F&quot;, &quot;M&quot;, &quot;M&quot;, &quot;F&quot;, &quot;F&quot;), major=c(&quot;Econ&quot;, NA, &quot;Math&quot;, &quot;OR&quot;, &quot;EE&quot;, &quot;CS&quot;, &quot;Eng&quot;)) 使用 na.omit() 即會刪除有 NA 的觀察值： dupli.table &lt;- na.omit(dupli.table) dupli.table ## ID sex major ## 1: E123456789 M Econ ## 2: N213456897 F Math ## 3: N123456789 M OR ## 4: A123456789 M EE ## 5: N213456897 F CS ## 6: E213456897 F Eng 使用 duplicated() 可以協助我們找到特定的 columns 重複的觀察值，例如： duplicated.rows1 &lt;- duplicated(dupli.table[, c(1, 3)]) # 設定第一個與第三個 cols # 得到 &quot;FALSE FALSE FALSE FALSE FALSE FALSE&quot; # 表示完全沒有在第一個與第三個 cols 都重複的觀察值 duplicated.rows2 &lt;- duplicated(dupli.table[, c(1, 2)]) # 設定第一個與第二個 cols # 得到 &quot;FALSE FALSE FALSE FALSE TRUE FALSE&quot; # 表示第五個觀察值重複了 duplicated.rows3 &lt;- duplicated(dupli.table[, 1]) # 設定第一個 cols # 等價於 duplicated.rows3 &lt;- duplicated(dupli.table$ID) # 得到 &quot;FALSE FALSE FALSE FALSE TRUE FALSE&quot; # 表示第五個觀察值重複了 那要怎樣刪除重複的觀察值呢？我們可以： dupli.table &lt;- dupli.table[!duplicated.rows2] dupli.table ## ID sex major ## 1: E123456789 M Econ ## 2: N213456897 F Math ## 3: N123456789 M OR ## 4: A123456789 M EE ## 5: E213456897 F Eng 4.3.1 TheSportsDB NBA Dataset Preprocessing 上一章使用： library(rvest) nbagames &lt;- read_html(&quot;https://www.thesportsdb.com/season.php?l=4387&amp;s=2020-2021&quot;) games &lt;- html_text(html_nodes(nbagames,&quot;td&quot;)) 得到的 games 儲存了許多無用的字元： [1] &quot;&quot; &quot;12 Dec 2020&quot; &quot;&quot; &quot;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tr00 &quot; [5] &quot;Atlanta Hawks&quot; &quot;112 - 116&quot; &quot; Orlando Magic&quot; &quot;12 Dec 2020&quot; [9] &quot;&quot; &quot;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tr00 &quot; &quot;Detroit Pistons&quot; &quot;84 - 90&quot; ... 首先我們要先把空的項目刪除： games &lt;- games[!games==&quot;&quot;] 接著，我們想把包含 \\n 的項目刪除。但是，他們都長得不太一樣，於是我們要以 grepl(text-to-find, where-to-find-it) 來刪除： games &lt;- games[!grepl(&quot;\\n&quot;,games)] 現在這樣就正常很多了。而現在儲存的方式是向量，我們可以將其轉成有 4 個 column 的矩陣，然後將其轉換成 data table，並冠上 column names： games.2021 &lt;- as.data.table(matrix(games, ncol=4, byrow=T)) colnames(games.2021) &lt;- c(&quot;Date&quot;,&quot;TeamA&quot;,&quot;Result&quot;,&quot;TeamB&quot;) 不過，比分還是無法計算，因為現在是兩個數字。data.table 中的函數 tstrsplit(variable, separator, keep) 可以用以切開資訊，如： games.2021[, tstrsplit(Result, &quot;-&quot;)] # 相當於 games.2021[, tstrsplit(Result, &quot; &quot;, keep = c(1, 3))] V1 V2 1: 112 116 2: 84 90 3: 104 125 4: 87 81 5: 127 102 --- 1217: 118 108 1218: 120 100 1219: 109 103 1220: 119 123 1221: 105 98 因此，我們如果要新增兩個 columns，分別是 A 隊與 B 隊的分數，可以： games.2021[, c(&quot;PointsA&quot;, &quot;PointsB&quot;):=tstrsplit(Result, &quot;-&quot;)] games.2021$Result &lt;- NULL 得： Date TeamA TeamB PointsA PointsB 1: 12 Dec 2020 Atlanta Hawks Orlando Magic 112 116 2: 12 Dec 2020 Detroit Pistons New York Knicks 84 90 3: 12 Dec 2020 Chicago Bulls Houston Rockets 104 125 4: 12 Dec 2020 Los Angeles Lakers Los Angeles Clippers 87 81 5: 12 Dec 2020 Portland Trail Blazers Sacramento Kings 127 102 --- 1217: 09 Jul 2021 Phoenix Suns Milwaukee Bucks 118 108 1218: 12 Jul 2021 Milwaukee Bucks Phoenix Suns 120 100 1219: 15 Jul 2021 Milwaukee Bucks Phoenix Suns 109 103 1220: 18 Jul 2021 Phoenix Suns Milwaukee Bucks 119 123 1221: 21 Jul 2021 Milwaukee Bucks Phoenix Suns 105 98 參考文獻 "],["vector-matrix.html", "5 向量與矩陣", " 5 向量與矩陣 "],["rank-det-inv.html", "6 Rank, Determinants and Inverses", " 6 Rank, Determinants and Inverses "],["ggplot2.html", "7 以 ggplot2 進行資料視覺化 7.1 創建一個 ggplot 7.2 The Layered Grammar of Graphics 7.3 Aesthetic Mappings 7.4 Facets 7.5 幾何物件 7.6 統計轉換 7.7 Position Adjustment 7.8 座標系統 7.9 標籤", " 7 以 ggplot2 進行資料視覺化 本部分（第 7、9、10 章）要談的是資料探索。本章為 Wickham and Grolemund (2016) 第 1 章內容。 Figure 7.1: Data exploring. 前置作業 此章的目的則是要學習以 ggplot2 進行簡單的資料視覺化。我們先要載入 tidyverse，其包含了 ggplot2。在 Console 輸入： library(tidyverse) ## ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ── ## ✓ ggplot2 3.3.5 ✓ purrr 0.3.4 ## ✓ tibble 3.1.5 ✓ dplyr 1.0.7 ## ✓ tidyr 1.1.4 ✓ stringr 1.4.0 ## ✓ readr 2.0.1 ✓ forcats 0.5.1 ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── ## x dplyr::between() masks data.table::between() ## x dplyr::filter() masks stats::filter() ## x dplyr::first() masks data.table::first() ## x purrr::flatten() masks jsonlite::flatten() ## x readr::guess_encoding() masks rvest::guess_encoding() ## x dplyr::lag() masks stats::lag() ## x dplyr::last() masks data.table::last() ## x purrr::transpose() masks data.table::transpose() 7.1 創建一個 ggplot 引擎大的車子相較於引擎小的車子使用更多的汽油嗎？ 我們可以使用 tidyverse 中 mpg 這個 data frame 來嘗試回答這個問題。 mpg ## # A tibble: 234 × 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto… f 18 29 p comp… ## 2 audi a4 1.8 1999 4 manu… f 21 29 p comp… ## 3 audi a4 2 2008 4 manu… f 20 31 p comp… ## 4 audi a4 2 2008 4 auto… f 21 30 p comp… ## 5 audi a4 2.8 1999 6 auto… f 16 26 p comp… ## 6 audi a4 2.8 1999 6 manu… f 18 26 p comp… ## 7 audi a4 3.1 2008 6 auto… f 18 27 p comp… ## 8 audi a4 quattro 1.8 1999 4 manu… 4 18 26 p comp… ## 9 audi a4 quattro 1.8 1999 4 auto… 4 16 25 p comp… ## 10 audi a4 quattro 2 2008 4 manu… 4 20 28 p comp… ## # … with 224 more rows 其中，displ 為引擎的大小，單位是公升數；hwy 為汽車在高速公路上的燃油效率，以每加侖英里（miles per gallon, mpg）為單位，較低的話代表同樣的里程得要使用更多的油。 我們可以把 displ 放在 \\(x\\) 軸，而把 hwy 放在 \\(y\\) 軸，創建一個 ggplot： ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) ggplot() 可以創造一個座標系統，而我們可以在上面加上圖層。其中，第一個引數為此圖所要使用的 dataset，例如此處為 ggplot(dataset=mpg)，但這時候不會得到任何東西，只有一張空白的圖。而我們可以再加上其他圖層，如使用 geom_point()，可以用來繪製散佈圖（scatterplot）。而 geom_point() 函數有引數 mapping，與 aes() 搭配使用，可以讓我們指定 \\(x\\) 軸與 \\(y\\) 軸分別要是什麼變數。 此外，從此圖看起來，引擎大小與燃油效率呈現負向關係，即引擎更大的車，使用更多油。 7.2 The Layered Grammar of Graphics ggplot2 的語法大致如下，層層堆疊各種函數。在 geom 中，除了 mapping=aes()，我們還可以加上其他種類的 stat 與 “position adjustment”；若有需要，也可以加上不同的「座標系統」與 “facet function”。 ggplot(data = &lt;DATA&gt;) + &lt;GEOM_FUNCTION&gt;( mapping = aes(&lt;MAPPINGS&gt;), stat = &lt;STAT&gt;, position = &lt;POSITION&gt;)+ &lt;COORDINATE_FUNCTION&gt; + &lt;FACET_FUNCTION&gt; 以下將逐一簡介這些參數（以 &lt;&gt; 包圍的字串）的使用方式。 7.3 Aesthetic Mappings 我們可以新增第三個變數，例如 mpg 中的 class 到兩向度的散佈圖，讓上面的點映射到 aesthetic。Aesthetic 是一種物件的視覺性質，包含了點的 color、size、shape 等。使用 aesthetic 在 aes() 中使用 aesthetic.name = variable.name 即可，而如果我們不想要旁邊的圖例，可以使用 show.legend = FALSE，如： # ggplot(data = mpg) + # geom_point(mapping = aes(x = displ, y = hwy, color = class), show.legend = FALSE) ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, color = class)) 此外，如果我們映射 color 到一個邏輯條件，則如： ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, color = displ &lt; 5)) 我們也可以使用 size = class。但要注意的是此時會出現 Warning，因為把一個無序的變數 class 映射到一個有序的 aesthetic size 並不是一個好方法： ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, size = class)) ## Warning: Using size for a discrete variable is not advised. 我們也可以映射 class 到 alpha 或 shape，分別代表透明度與形狀，但也都會出現 Warning： ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, alpha = class)) ## Warning: Using alpha for a discrete variable is not advised. ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, shape = class)) ## Warning: The shape palette can deal with a maximum of 6 discrete values because ## more than 6 becomes difficult to discriminate; you have 7. Consider ## specifying shapes manually if you must have them. ## Warning: Removed 62 rows containing missing values (geom_point). 我們也可以從 geom 手動選擇 aesthetic properties，例如我們可以在 geom() 中加上 color = \"blue\"，讓所有點都變成藍色： ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy), color = &quot;blue&quot;) 這樣的話，就只是改變顏色，顏色並未傳達更多資訊。不過，事實上 ggplot2 也可以手動設置 aesthetic，不過此處從略。 7.4 Facets 注意：類別變數才能繪製成 facets！ 除了把變數映射到 aesthetics，我們也可以把類別變數繪製成 facets，即分別繪製資料不同的子集。要繪製 facets，我們可以使用 facet_wrap()，其第一個引數是一個 formula，即 ~ 變數名稱。此外，也可以 nrow 或 ncol 來指定要有幾個 rows 或 columns。如我們要根據 class 來繪製 facets，而排成兩個 rows 的形式，即： ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + facet_wrap(~ class, nrow = 2) 如果我們要把 facets 畫成兩個變數的組合，那就必須使用 facet_gird()，其語法如 facet_grid(row ~ col)。以下的例子，因為 drv 共有三種值：4、f、r，而 cyl 共有四種值：4、5、6、8，所以： ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + facet_grid(drv ~ cyl) 如果 row 或 column 其中一者不想要有變數，可以使用 facet_grid()。 7.5 幾何物件 Geom 是一種圖用來表示資料的幾何物件。例如，bar charts 使用 bar geoms，line charts 使用 line geoms，boxplots 使用 boxplot geoms 等。 要改變圖的 geom，即改變 ggplot() 所加的 geom function，例如我們把剛剛的 geom_point() 改成 geom_smooth 的話將會得到： # 對於 geom_smooth() 中的 method 與 formula 用法可見其文檔 ggplot(data = mpg) + geom_smooth(mapping = aes(x = displ, y = hwy), method = &#39;loess&#39;, formula = &#39;y ~ x&#39;) 我們也可以設置 aesthetic。雖然不能設置線的 shape，但可以設定線的 linetype。例如，我們可以根據變數 drv 來繪製三條不同的線： ggplot(data = mpg) + geom_smooth(mapping = aes(x = displ, y = hwy, linetype = drv), method = &quot;loess&quot;, formula = &quot;y ~ x&quot;) 或者也可以疊加兩種 geom： ggplot(data = mpg) + geom_smooth(mapping = aes(x = displ, y = hwy, color = drv, linetype = drv), method = &quot;loess&quot;, formula = &quot;y ~ x&quot;) + geom_point(mapping = aes(x = displ, y = hwy, color = drv)) 如果把引數放在 ggplot() 中，則會被視為 global mapping，將會套用到圖中的所有 geom；而放在 geom() 中則會被視為 local mapping，只會套用到該 geom。所以上述的程式碼也可以簡化為： ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = drv)) + geom_smooth(aes(linetype = drv), method = &quot;loess&quot;, formula = &quot;y ~ x&quot;) + geom_point() 7.6 統計轉換 diamonds 是 ggplot2 中的一個 dataset，約有 54000 顆鑽石的資料，包含 carat、cut、color、clarity、depth、table、price 等變數。使用 geom_bar() 可以依據某個變數畫出長條圖（bar chart），例如我們想要知道各種 cuts 到底有分別有多少鑽石，可以： ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut)) 在此，\\(x\\) 軸為 cut，是 diamonds 中的變數；\\(y\\) 軸為 count，並非 diamonds 中的變數，而是自動計算在各個 cut 中鑽石的數量。某些圖會計算新的變數然，例如： 長條圖、直方圖（histogram）或 frequency polygons 都會計算個數。 Smoothers 會適配模型然後畫出預測。 Boxplots 會計算分佈。 用來計算新的值的演算法稱之為 stat，為 statistical transformation 的簡稱。例如以 ?geom_bar 查看 geom_bar() 的幫助頁面，會發現其使用 stat_count()。因為每個 geom 都有一個預設的 stat，反之亦然，所以我們可以把 geom 與 stat 交換使用。也因此，如果把上圖的 geom_bar() 換成 stat_count() 也會到相同的結果。 什麼時候需要明確地使用 stat 呢？ 想要替換預設的 stat 的時候。 想要換原本的 mapping 時。 ggplot(data = diamonds) + geom_bar( mapping = aes(x = cut, y = ..prop.., group = 1) ) 想要使用其他的 statistical transformation 的時候。例如使用 stat_summary()，其會對每個 x 都 summarizes 其 y。 ggplot(data = diamonds) + stat_summary( mapping = aes(x = cut, y = depth), fun.min = min, fun.max = max, fun = median ) 7.7 Position Adjustment 想要為長條圖著色，除了使用 color，還可以使用 fill，兩者的效果也不同： ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, color = cut)) ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, fill = cut)) 如果 fill 指定為另一個變數的話，就會自動變成「堆疊」的形式，如： ggplot(data = diamonds, mapping = aes(x = cut, fill = clarity)) + geom_bar() 這種堆疊是透過位置調整（position adjustment）進行的。position 預設為 position=\"stack\"，而我們還能把 position 指定成其他三種選項：identity、dodge 與 fill： position = \"identity\"：用在 bar chart 上效果有點像 stack，但差別在調整透明度後可以看出來（即 alpha = 1/5）；雖然還是不明顯，但差別在 identity 的各個物件是會相互堆疊的。例如在下圖中，調整透明度明明應該所有物件的透明度都相同，但越靠下的部分透明度顯然越低，這就是因為越靠下的部分有越多個物件重疊在一起，使得圖形顯得較不透明。 ggplot(data = diamonds, mapping = aes(x = cut, fill = clarity)) + geom_bar(alpha = 1/5, position = &quot;identity&quot;) position = \"fill\"：依據指定的變數（此數為 clarity）堆疊，差別在高度相同，所以便於我們比較組間的比例差別。 ggplot(data = diamonds, mapping = aes(x = cut, fill = clarity)) + geom_bar(position = &quot;fill&quot;) position = \"dodge\"：以此例而言，即是對於每個不同的 cut，都分別把其各個 clarity 展現在逐一呈現，而非用堆疊的方式。 ggplot(data = diamonds, mapping = aes(x = cut, fill = clarity)) + geom_bar(position = &quot;dodge&quot;) 此外，當然還有其他 position 的引數可用，例如 position = \"jitter\"，其在 bar chart 中沒什麼用，但在散佈圖中有大用。回憶節 7.1 的散佈圖： ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) 事實上，mpg 明明有 234 個觀察值，如： str(mpg) # tibble [234 × 11] (S3: tbl_df/tbl/data.frame) # ... 但上面的散佈圖卻只有顯示 126 個點，為什麼？因為 overplotting！有些點的座標相同，所以相互覆蓋了。設置 position = \"jitter\" 可以解決這個問題，這會在每個點加入一點點 random noise，排除 overplotting 的問題。 ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point(position = &quot;jitter&quot;) 7.8 座標系統 除了前面使用的笛卡兒座標系統，還有其他有用的座標系統： coord_flip()：繪製旋轉 90 度的直角坐標，如： ggplot(data = mpg, mapping = aes(x = class, y = hwy)) + geom_boxplot() ggplot(data = mpg, mapping = aes(x = class, y = hwy)) + geom_boxplot() + coord_flip() coord_quickmap()：繪製有正確方位比例的地圖4，如： nz &lt;- map_data(&quot;nz&quot;) ggplot(nz, aes(long, lat, group = group)) + geom_polygon(fill = &quot;white&quot;, color = &quot;black&quot;) ggplot(nz, aes(long, lat, group = group)) + geom_polygon(fill = &quot;white&quot;, color = &quot;black&quot;) + coord_quickmap() coord_polar()：繪製極座標圖（polar coordinates），結合 bar char 與 Coxcomb chart，如： bar &lt;- ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, fill = cut), show.legend = FALSE, width = 1) + theme(aspect.ratio = 1) + labs(x = NULL, y = NULL) bar + coord_polar() coord_fixed：因為人對與 45 度線的差異感受最明顯，而 coord_fixed() 可以讓 geom_abline()（用以產生 reference lines 的 geom）產生的線為 45 度，如： p &lt;- ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + geom_point() + geom_abline() p + coord_fixed() # 如果不加 coord_fixed()，比例將會跑掉。 7.9 標籤 labs() 能使我們為圖加上標題、註解或更改 x 軸、y 軸的名稱，如： ggplot(data = mpg, mapping = aes(x = class, y = hwy)) + geom_boxplot() + coord_flip() + labs(y = &quot;Highway MPG&quot;, x = &quot;Class&quot;, title = &quot;Highway MPG by car class&quot;, subtitle = &quot;1999-2008&quot;, caption = &quot;Source: http://fueleconomy.gov&quot;) 參考文獻 "],["ggplot22.html", "8 更多 ggplot2", " 8 更多 ggplot2 "],["dplyr.html", "9 以 dplyr 轉換資料 9.1 前言 9.2 Filter Rows with filter() 9.3 Arrange Rows with arrange() 9.4 Select Columns with select() 9.5 Add New Variables with mutate() 9.6 Grouped Summaries with summarize() 9.7 Grouped Mutates (and Filters)", " 9 以 dplyr 轉換資料 本章為 Wickham and Grolemund (2016) 第 3 章內容。 9.1 前言 一拿到資料，除了以視覺化的方式快速洞察資料的樣貌，我們可能還需要： 新增新的變數。 統整。 重新命名變數。 重新排列觀察值的順序。 dplyr 的某些功能也能以 data.table 完成，並且兩者各有所長（data.table 的介紹可見節 4.1），而本章將要介紹 dplyr，為 tidyverse 中一個重要的成員，用以資料轉換。本章的任務是以 nycflights13 資料為例，簡介 dplyr 的使用。 9.1.1 前置作業 先載入 nycflights13 與 tidyverse： library(nycflights13) library(tidyverse) 要注意的是，dplyr 與 base R 一套件 stats 的某些函數名稱相同，如 filter 與 lag。如果是先載入 stats，後載入 dplyr 的話，則使用 filter() 將會是 dplyr 的 filter，這時候如果還想使用 stats 的 filter()，則需使用其全名，即 stats::filter()。反之，如果是先載入 dplyr，後載入 stats，則使用 filter() 將會使用到 stats 的 filter()，這時候如果還想使用 dplyr 的 filter()，亦須使用全名，即 dplyr::filter()。 9.1.2 nycflights13 我們將使用 nycflights13 中的 flights 這個 dataset，此 data frame 包含 336,776 個觀察值，並有 19 個變數。 flights ## # A tibble: 336,776 × 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 819 ## 2 2013 1 1 533 529 4 850 830 ## 3 2013 1 1 542 540 2 923 850 ## 4 2013 1 1 544 545 -1 1004 1022 ## 5 2013 1 1 554 600 -6 812 837 ## 6 2013 1 1 554 558 -4 740 728 ## 7 2013 1 1 555 600 -5 913 854 ## 8 2013 1 1 557 600 -3 709 723 ## 9 2013 1 1 557 600 -3 838 846 ## 10 2013 1 1 558 600 -2 753 745 ## # … with 336,766 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; 我們也可以看到，變數名稱下方有諸如 &lt;int&gt;、&lt;dbl&gt; 等代號，即變數的型態： int 代表整數。 dbl 代表 doubles 或實數。 chr 代表字元向量或字串。 dttm 代表日期時間（date-times）。 lgl 代表 logical，即 TRUE 或 FALSE 的向量。 fctr 代表 factors，即類別變數。 date 代表時間。 9.1.3 基礎 dplyr 本章將會簡介 6 個 dplyr 函數，即： 在節 9.2 以 filter() 選取某些觀察值。 在節 9.3 以 arrange() 重新排列 rows。 在節 9.4 以 select() 選取變數。 在節 9.5 以 mutate() 與現存變數的函數創造新的變數。 在節 9.6 以 summarize() 摘要資料。 以 group_by() 比較群組之間的關係。 我們的工作就是在第一個引數丟入一個 data frame，並在第二個引數描述要對其做什麼，然後得到一個新的 data frame。 9.2 Filter Rows with filter() 我們可以用 filter 來選取某些觀察值，例如： filter(flights, month == 1, day == 1) ## # A tibble: 842 × 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 819 ## 2 2013 1 1 533 529 4 850 830 ## 3 2013 1 1 542 540 2 923 850 ## 4 2013 1 1 544 545 -1 1004 1022 ## 5 2013 1 1 554 600 -6 812 837 ## 6 2013 1 1 554 558 -4 740 728 ## 7 2013 1 1 555 600 -5 913 854 ## 8 2013 1 1 557 600 -3 709 723 ## 9 2013 1 1 557 600 -3 838 846 ## 10 2013 1 1 558 600 -2 753 745 ## # … with 832 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, ## # flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, ## # distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; 因為 filter() 會創造一個新的 data frame，而不會更動原先輸入的那個 data frame，所以 9.2.1 比較 我們可以用比較運算子，如 &gt;=、&lt;、&lt;=、!= 或 == 等來選取觀察值。 9.2.2 邏輯運算子 我們也可以運用邏輯運算子，如 &amp; 即 “and”，| 即 “or” 而 ! 即 “not”（切記不要用成 &amp;&amp; 或 ||！）。例如我們可以透過以下的程式碼找出 month 恰等於 11 或 12 的觀察值： filter(flights, month == 11 | month == 12) ## # A tibble: 55,403 × 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 11 1 5 2359 6 352 345 ## 2 2013 11 1 35 2250 105 123 2356 ## 3 2013 11 1 455 500 -5 641 651 ## 4 2013 11 1 539 545 -6 856 827 ## 5 2013 11 1 542 545 -3 831 855 ## 6 2013 11 1 549 600 -11 912 923 ## 7 2013 11 1 550 600 -10 705 659 ## 8 2013 11 1 554 600 -6 659 701 ## 9 2013 11 1 554 600 -6 826 827 ## 10 2013 11 1 554 600 -6 749 751 ## # … with 55,393 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; 上述的程式碼也有一種簡寫，即 x %in% y，將會選出所有 x 等於其中一個 y 的觀察值。上述的程式碼因此可以寫成： filter(flights, month %in% c(11, 12)) 我們如果想要找到 arr_delay 不超過 120 且 dep_delay 也不超過 120 的觀察值，下面兩行等價的程式碼都能達成： filter(flights, !(arr_delay &gt; 120 | dep_delay &gt; 120)) filter(flights, arr_delay &lt;= 120, dep_delay &lt;= 120) 9.2.3 缺漏值 filter() 只會選取邏輯判斷為 TRUE 的觀察值，而排除 FALSE 或 NA。如果也想選取 NA，則要明白地寫出來： df &lt;- tibble(x = c(1, NA, 3)) filter(df, x &gt; 1) ## # A tibble: 1 × 1 ## x ## &lt;dbl&gt; ## 1 3 filter(df, is.na(x) | x &gt; 1) ## # A tibble: 2 × 1 ## x ## &lt;dbl&gt; ## 1 NA ## 2 3 9.3 Arrange Rows with arrange() 使用 arrange() 可以改變觀察值的排列順序。 arrange(flights, year, month, day) # 先排前面的引數，由小至大排列 ## # A tibble: 336,776 × 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 819 ## 2 2013 1 1 533 529 4 850 830 ## 3 2013 1 1 542 540 2 923 850 ## 4 2013 1 1 544 545 -1 1004 1022 ## 5 2013 1 1 554 600 -6 812 837 ## 6 2013 1 1 554 558 -4 740 728 ## 7 2013 1 1 555 600 -5 913 854 ## 8 2013 1 1 557 600 -3 709 723 ## 9 2013 1 1 557 600 -3 838 846 ## 10 2013 1 1 558 600 -2 753 745 ## # … with 336,766 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; 使用 desc() 可以製造由大至小的排列，如： arrange(flights, desc(dep_time), day) ## # A tibble: 336,776 × 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 4 2 2400 2359 1 339 343 ## 2 2013 9 2 2400 2359 1 411 340 ## 3 2013 4 4 2400 2355 5 347 345 ## 4 2013 12 5 2400 2359 1 427 440 ## 5 2013 2 7 2400 2359 1 432 436 ## 6 2013 2 7 2400 2359 1 443 444 ## 7 2013 7 7 2400 1950 250 107 2130 ## 8 2013 12 9 2400 2359 1 432 440 ## 9 2013 12 9 2400 2250 70 59 2356 ## 10 2013 8 10 2400 2245 75 110 1 ## # … with 336,766 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; 缺漏值永遠排在最後，無論採用由小至大或由大至小的排列方式： df &lt;- tibble(x = c(5, 2, NA)) arrange(df, x) ## # A tibble: 3 × 1 ## x ## &lt;dbl&gt; ## 1 2 ## 2 5 ## 3 NA arrange(df, desc(x)) ## # A tibble: 3 × 1 ## x ## &lt;dbl&gt; ## 1 5 ## 2 2 ## 3 NA 9.4 Select Columns with select() filter() 與 arrange() 處理的對象是 rows，而 select() 處理的則是 columns。我們可以透過 select()，快速地選取指定的變數，如： select(flights, year, month, day) ## # A tibble: 336,776 × 3 ## year month day ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 ## 2 2013 1 1 ## 3 2013 1 1 ## 4 2013 1 1 ## 5 2013 1 1 ## 6 2013 1 1 ## 7 2013 1 1 ## 8 2013 1 1 ## 9 2013 1 1 ## 10 2013 1 1 ## # … with 336,766 more rows 或者： select(flights, year:day) # 選擇 year 至 day 之間所有的 columns select(flights, -(year:day)) # 選擇 year 至 day 以外的所有 columns 9.4.1 常用的 5 個函數 select() 之中還有幾個常用的函數可用，如： start_with(\"abc\")：選取名稱以 “abc” 開頭的變數。 ends_with(\"abc\")：選取名稱以 “abc” 結尾的變數。 contains(\"abc\")：選取名稱中包含 “abc” 的變數。 matches(\"abc$\")：選取名稱符合正規表示式的變數，此例中為名稱以 “abc” 結尾的變數。正規表示式將會在第 15 章介紹。 num_range(\"x\", 1:3)：選取名為 x1、x2、x3 的變數。 以下為範例： select(flights, starts_with(&quot;d&quot;)) # 選取名稱以 &quot;d&quot; 開頭的變數 ## # A tibble: 336,776 × 5 ## day dep_time dep_delay dest distance ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 517 2 IAH 1400 ## 2 1 533 4 IAH 1416 ## 3 1 542 2 MIA 1089 ## 4 1 544 -1 BQN 1576 ## 5 1 554 -6 ATL 762 ## 6 1 554 -4 ORD 719 ## 7 1 555 -5 FLL 1065 ## 8 1 557 -3 IAD 229 ## 9 1 557 -3 MCO 944 ## 10 1 558 -2 ORD 733 ## # … with 336,766 more rows select(flights, ends_with(&quot;t&quot;)) # 選取名稱以 &quot;t&quot; 結尾的變數 ## # A tibble: 336,776 × 2 ## flight dest ## &lt;int&gt; &lt;chr&gt; ## 1 1545 IAH ## 2 1714 IAH ## 3 1141 MIA ## 4 725 BQN ## 5 461 ATL ## 6 1696 ORD ## 7 507 FLL ## 8 5708 IAD ## 9 79 MCO ## 10 301 ORD ## # … with 336,766 more rows select(flights, contains(&quot;ep&quot;)) # 選取名稱中包含 &quot;ep&quot; 的變數 ## # A tibble: 336,776 × 3 ## dep_time sched_dep_time dep_delay ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 517 515 2 ## 2 533 529 4 ## 3 542 540 2 ## 4 544 545 -1 ## 5 554 600 -6 ## 6 554 558 -4 ## 7 555 600 -5 ## 8 557 600 -3 ## 9 557 600 -3 ## 10 558 600 -2 ## # … with 336,766 more rows select(flights, matches(&quot;time$&quot;)) # 選取名稱以 &quot;time&quot; 結尾的變數 ## # A tibble: 336,776 × 5 ## dep_time sched_dep_time arr_time sched_arr_time air_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 517 515 830 819 227 ## 2 533 529 850 830 227 ## 3 542 540 923 850 160 ## 4 544 545 1004 1022 183 ## 5 554 600 812 837 116 ## 6 554 558 740 728 150 ## 7 555 600 913 854 158 ## 8 557 600 709 723 53 ## 9 557 600 838 846 140 ## 10 558 600 753 745 138 ## # … with 336,766 more rows 9.4.2 重新命名：rename() 有兩種重新命名變數的方法： 使用 select(資料, 新變數名稱 = 舊變數名稱, everything())。之所以要加 everything 是因為如果不加，select() 將會丟棄其他所有變數，而 everything() 的用途即在補上其他 columns。 使用 rename(資料, 新變數名稱 = 舊變數名稱)。 此外，因為 everything() 可以補上其他沒有選到的 columns，所以也可以用來移動變數的順序，如我們想要把 dep_time 與 arr_time 移到前面的話，即： select(flights, dep_time, arr_time, everything()) ## # A tibble: 336,776 × 19 ## dep_time arr_time year month day sched_dep_time dep_delay sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 517 830 2013 1 1 515 2 819 ## 2 533 850 2013 1 1 529 4 830 ## 3 542 923 2013 1 1 540 2 850 ## 4 544 1004 2013 1 1 545 -1 1022 ## 5 554 812 2013 1 1 600 -6 837 ## 6 554 740 2013 1 1 558 -4 728 ## 7 555 913 2013 1 1 600 -5 854 ## 8 557 709 2013 1 1 600 -3 723 ## 9 557 838 2013 1 1 600 -3 846 ## 10 558 753 2013 1 1 600 -2 745 ## # … with 336,766 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; 9.5 Add New Variables with mutate() 我們還會想新增 columns 為既有 columns 的函數，那就要使用 mutate()。我們先新建一個小一點的表格，方便查看結果，然後新增兩個 columns，其一為 gain，為 arr_delay 減去 ep_delay；其一為 speed，為 distance 除以 air_time 再乘以 60： flights_sml &lt;- select(flights, year:day, ends_with(&quot;delay&quot;), distance, air_time) mutate(flights_sml, gain = arr_delay - dep_delay, speed = distance / air_time * 60) ## # A tibble: 336,776 × 9 ## year month day dep_delay arr_delay distance air_time gain speed ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2013 1 1 2 11 1400 227 9 370. ## 2 2013 1 1 4 20 1416 227 16 374. ## 3 2013 1 1 2 33 1089 160 31 408. ## 4 2013 1 1 -1 -18 1576 183 -17 517. ## 5 2013 1 1 -6 -25 762 116 -19 394. ## 6 2013 1 1 -4 12 719 150 16 288. ## 7 2013 1 1 -5 19 1065 158 24 404. ## 8 2013 1 1 -3 -14 229 53 -11 259. ## 9 2013 1 1 -3 -8 944 140 -5 405. ## 10 2013 1 1 -2 8 733 138 10 319. ## # … with 336,766 more rows 也可以在後面的引數中，使用前面的引數剛新增出來的 columns，如： mutate(flights_sml, gain = arr_delay - dep_delay, hours = air_time / 60, gain_per_hour = gain / hours) 只想要保存新變數的話，可以用 transmute()，如： transmute(flights_sml, gain = arr_delay - dep_delay, hours = air_time / 60, gain_per_hour = gain / hours) ## # A tibble: 336,776 × 3 ## gain hours gain_per_hour ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 9 3.78 2.38 ## 2 16 3.78 4.23 ## 3 31 2.67 11.6 ## 4 -17 3.05 -5.57 ## 5 -19 1.93 -9.83 ## 6 16 2.5 6.4 ## 7 24 2.63 9.11 ## 8 -11 0.883 -12.5 ## 9 -5 2.33 -2.14 ## 10 10 2.3 4.35 ## # … with 336,766 more rows 而如果新建的變數名稱與既有的變數名稱相同，則會覆蓋之，即既有的變數值被替換成 mutate() 中所指定的運算方法所得的變數值。 9.5.1 Useful Creation Functions 創建新 columns 有一些常用的、有用的運算子或函數： Arithmetic operators. +, -, *, /, ^. Modular arithmetic. %/% and %%. %/% 為整數除法，而 %% 為餘數。 如：30 %/% 4 等於 4；3 %% 2 等於 1。 Logs. log(), log2(), log10() Logical comparisons. &lt;, &lt;=, &gt;, &gt;=, !=. Offsets. lead() and lag(). lead() 可以用來指涉 leading values，而 lag() 可以用來指涉 lagging values。與 group_by() 一起使用有很大的用處。 例如 x &lt;- 1 : 10。lead(x) 會是 2 3 4 5 6 7 8 9 10 NA，而 lag(x) 會是 NA 1 2 3 4 5 6 7 8 9。 Logical comparisons. &lt;, &lt;=, &gt;, &gt;=, !=. Ranking. min_rank(), row_number(), dense_rank(), percent_rank(), cume_dist(), ntile(). min_rank()：依序輸入的向量中的元素依序報出向量各元素的大小排名（由小而大），重複的順序將會跳號。如 y &lt;- c(3, 4, 5, 2, 1)，第一個元素是第 3 小，第二個元素是第 4 小，第三個元素是第 5 小，第四個元素是第 2 小，第五個元素最小，因此回傳 3 4 5 2 1。而我們也可以搭配使用 desc()，則第一個元素是第 3 大，第二個元素是第 2 大，以此類推，將會回傳 3 2 1 4 5。 row_number：類似 min_rank()，但如果有重複的元素，將會把較前面的排的比較小。例如 z &lt;- c(1, 1, 0, 2, 3)，輸入 min_rank() 將會回傳 2 2 1 4 5；而輸入 row_number() 將會回傳 2 3 1 4 5。 dense_rank()：類似 min_rank()，但重複的順序不會跳號，如 z &lt;- c(1, 1, 0, 2, 3)，輸入 dense_rank() 將會回傳 2 2 1 3 4。 percent_rank(y)：min_rank() 的百分比版本。 cume_dist(y)：min_rank() 的累積版本。 y&lt;-c(1, 2, 2, NA, 3, 4) min_rank(y) # [1] 1 2 2 NA 4 5 row_number(y) # [1] 1 2 3 NA 4 5 row_number(y) # [1] 1 2 3 NA 4 5 dense_rank(y) # [1] 1 2 2 NA 3 4 percent_rank(y) # [1] 0.00 0.25 0.25 NA 0.75 1.00 cume_dist(y) # [1] 0.2 0.6 0.6 NA 0.8 1.0 Cumulative and rolling aggregates. cumsum(), cumprod(), cummin(), cummax(), cummean(). 前四者為 R 本身提供，cummean() 為 dplyr 所提供。 分別可以計算 running sums、products、mins、maxes 與 cumulative means，例如： x &lt;- 1 : 10 cumsum(x) # [1] 1 3 6 10 15 21 28 36 45 55 cumprod(x) # [1] 1 2 6 24 120 720 5040 40320 362880 # [10] 3628800 cummin(x) # [1] 1 1 1 1 1 1 1 1 1 1 cummax(x) # [1] 1 2 3 4 5 6 7 8 9 10 cummean(x) # [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 9.6 Grouped Summaries with summarize() summarize() 會把整個表格整理成單一個 row。我們可以使用 summarize() 來計算全部航班的 dep_delay 的平均值： summarize(flights, delay = mean(dep_delay, na.rm = TRUE)) ## # A tibble: 1 × 1 ## delay ## &lt;dbl&gt; ## 1 12.6 其中，使用 na.rm = TRUE 的原因在避免計算出一大堆 NA，見節 9.6.2。 但 summarize() 要搭配上 group_by() 才顯得更強大。如果我們想要知道每天的 dep_delay 的平均到底是多少與每天有多少個航班，我們可以使用 group_by()，將 flights 這個 dataset 依照 year、month、day 分組，然後指派給變數 by_day。接著，我們就可以使用 summarize()，並定義兩個新變數欄位為 delay 與 count，如： by_day &lt;- group_by(flights, year, month, day) summarize(by_day, delay = mean(dep_delay, na.rm = TRUE), count = n()) ## `summarise()` has grouped output by &#39;year&#39;, &#39;month&#39;. You can override using the `.groups` argument. ## # A tibble: 365 × 5 ## # Groups: year, month [12] ## year month day delay count ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 1 1 11.5 842 ## 2 2013 1 2 13.9 943 ## 3 2013 1 3 11.0 914 ## 4 2013 1 4 8.95 915 ## 5 2013 1 5 5.73 720 ## 6 2013 1 6 7.15 832 ## 7 2013 1 7 5.42 933 ## 8 2013 1 8 2.55 899 ## 9 2013 1 9 2.28 902 ## 10 2013 1 10 2.84 932 ## # … with 355 more rows 9.6.1 以 Pipe 結合多重運算 如果我們想知道距離與每個地點的平均延誤的關係，我們可以： 使用 group_by，依據 dest（終點）來分類 flights。 使用 summarize() 製造一個新的 tibble，列出各個 dest 的次數（count）、平均距離（dist）與平均抵達延誤（delay）。 使用 filter()，第一個引數放入剛剛新建的表格，然後移除 noise（出現次數小於 20 次者），並移除 “HNL” 這個終點站。 上面的步驟正如： by_dest &lt;- group_by(flights, dest) delay &lt;- summarize(by_dest, count = n(), dist = mean(distance, na.rm = TRUE), delay = mean(arr_delay, na.rm = TRUE)) # 整理資料 delay &lt;- filter(delay, count &gt; 20, dest != &quot;HNL&quot;) # 移除噪點 ggplot(data = delay, mapping = aes(x = dist, y = delay)) + geom_point(aes(size = count), alpha = 1/3) + geom_smooth(method = &#39;loess&#39;, formula = &quot;y ~ x&quot;, se = FALSE) # 繪圖 但這種撰寫程式碼的方式稍嫌惱人，因為我們還要幫中間的 data frame 取名字。使用 pipe %&gt;% 可以解決此問題： delays &lt;- flights %&gt;% group_by(dest) %&gt;% summarize(count = n(), dist = mean(distance, na.rm = TRUE), delay = mean(arr_delay, na.rm = TRUE)) %&gt;% filter(count &gt; 20, dest != &quot;HNL&quot;) %&gt;% 可以讀成 “then”，即我們先使用 group_by 分組，然後使用 summarize() 計算次數與平均數，然後使用 filter() 過濾掉噪點與不想要的觀察值。這背後的邏輯就是 x %&gt;% f(y) 即 f(x, y)，而 x %&gt;% f(y) %&gt;% g(z) 即 g(f(x, y), z)。 9.6.2 缺漏值 前開使用的 na.rm 引數的功能即決定要不要在計算前移除掉 NA。如果我們沒有設定 na.rm = TRUE，則我們將會製造出一大堆 NA，因為 NA 無論做什麼運算都會得到 NA，所以只要有其中一個觀察值的 dep_delay 為 NA，那一整天的平均就會是 NA，如： flights %&gt;% group_by(year, month, day) %&gt;% summarize(mean = mean(dep_delay)) %&gt;% group_by(mean) %&gt;% summarize(count = n()) ## `summarise()` has grouped output by &#39;year&#39;, &#39;month&#39;. You can override using the `.groups` argument. ## # A tibble: 8 × 2 ## mean count ## &lt;dbl&gt; &lt;int&gt; ## 1 0.145 1 ## 2 0.241 1 ## 3 1.61 1 ## 4 3.53 1 ## 5 6.06 1 ## 6 7.78 1 ## 7 7.93 1 ## 8 NA 358 我們可以發現製造了 358 個 NA！以下就不會產生上面的問題了： flights %&gt;% group_by(year, month, day) %&gt;% summarize(mean = mean(dep_delay, na.rm = TRUE)) 在此，NA 代表航班取消；我們也可以先把 NA 的地方去除掉，如： not_cancelled &lt;- flights %&gt;% filter(!is.na(dep_delay), !is.na(arr_delay)) not_cancelled %&gt;% group_by(year, month, day) %&gt;% summarize(mean = mean(dep_delay)) ## `summarise()` has grouped output by &#39;year&#39;, &#39;month&#39;. You can override using the `.groups` argument. ## # A tibble: 365 × 4 ## # Groups: year, month [12] ## year month day mean ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2013 1 1 11.4 ## 2 2013 1 2 13.7 ## 3 2013 1 3 10.9 ## 4 2013 1 4 8.97 ## 5 2013 1 5 5.73 ## 6 2013 1 6 7.15 ## 7 2013 1 7 5.42 ## 8 2013 1 8 2.56 ## 9 2013 1 9 2.30 ## 10 2013 1 10 2.84 ## # … with 355 more rows 9.6.3 計數 我們可以加入計數（n()）或非缺漏值的計數（sum(!is.na(x))），避免我們從很小的樣本得出結論。 delays &lt;- not_cancelled %&gt;% group_by(tailnum) %&gt;% summarize(delay = mean(arr_delay)) ggplot(data = delays, mapping = aes(x = delay)) + geom_freqpoly(binwidth = 10) 我們可以發現，有些航班甚至可以延遲超過 300 秒！但我們如果畫出散佈圖就會發現，如果只有少數幾個航班的日子，取平均以後其變異就會非常大，即樣本越大，變異越小（類似大數法則中，當樣本越來越大，估計參數會機率收斂到母體參數的概念），如： delays &lt;- not_cancelled %&gt;% group_by(tailnum) %&gt;% summarize(delay = mean(arr_delay, na.rm = TRUE),n=n()) ggplot(data = delays, mapping = aes(x = n, y = delay)) + geom_point(alpha = 1/10) 所以我們其實可以移除掉樣本過小的日期，如： delays %&gt;% filter(n &gt; 25) %&gt;% ggplot(mapping = aes(x = n, y = delay)) + geom_point(alpha = 1/10) 我們接下來使用 Lahman 這個套件中的 Batting 這個 data frame 來討論棒球比賽中打擊者的表現與擊球次數的關係。 library(Lahman) # 載入 Lahman batting &lt;- as_tibble(Lahman::Batting) # 將 Batting 轉換成 tibble 型態 batters &lt;- batting %&gt;% group_by(playerID) %&gt;% summarize(ba = sum(H, na.rm = TRUE) / sum(AB, na.rm = TRUE), ab = sum(AB, na.rm = TRUE) ) # ba 為 batting average，即打擊率，衡量打擊的能力 # ab 為 at bat，即上場打擊的機會 batters %&gt;% filter(ab &gt; 100) %&gt;% ggplot(mapping = aes(x = ab, y = ba)) + geom_point() + geom_smooth(se = FALSE) ## `geom_smooth()` using method = &#39;gam&#39; and formula &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; 我們可以發現，打擊次數越多的球員，打擊率也就越高，兩者有正向的關係；這可能是因為球隊會讓能打球的球員上場。 9.6.4 有用的歸納函數 Measures of location: mean(x), median(x). not_cancelled %&gt;% group_by(year, month, day) %&gt;% summarize( # average delay: avg_delay1 = mean(arr_delay), # average positive delay: avg_delay2 = mean(arr_delay[arr_delay &gt; 0]) ) ## `summarise()` has grouped output by &#39;year&#39;, &#39;month&#39;. You can override using the `.groups` argument. ## # A tibble: 365 × 5 ## # Groups: year, month [12] ## year month day avg_delay1 avg_delay2 ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2013 1 1 12.7 32.5 ## 2 2013 1 2 12.7 32.0 ## 3 2013 1 3 5.73 27.7 ## 4 2013 1 4 -1.93 28.3 ## 5 2013 1 5 -1.53 22.6 ## 6 2013 1 6 4.24 24.4 ## 7 2013 1 7 -4.95 27.8 ## 8 2013 1 8 -3.23 20.8 ## 9 2013 1 9 -0.264 25.6 ## 10 2013 1 10 -5.90 27.3 ## # … with 355 more rows Measures of spread: sd(x), IQR(x), mad(x). 標準差、四分位距（interquartile range）與絕對中位差（median absolute deviation，即原數據減去中位數所得的新數據的絕對值的中位數）。 \\(\\mbox{MAD} = \\mbox{median}(|X_i - \\mbox{median}|)\\). # 算出不同目的地的距離標準差，並降冪排列 not_cancelled %&gt;% group_by(dest) %&gt;% summarize(distance_sd = sd(distance)) %&gt;% arrange(desc(distance_sd)) ## # A tibble: 104 × 2 ## dest distance_sd ## &lt;chr&gt; &lt;dbl&gt; ## 1 EGE 10.5 ## 2 SAN 10.4 ## 3 SFO 10.2 ## 4 HNL 10.0 ## 5 SEA 9.98 ## 6 LAS 9.91 ## 7 PDX 9.87 ## 8 PHX 9.86 ## 9 LAX 9.66 ## 10 IND 9.46 ## # … with 94 more rows Measures of rank: min(x), quantile(x, 0.25), max(x). quantile(x, 0.25) 即大於 25 % 的樣本但小於剩餘的 75 % 者。 # 算出每天第一班與最後一班班機 not_cancelled %&gt;% group_by(year, month, day) %&gt;% summarize( first = min(dep_time), last = max(dep_time) ) ## `summarise()` has grouped output by &#39;year&#39;, &#39;month&#39;. You can override using the `.groups` argument. ## # A tibble: 365 × 5 ## # Groups: year, month [12] ## year month day first last ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 2356 ## 2 2013 1 2 42 2354 ## 3 2013 1 3 32 2349 ## 4 2013 1 4 25 2358 ## 5 2013 1 5 14 2357 ## 6 2013 1 6 16 2355 ## 7 2013 1 7 49 2359 ## 8 2013 1 8 454 2351 ## 9 2013 1 9 2 2252 ## 10 2013 1 10 3 2320 ## # … with 355 more rows Measures of position: first(x), nth(x, 2), last(x). # 找出每天第一班與最後一班班機 not_cancelled %&gt;% group_by(year, month, day) %&gt;% summarize( first = min(dep_time), last = max(dep_time) ) ## `summarise()` has grouped output by &#39;year&#39;, &#39;month&#39;. You can override using the `.groups` argument. ## # A tibble: 365 × 5 ## # Groups: year, month [12] ## year month day first last ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 2356 ## 2 2013 1 2 42 2354 ## 3 2013 1 3 32 2349 ## 4 2013 1 4 25 2358 ## 5 2013 1 5 14 2357 ## 6 2013 1 6 16 2355 ## 7 2013 1 7 49 2359 ## 8 2013 1 8 454 2351 ## 9 2013 1 9 2 2252 ## 10 2013 1 10 3 2320 ## # … with 355 more rows not_cancelled %&gt;% group_by(year, month, day) %&gt;% mutate(r = min_rank(desc(dep_time))) %&gt;% filter(r %in% range(r)) ## # A tibble: 770 × 20 ## # Groups: year, month, day [365] ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 819 ## 2 2013 1 1 2356 2359 -3 425 437 ## 3 2013 1 2 42 2359 43 518 442 ## 4 2013 1 2 2354 2359 -5 413 437 ## 5 2013 1 3 32 2359 33 504 442 ## 6 2013 1 3 2349 2359 -10 434 445 ## 7 2013 1 4 25 2359 26 505 442 ## 8 2013 1 4 2358 2359 -1 429 437 ## 9 2013 1 4 2358 2359 -1 436 445 ## 10 2013 1 5 14 2359 15 503 445 ## # … with 760 more rows, and 12 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, ## # flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, ## # distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, r &lt;int&gt; Counts: n(), sum(!is.na(x)), n_distinct(x):. sum(!is.na(x)): non-missing values. n_distinct(x): the number of distinct (unique) values. not_cancelled %&gt;% group_by(dest) %&gt;% summarize(carriers = n_distinct(carrier)) %&gt;% arrange(desc(carriers)) ## # A tibble: 104 × 2 ## dest carriers ## &lt;chr&gt; &lt;int&gt; ## 1 ATL 7 ## 2 BOS 7 ## 3 CLT 7 ## 4 ORD 7 ## 5 TPA 7 ## 6 AUS 6 ## 7 DCA 6 ## 8 DTW 6 ## 9 IAD 6 ## 10 MSP 6 ## # … with 94 more rows # 因為 count() 太常用了 # 所以甚至不用 summerize() 就可以直接使用 not_cancelled %&gt;% count(dest) # 甚至可以在引數 wt 加上權重 # 如下算出各飛機的總里程 not_cancelled %&gt;% count(tailnum, wt = distance) ## # A tibble: 4,037 × 2 ## tailnum n ## &lt;chr&gt; &lt;dbl&gt; ## 1 D942DN 3418 ## 2 N0EGMQ 239143 ## 3 N10156 109664 ## 4 N102UW 25722 ## 5 N103US 24619 ## 6 N104UW 24616 ## 7 N10575 139903 ## 8 N105UW 23618 ## 9 N107US 21677 ## 10 N108UW 32070 ## # … with 4,027 more rows Counts and proportions of logical values: sum(x &gt; 10), mean(y == 0). 如果這些邏輯判斷式為真，那就會回傳 TRUE，反之則回傳 FALSE。 據此，我們可以使用 sum() 來得知符合這些條件的有多少，而使用 mean() 來得知符合條件的比例。 # 如果我們想得知每天離開時間小於 500 的班次數目，可以如下 not_cancelled %&gt;% group_by(year, month, day) %&gt;% summarize(n_early = sum(dep_time &lt; 500)) ## `summarise()` has grouped output by &#39;year&#39;, &#39;month&#39;. You can override using the `.groups` argument. ## # A tibble: 365 × 4 ## # Groups: year, month [12] ## year month day n_early ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 0 ## 2 2013 1 2 3 ## 3 2013 1 3 4 ## 4 2013 1 4 3 ## 5 2013 1 5 3 ## 6 2013 1 6 2 ## 7 2013 1 7 2 ## 8 2013 1 8 1 ## 9 2013 1 9 3 ## 10 2013 1 10 3 ## # … with 355 more rows # 如果我們想得知每天延誤超過一小時的航班的比例，可以如下 not_cancelled %&gt;% group_by(year, month, day) %&gt;% summarize(hour_perc = mean(arr_delay &gt; 60)) ## `summarise()` has grouped output by &#39;year&#39;, &#39;month&#39;. You can override using the `.groups` argument. ## # A tibble: 365 × 4 ## # Groups: year, month [12] ## year month day hour_perc ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2013 1 1 0.0722 ## 2 2013 1 2 0.0851 ## 3 2013 1 3 0.0567 ## 4 2013 1 4 0.0396 ## 5 2013 1 5 0.0349 ## 6 2013 1 6 0.0470 ## 7 2013 1 7 0.0333 ## 8 2013 1 8 0.0213 ## 9 2013 1 9 0.0202 ## 10 2013 1 10 0.0183 ## # … with 355 more rows 9.6.5 依據多變數分組 像撥洋蔥一樣，但不太可能適用於有牽涉到排序的統計量，如中位數。 daily &lt;- group_by(flights, year, month, day) (per_day &lt;-summarize(daily,flights=n())) ## `summarise()` has grouped output by &#39;year&#39;, &#39;month&#39;. You can override using the `.groups` argument. ## # A tibble: 365 × 4 ## # Groups: year, month [12] ## year month day flights ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 842 ## 2 2013 1 2 943 ## 3 2013 1 3 914 ## 4 2013 1 4 915 ## 5 2013 1 5 720 ## 6 2013 1 6 832 ## 7 2013 1 7 933 ## 8 2013 1 8 899 ## 9 2013 1 9 902 ## 10 2013 1 10 932 ## # … with 355 more rows (per_month &lt;- summarize(per_day, flights = sum(flights))) ## `summarise()` has grouped output by &#39;year&#39;. You can override using the `.groups` argument. ## # A tibble: 12 × 3 ## # Groups: year [1] ## year month flights ## &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 27004 ## 2 2013 2 24951 ## 3 2013 3 28834 ## 4 2013 4 28330 ## 5 2013 5 28796 ## 6 2013 6 28243 ## 7 2013 7 29425 ## 8 2013 8 29327 ## 9 2013 9 27574 ## 10 2013 10 28889 ## 11 2013 11 27268 ## 12 2013 12 28135 (per_year &lt;- summarize(per_month, flights = sum(flights))) ## # A tibble: 1 × 2 ## year flights ## &lt;int&gt; &lt;int&gt; ## 1 2013 336776 9.6.6 取消分組 使用 ungroup() 可以取消分組，如下： daily %&gt;% ungroup() %&gt;% # no longer grouped by date summarize(flights = n()) ## # A tibble: 1 × 1 ## flights ## &lt;int&gt; ## 1 336776 9.7 Grouped Mutates (and Filters) 除了與 summarize() 共同使用，group_by 與 mutate() 及 filter() 共同使用也很方便，例如： 找每組最差的成員： flights_sml %&gt;% group_by(year, month, day) %&gt;% filter(rank(desc(arr_delay)) &lt; 10) ## # A tibble: 3,306 × 7 ## # Groups: year, month, day [365] ## year month day dep_delay arr_delay distance air_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2013 1 1 853 851 184 41 ## 2 2013 1 1 290 338 1134 213 ## 3 2013 1 1 260 263 266 46 ## 4 2013 1 1 157 174 213 60 ## 5 2013 1 1 216 222 708 121 ## 6 2013 1 1 255 250 589 115 ## 7 2013 1 1 285 246 1085 146 ## 8 2013 1 1 192 191 199 44 ## 9 2013 1 1 379 456 1092 222 ## 10 2013 1 2 224 207 550 94 ## # … with 3,296 more rows 找到所有大於某個閾值的組別： popular_dests &lt;- flights %&gt;% group_by(dest) %&gt;% filter(n() &gt; 365) popular_dests ## # A tibble: 332,577 × 19 ## # Groups: dest [77] ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 819 ## 2 2013 1 1 533 529 4 850 830 ## 3 2013 1 1 542 540 2 923 850 ## 4 2013 1 1 544 545 -1 1004 1022 ## 5 2013 1 1 554 600 -6 812 837 ## 6 2013 1 1 554 558 -4 740 728 ## 7 2013 1 1 555 600 -5 913 854 ## 8 2013 1 1 557 600 -3 709 723 ## 9 2013 1 1 557 600 -3 838 846 ## 10 2013 1 1 558 600 -2 753 745 ## # … with 332,567 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, ## # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, ## # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; 標準化： popular_dests %&gt;% filter(arr_delay &gt; 0) %&gt;% mutate(prop_delay = arr_delay / sum(arr_delay)) %&gt;% select(year:day, dest, arr_delay, prop_delay) ## # A tibble: 131,106 × 6 ## # Groups: dest [77] ## year month day dest arr_delay prop_delay ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2013 1 1 IAH 11 0.000111 ## 2 2013 1 1 IAH 20 0.000201 ## 3 2013 1 1 MIA 33 0.000235 ## 4 2013 1 1 ORD 12 0.0000424 ## 5 2013 1 1 FLL 19 0.0000938 ## 6 2013 1 1 ORD 8 0.0000283 ## 7 2013 1 1 LAX 7 0.0000344 ## 8 2013 1 1 DFW 31 0.000282 ## 9 2013 1 1 ATL 12 0.0000400 ## 10 2013 1 1 DTW 16 0.000116 ## # … with 131,096 more rows 參考文獻 "],["EDA.html", "10 探索性資料分析 10.1 事前準備 10.2 問題 10.3 Variation 10.4 Missing Value 10.5 Covariation 10.6 模式與模型", " 10 探索性資料分析 本章為 Wickham and Grolemund (2016) 第 5 章內容。 資料一拿來就先跑跑看長什麼樣子！ 10.1 事前準備 探索性資料分析（Exploratory Data Analysis, EDA）的目標就是要更了解資料，而步驟可以為： 構思關於這筆資料的問題。 透過視覺化、轉換和建模，試著尋找答案。 經由所得的結果，重整原先的問題，或者構思、增加新的問題。 10.2 問題 Far better an approximate answer to the right question, which is often vague, than an exact answer to the wrong question, which can always be made precise. —John Tukey 你可以問這兩類的問題： What type of variation occurs within my variables? What type of covariation occurs between my variables? 10.3 Variation Variation 即每次測量變數值所得的趨勢（tendency）。每個變數都有自己的 variation，而要看出 variation，最好的方法是視覺化變數值的分配。 10.3.1 視覺化分配 如果是類別變數，我們可以使用 bar chart 來視覺化，因為它只有一小組變數值，而存成 factors 或 characters 的向量，如： ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut)) 也可以使用 dplyr 的 count() 來計算究竟各種品質的鑽石有多少，如： diamonds %&gt;% count(cut) ## # A tibble: 5 × 2 ## cut n ## &lt;ord&gt; &lt;int&gt; ## 1 Fair 1610 ## 2 Good 4906 ## 3 Very Good 12082 ## 4 Premium 13791 ## 5 Ideal 21551 如果是連續變數，例如數字與日期時間，我們則要使用 histogram，如： # binwidth 引數即直方圖的直方寬度 ggplot(data = diamonds) + geom_histogram(mapping = aes(x = carat), binwidth = 0.5) 我們也可以用 count() 來計算，如： diamonds %&gt;% count(cut_width(carat, 0.5)) ## # A tibble: 11 × 2 ## `cut_width(carat, 0.5)` n ## &lt;fct&gt; &lt;int&gt; ## 1 [-0.25,0.25] 785 ## 2 (0.25,0.75] 29498 ## 3 (0.75,1.25] 15977 ## 4 (1.25,1.75] 5313 ## 5 (1.75,2.25] 2002 ## 6 (2.25,2.75] 322 ## 7 (2.75,3.25] 32 ## 8 (3.25,3.75] 5 ## 9 (3.75,4.25] 4 ## 10 (4.25,4.75] 1 ## 11 (4.75,5.25] 1 如果想要重疊多個直方圖，使用 geom_frepoly() 而非 geom_histogram()。兩者的算法一樣，但前者以線來呈現，後者以直方來呈現，如： ggplot(data = diamonds, mapping = aes(x = carat, color = cut)) + geom_freqpoly(binwidth = 0.1) 10.3.2 代表性的變數值 哪些是變數值經常出現？哪些變數值很少出現？其中有什麼規律？ ggplot(data = diamonds, mapping = aes(x = carat)) + geom_histogram(binwidth = 0.01) 為何克拉數為整數與某些常見的有理數的觀察值特別多？為何每個高峰的右側都比左側更緩？為何超過 3 克拉的鑽石很稀有？ 類似的值的群集（cluster）通常意味著資料中有子群（subgroup）。我們可以質問幾個問題： 每個 subgroup 中的觀察值與其他 subgroups 之間有何相異或相似？ 如何描述或解釋群集？ 為何群集的外觀可能產生誤導？ 10.3.3 不尋常的變數值 Outliers 即不尋常的變數值，可能源自資料輸入錯誤，也可能是一些不一樣的東西。 要注意的是，當樣本很大時，使用直方圖很難看出 outliers；例如上一張圖中，事實上 3 克拉到 5 克拉之間都還有觀察值，可是從直方圖幾乎看不出來。我們可以透過 coord_cartesian()，來改變 y 軸的上下限，這樣就可以辨識稀有的觀察值了，如： ggplot(diamonds) + geom_histogram(mapping = aes(x = y), binwidth = 0.5) + coord_cartesian(ylim = c(0, 50)) 或者，我們也可以使用 dplyr，列出寬度小於 3 mm 或超過 20 mm 的觀察值： unusual &lt;- diamonds %&gt;% filter(y &lt; 3 | y &gt; 20) %&gt;% arrange(y) unusual ## # A tibble: 9 × 10 ## carat cut color clarity depth table price x y z ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 Very Good H VS2 63.3 53 5139 0 0 0 ## 2 1.14 Fair G VS1 57.5 67 6381 0 0 0 ## 3 1.56 Ideal G VS2 62.2 54 12800 0 0 0 ## 4 1.2 Premium D VVS1 62.1 59 15686 0 0 0 ## 5 2.25 Premium H SI2 62.8 59 18034 0 0 0 ## 6 0.71 Good F SI2 64.1 60 2130 0 0 0 ## 7 0.71 Good F SI2 64.1 60 2130 0 0 0 ## 8 0.51 Ideal E VS1 61.8 55 2075 5.15 31.8 5.12 ## 9 2 Premium H SI2 58.9 57 12210 8.09 58.9 8.06 我們可以發現，寬度等於 0 mm 的鑽石根本不可能存在，顯然是打錯了；而寬度為 31.8 mm 與 58.9 mm 那兩個觀察值的價格也不合理。此種錯誤（像是輸入錯誤）所出現的 outliers 就該丟掉。但也不是逢 outliers 就該丟掉，如果其有真實的意義，那還是必須保留。 10.4 Missing Value 10.4.1 替換掉 Outliers 遇到 outliers，有兩種做法： 丟棄有奇怪的變數值的觀察值。可是，其中一個變數輸入錯誤不代表其他變數就也輸入錯誤。而且如果資料品質不良，可能最後什麼都不剩。 # 丟棄有奇怪的變數值的觀察 diamonds2 &lt;- diamonds %&gt;% filter(between(y, 3, 20)) （推薦）把 outliers 的變數值換成 NA。我們可以使用 mutate() 與 ifelse()，如： # 把 outliers 的變數值換成 NA diamonds2 &lt;- diamonds %&gt;% mutate(y = ifelse(y &lt; 3 | y &gt; 20, NA, y)) # 這樣畫出來的散佈圖就不會是 y 的 outliers ggplot(data = diamonds2, mapping = aes(x = x, y = y)) + geom_point(na.rm = TRUE) # 注意：設定 na.rm = TRUE，忽略掉 NA 10.4.2 比較 NA 與否 有時候我們想了解具有 NA 的觀察值與有變數值的觀察值有何區別，那我們就可以使用 mutate() 與 is.na() 來記錄。在 nycflights13 的 flights 中，dep_time 如果是 NA，那表示航班取消。當我們想要比較取消航班與為取消航班之間的預計離開時間的差別，我們可以： nycflights13::flights %&gt;% mutate( cancelled = is.na(dep_time), sched_hour = sched_dep_time %/% 100, sched_min = sched_dep_time %% 100, sched_dep_time = sched_hour + sched_min / 60) %&gt;% ggplot(mapping = aes(sched_dep_time)) + geom_freqpoly(mapping = aes(color = cancelled), binwidth = 1/4) 不過，因為未取消航班比取消的航班多太多了，因此下個章節我們要對此做些改進。 10.5 Covariation Covariation 即兩個或多個變數變動的關係。想要發覺 covariation，最好的辦法就是視覺化它。但如何視覺化則牽涉到變數型態的問題。 10.5.1 類別與連續變數 為什麼我們剛剛所使用的 geom_freqpoly() 不太適合拿來「比較」變數？ 這是因為，geom_freqpoly() 的高度（縱軸）是出現次數，所以說如果有一組遠小於另一組，像剛剛的情況，那我們就很難看出其形狀的差異。以下還有另一個例子為比較不同品質的鑽石之間的價格差異： ggplot(data = diamonds, mapping = aes(x = price)) + geom_freqpoly(mapping = aes(color = cut), binwidth = 500) 這種時候，我們可以把 \\(y\\) 軸從呈現 “count”，改成呈現 “density”，即經過標準化的 count，在每組的多邊形底下的面積都為 \\(1\\)，如： ggplot(data = diamonds, mapping = aes(x = price, y = ..density..)) + geom_freqpoly(mapping = aes(color = cut), binwidth = 500) 另一種把連續變數拆成類別變數然後呈現的方法是使用箱形圖（box plot），其可以把某些分佈的特徵給視覺化；即每個箱形圖中的箱子的底部都是 25 百分位，而頂部都是 75 百分位，箱子的中間則是中位數。我們可以大略看出分佈與偏態，而箱形圖中的點則是 outliers，線則是從箱子外延伸到非 outliers 的地方，如： ggplot(data = diamonds, mapping = aes(x = cut, y = price)) + geom_boxplot() 看起來似乎 fair 的比較貴！為什麼？實際上是因為 fair 的鑽石相對比較大顆，如： ggplot(data = diamonds, mapping = aes(x = cut, y = carat)) + geom_boxplot() 類別變數經常是有序的（例如 cut），但也有些並不然。如果類別變數無序，我們又希望它按照一定的方式來排序呢？可以使用 reorder()。例如，在 mpg 這個 dataset 中，class 其實是無序的，我們想知道各種 class 的 hwy 的話，以箱形圖描繪，就如： ggplot(data = mpg, mapping = aes(x = class, y = hwy)) + geom_boxplot() 那如果我們想要依照中位數來排序 class 的變數值的話，根據說明文檔，reorder 的語法如： reorder(x, X, FUN = mean, ..., order = is.ordered(x)) 因此可以： ggplot(data = mpg) + geom_boxplot(mapping = aes( x = reorder(class, hwy, FUN = median), y = hwy )) 也可以仿效節 (coordinatedsystem) 的作法，加上 coord_flip()，將箱形圖旋轉 90 度，如： ggplot(data = mpg) + geom_boxplot(mapping = aes( x = reorder(class, hwy, FUN = median), y = hwy )) + coord_flip() 10.5.2 兩個類別變數 要視覺化兩個類別變數之間的 covariation，我們要計算各種組合有多少觀察值，如使用 geom_count()： ggplot(data = diamonds) + geom_count(mapping = aes(x = cut, y = color)) 或者以 dplyr 來計算： diamonds %&gt;% count(color, cut) ## # A tibble: 35 × 3 ## color cut n ## &lt;ord&gt; &lt;ord&gt; &lt;int&gt; ## 1 D Fair 163 ## 2 D Good 662 ## 3 D Very Good 1513 ## 4 D Premium 1603 ## 5 D Ideal 2834 ## 6 E Fair 224 ## 7 E Good 933 ## 8 E Very Good 2400 ## 9 E Premium 2337 ## 10 E Ideal 3903 ## # … with 25 more rows 這也可以接著以 geom_title() 來視覺化，如： diamonds %&gt;% count(color, cut) %&gt;% ggplot(mapping = aes(x = color, y = cut)) + geom_tile(mapping = aes(fill = n)) 而如果類別變數是無序的，我們可能會需要使用 seration 套件來同時重新排序 rows 與 columns；如果想要畫更大的熱圖，可能會需要使用 d3heatmap 或 heatmaply 套件。 10.5.3 兩個連續變數 要視覺化兩個連續變數的可以 geom_point() 畫出散佈圖，如： ggplot(data = diamonds) + geom_point(mapping = aes(x = carat, y = price)) 不過 overplot 的情況在小克拉的鑽石有點嚴重，因此我們可以更改透明度，如： ggplot(data = diamonds) + geom_point(mapping = aes(x = carat, y = price), alpha = 1/100) 但其實在很大的 dataset 中，更改透明度也不見得是好辦法。 除了單純描繪散佈圖以外，另一個方法是使用 bin。以前的 geom_histogram() 與 geom_freqpoly() 為單向度的 bin，我們現在要使用 geom_bin2d() 與 geom_hex() 來描繪兩個向度的 bin。 geom_bin2d() 與 geom_hex() 所繪製出來的圖形樣式相似，都是有二維的 bins，而使用 fill 來表示數量，差別在 geom_bin2d() 繪製出來的是矩形，而 geom_hex() 繪製出來的是六邊形，如： ggplot(data = diamonds) + geom_bin2d(mapping = aes(x = carat, y = price)) # install.packages(&quot;hexbin&quot;) library(hexbin) ggplot(data = diamonds) + geom_hex(mapping = aes(x = carat, y = price)) 還有一種方式是把連續變數用 bin 拆成類別變數，然後繪製箱形圖，如下把克拉拆成類別變數： ggplot(data = diamonds, mapping = aes(x = carat, y = price)) + geom_boxplot(mapping = aes(group = cut_width(carat, 0.3))) 但我們如果使用箱形圖的話，要怎麼看出各個 bin 的觀察值數量呢？我們可以設置 varwidth = TRUE，這會讓箱子的寬度與觀察值的數量成比例，如： ggplot(data = diamonds, mapping = aes(x = carat, y = price)) + geom_boxplot(mapping = aes(group = cut_width(carat, 0.3)), varwidth = TRUE) 另一個看出觀察值數量的方法是使用 cut_number()，這會讓每個 bin 所包含的觀察值數量相當，以下圖而言，即克拉數大的鑽石很少： ggplot(data = diamonds, mapping = aes(x = carat, y = price)) + geom_boxplot(mapping = aes(group = cut_number(carat, 20))) 10.6 模式與模型 模式（patterns）為兩個變數之間系統性的關係，如： ggplot(data = faithful) + geom_point(mapping = aes(x = eruptions, y = waiting)) 我們可以看出，等待時間越長伴隨著更長時間的爆發。 模型（models）則是從資料中萃取出 patterns 的工具。例如以 diamonds 資料集來說，我們很難弄清楚 cut 與 price 之間的關係，因為「cut 與 carat」及「carat 與 price」之間都密切相關。我們如果能使用模型移除掉 price 與 carat 之間的關係，那我們就能更清楚 cut 與 price 之間的關係。以下的程式碼就是先算出 carat 對 price 的效果，而其無法解釋的部份就在殘差項。我們能說，殘差項就撇除了 carat 對 price 的效果，那很有可能就是 cut 對 price 的效果，如： library(modelr) mod &lt;- lm(log(price) ~ log(carat), data = diamonds) diamonds2 &lt;- diamonds %&gt;% add_residuals(mod) %&gt;% mutate(resid = exp(resid)) ggplot(data = diamonds2) + geom_point(mapping = aes(x = carat, y = resid)) 在我們移除了 carat 對 price 的效果後，很清楚地，可以看出 cut 與 price 之間的關係；即給定鑽石大小，品質越好的鑽石越貴！（非常符合直覺） 我們也能從箱形圖看「品質越好的鑽石越貴」這一現象： ggplot(data = diamonds2) + geom_boxplot(mapping = aes(x = cut, y = resid)) 本書之後會更深入探討關於模型的問題。 參考文獻 "],["tibble.html", "11 以 tibble 處理 Tibbles 11.1 創建 Tibbles 11.2 Tibbles 與 Data Frames 的比較 11.3 古老的程式碼", " 11 以 tibble 處理 Tibbles 本章為 Wickham and Grolemund (2016) 第 7 章內容。 本部分（第 11、12、13、14、15、16、17 章）要談的是資料整理（data wrangling）。 Figure 11.1: Data wrangling. 11.1 創建 Tibbles 11.1.1 把 Data Frames 轉換 Tibbles Tibbles 也是一種 data frames。要把 data frames 轉換成 tibbles 很簡單，只要使用 as_tibble() 函數即可，如： as_tibble(iris) ## # A tibble: 150 × 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa ## 7 4.6 3.4 1.4 0.3 setosa ## 8 5 3.4 1.5 0.2 setosa ## 9 4.4 2.9 1.4 0.2 setosa ## 10 4.9 3.1 1.5 0.1 setosa ## # … with 140 more rows 11.1.2 透過向量創建 Tibbles 我們也可以透過向量來創建 tibbles，如： tibble( x = 1 : 5, y = 1, z = x ^ 2 + y ) ## # A tibble: 5 × 3 ## x y z ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1 2 ## 2 2 1 5 ## 3 3 1 10 ## 4 4 1 17 ## 5 5 1 26 Tibbles 的 column 還可以取名為本來在 base R 的語法中不合法的變數名稱，即 nonsynaptic names，例如非字母開頭或者有特殊字元或空格，只要用兩個 \\ 包圍即可，而要使用這些變數的話同樣要以 \\ 來包圍，如： tibble( ` ` = 1 : 3, `:)` = 1, `2049` = ` ` ^ 2 + `:)` ) ## # A tibble: 3 × 3 ## ` ` `:)` `2049` ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1 2 ## 2 2 1 5 ## 3 3 1 10 11.1.3 以 Transposed Tibble tribble() 創建 Tibbles 我們也可以 tribble()，即 transposed tribble 來創建 tibbles。使用 tribble() 的方式如下： tribble( ~x, ~y, ~z, #--/--/---- &quot;a&quot;, 2, 3.4, &quot;s&quot;, 4, NA ) ## # A tibble: 2 × 3 ## x y z ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 a 2 3.4 ## 2 s 4 NA 事實上，#--/--/---- 並非必須的（也只是一個註解），但便於我們辨識變數與變數值。 11.2 Tibbles 與 Data Frames 的比較 11.2.1 Printing tibble( a = lubridate::now() + runif(1e3) * 86400, b = lubridate::today() + runif(1e3) * 30, c = 1:1e3, d = runif(1e3), e = sample(letters, 1e3, replace = TRUE) ) ## # A tibble: 1,000 × 5 ## a b c d e ## &lt;dttm&gt; &lt;date&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2022-04-17 05:22:51 2022-05-04 1 0.703 n ## 2 2022-04-17 06:28:48 2022-05-10 2 0.846 f ## 3 2022-04-17 12:17:43 2022-04-26 3 0.811 h ## 4 2022-04-17 02:09:19 2022-05-09 4 0.586 m ## 5 2022-04-17 10:39:25 2022-04-16 5 0.578 d ## 6 2022-04-16 22:19:53 2022-04-30 6 0.768 v ## 7 2022-04-17 00:05:50 2022-05-04 7 0.497 o ## 8 2022-04-17 07:43:37 2022-05-10 8 0.109 o ## 9 2022-04-16 22:21:32 2022-04-23 9 0.360 o ## 10 2022-04-17 02:34:16 2022-05-15 10 0.134 b ## # … with 990 more rows 印出 tibbles 時，預設只會印出前 10 個 rows，而每個 column 之下都會印出其型態。 那如果我們想要同時看到更多觀察值怎麼辦？有以下幾種做法： 使用 print()，決定要印出多少 rows 與 columns；其中，n = 2 代表印出 2 個 rows，而 width = Inf 代表印出所有 columns，如： nycflights13::flights %&gt;% print(n = 2, width = Inf) ## # A tibble: 336,776 × 19 ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 819 ## 2 2013 1 1 533 529 4 850 830 ## arr_delay carrier flight tailnum origin dest air_time distance hour minute ## &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 11 UA 1545 N14228 EWR IAH 227 1400 5 15 ## 2 20 UA 1714 N24211 LGA IAH 227 1416 5 29 ## time_hour ## &lt;dttm&gt; ## 1 2013-01-01 05:00:00 ## 2 2013-01-01 05:00:00 ## # … with 336,774 more rows 或者使用 options(tibble.print_max = n, tibble.print_min = m)：如果有超過 m 個 rows，則只印出 n 個 rows。所以如果 tibble.print_min 設置為 Inf 則會印出所有的 rows；而 options(tibble.width = Inf) 會印出所有的 columns。 使用 View()，最容易閱讀的方式。 11.2.2 Subsetting 如果我們要取出 tibble 的某個變數，我們需要使用 $ 與 [[，前者可以使我們取出指定的變數名稱的變數；後者除了可以使我們取出指定的變數名稱的變數以外，還能取出指定位置的變數，如新增一個 tibble： df &lt;- tibble( x = runif(5), # x 為均勻分配的 5 個數字 y = rnorm(5) # y 為常態分配的 5 個數字 ) # Extract by name df$x # [1] 0.1552525 0.2570212 0.2929349 0.7355940 0.3282747 df[[&quot;x&quot;]] # [1] 0.1552525 0.2570212 0.2929349 0.7355940 0.3282747 # Extract by position df[[1]] # [1] 0.1552525 0.2570212 0.2929349 0.7355940 0.3282747 想要在此時使用 pipe 的話要記得加上 .，如： df %&gt;% .$x # [1] 0.1552525 0.2570212 0.2929349 0.7355940 0.3282747 df %&gt;% .[[&quot;x&quot;]] # [1] 0.1552525 0.2570212 0.2929349 0.7355940 0.3282747 11.3 古老的程式碼 有些古老的函數無法使用 tibble，這時候我們需要使用 as.data.frame() 將 tibble 轉換回 data frame。如果 tibble 不相容於某古老的函數，那很有可能是因為 [（即 subsetting）的函數。在 tidyverse 中，多半可以不用 [，而透過 dplyr::filter() 與 dplyr::select() 來達到類似的結果。此外，在 base R 中，使用 [ 有時候會回傳一個 data frame，而有時會回傳一個向量；不過在 tibbles 中，使用 [ 都會回傳 tibble。 參考文獻 "],["readr.html", "12 以 readr 匯入資料 12.1 簡介 12.2 Parsing a Vector 12.3 Parsing a File 12.4 寫入檔案 12.5 其他類型的資料", " 12 以 readr 匯入資料 本章為 Wickham and Grolemund (2016) 第 7 章內容。 需要的套件 library(tidyverse) library(readr) 12.1 簡介 本章要使用 tidyverse 中的 readr 來匯入資料。使用 read_csv() 可以匯入 .csv 檔，或是直接匯入 inline 的 csv 檔，如： read_csv(&quot;a,b,c 1,2,3 4,5,6&quot;) ## # A tibble: 2 × 3 ## a b c ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 2 3 ## 2 4 5 6 要注意的是，read_csv 會把第一行的資料當成 column 的名稱，所以我們可以看到上面的 tibble 中，column 的名稱分別是 a、b 與 c。如果我們不想要這樣的話，可以透過幾種方式： 如果情況是檔案的前幾行不希望匯入的話，可以透過引數 skip = n，而或者指定 comment = \"#\" 直接註解掉，如： read_csv(&quot;不想讀入第一行 第二行也不想 x,y,z 1,2,3&quot;, skip = 2) read_csv(&quot;#不想讀入第一行 #第二行也不想 x,y,z 1,2,3&quot;, comment = &quot;#&quot;) # 以上兩種做法都會得到 ## # A tibble: 1 × 3 ## x y z ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 2 3 如果是因為資料沒有 column name 的話，可以使用 col_names = FALSE，這樣 read_csv() 就不會把第一行當作是 column names，而是使用 X1、X2、⋯⋯；所以反過來說，也可以使用 col_names 來指定 column names，如： read_csv(&quot;1,2,3\\n4,5,6&quot;, col_names = FALSE) ## # A tibble: 2 × 3 ## X1 X2 X3 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 2 3 ## 2 4 5 6 read_csv(&quot;1,2,3\\n4,5,6&quot;, col_names = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)) ## # A tibble: 2 × 3 ## A B C ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 2 3 ## 2 4 5 6 此外，如果資料中的變數值有 NA，但以其他方式表示怎麼辦？我們可以使用引數 na 來指定資料中所用以表示缺漏值的符號，讀入時就將其轉換成 NA，如以下的資料將 NA 用 . 來表示： read_csv(&quot;a,b,c\\n1,2,.&quot;, na = &quot;.&quot;) ## # A tibble: 1 x 3 ## a b c ## &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; ## 1 1 2 NA 12.1.1 與 base R 比較 為何不用 base R 的 read.csv()？ readr 中的 read_csv() 速度快上 10 倍。單純追求速度的話可以使用 data.table 套件（可見節 4.1），速度更快，但跟 tidyverse 就有一點點不搭。 直接讀入成為 tibbles、不會把 character vectors 轉成 factors、不會使用 row names、不會破壞 column names。 更可複製（reproducible）。 12.2 Parsing a Vector parse_*() 函數可以幫助我們把字母向量轉成特定型態的向量，如 logical、integer 或 date，其中，第一個引數為要 parse 的字母向量： str(parse_logical(c(&quot;TRUE&quot;, &quot;FALSE&quot;, &quot;NA&quot;))) # logi [1:3] TRUE FALSE NA str(parse_integer(c(&quot;3&quot;, &quot;5&quot;, &quot;6&quot;))) # int [1:3] 3 5 6 str(parse_date(c(&quot;2020-11-03&quot;, &quot;2000-04-23&quot;))) # Date[1:2], format: &quot;2020-11-03&quot; &quot;2000-04-23&quot; # 注意：date 預設格式為 yyyy-mm-dd # 也可以使用 na = parse_integer(c(&quot;1&quot;, &quot;231&quot;, &quot;.&quot;, &quot;456&quot;), na = &quot;.&quot;) # [1] 1 231 NA 456 # 當然，如果輸入錯的格式就會得到 warning 如果有 parsing failures，我們可以透過 problem() 來檢視出問題的地方。 常用的 parse_*() 如下： parse_logical()：用來 parse logical。 parse_integer()、parse_double() 與 parse_number()：看似類似，實則大相徑庭。parse_integer() 已經示範過了，即用來 parse 整數；parse_double() 用來 parse 實數；parse_number() 則會丟掉數字前後的非數字字元，如 $1000 就會變成 1000，euro1,000 就會變成 1000，詳細的使用方法與範例可以參見節 12.2.1 或 Parse numbers, flexibly。 parse_chracter()：看似非必要，卻還是有其用處，見節 12.2.2。 parse_factor()：用來 parse factors，見節 12.2.3。 parse_date()、parse_datetime() 與 parse_time()：用來 parse 日期時間，見節 12.2.4。 12.2.1 Numbers 之所以 parse 數字會成為問題，是因為數字有非常多種不同的寫法。readr 為了解決這個問題，有引數 locale，可以用來指定 parsing options。 12.2.1.1 小數點 一般而言，我們熟知的小數點是 .，但也是有人會寫成 ,。parse_double() 中，預設就是 .，但如果是 , 或其他符號怎麼辦？要處理這個問題，我們可以在 locale 的設定中，使用引數 decimal_mark，如： parse_double(&quot;1.23&quot;) # [1] 1.23 parse_double(&quot;1,23&quot;, locale = locale(decimal_mark = &quot;,&quot;)) # # [1] 1.23 12.2.1.2 數字前後有非數字的字母 有時候，數字前後就是有非數字的字母，例如 $1000 或 20% 或 1,300，那怎麼辦？我們可以改用 parse_number()。此外，美國通常以 , 作為 grouping mark，像是 20000 會寫成 20,000；但歐洲各國並不一定，因此我們也可以在 locale 中設置引數 grouping_mark，如： parse_number(&quot;20,044,620&quot;) # [1] 20044620 parse_number(&quot;20%&quot;) # [1] 20 parse_number(&quot;#20&quot;) # [1] 20 parse_number(&quot;It costs $817.&quot;) # [1] 817 parse_number(&quot;552.255.123&quot;, locale = locale(grouping_mark = &quot;.&quot;)) # [1] 552255123 parse_number(&quot;552&#39;255&#39;123&quot;, locale = locale(grouping_mark = &quot;&#39;&quot;)) # [1] 552255123 parse_number(&quot;33.457,32&quot;, locale = locale(decimal_mark = &quot;,&quot;, grouping_mark = &quot;.&quot;)) # [1] 33457.32 12.2.2 Strings 貌似無用的函數，其實不然。問題在，同樣的字串也有許多種不同的表示方式。例如我們使用 chatToRaw() 函數，如： charToRaw(&quot;Politics&quot;) # [1] 50 6f 6c 69 74 69 63 73 這種編碼（encoding）方式即 ASCII，每 byte 的資訊，都會被表成十六進位的數字，如 50 即 P、6f 即 o 等。ASCII 用來表示英文字母是不錯，但問題在對其他的語言顯然力不從心。 今日，多數的編碼方式都是 UTF-8，可以表示各種語言，甚至表情符號。因此，readr 也是使用 UTF-8，即假設資料是以 UTF-8 的方式來編碼。可是又會反過來遇到一個問題，即如果我們的資料是由古老的電腦系統所生成，並非以 UTF-8 來編碼的話，那怎麼辦？ 這時候 parse_character() 就派上用場了。我們可以在引數 locale 中指定編碼的格式，如： parse_character(&quot;El Ni\\xf1o was particularly bad this year&quot;, locale = locale(encoding = &quot;Latin1&quot;)) # [1] &quot;El Niño was particularly bad this year&quot; 下一個問題又來了：如果我們不知道它的編碼格式，那怎麼辦？我們可以使用 guess_encoding() 函數。當然文字數量多的時候它會猜得比較準，但現在這裡就是一個範例。 guess_encoding(charToRaw(&quot;El Ni\\xf1o was particularly bad this year&quot;)) ## # A tibble: 2 × 2 ## encoding confidence ## &lt;chr&gt; &lt;dbl&gt; ## 1 ISO-8859-1 0.46 ## 2 ISO-8859-9 0.23 其他關於編碼的問題，詳情可見 What Every Programmer Absolutely, Positively Needs To Know About Encodings And Character Sets To Work With Text。 12.2.3 Factors 以 parse_factor() 搭配 levels 可以解析 factors，如： fruit &lt;- c(&quot;apple&quot;, &quot;banana&quot;) parse_factor(c(&quot;apple&quot;, &quot;banana&quot;), levels = fruit) ## [1] apple banana ## Levels: apple banana 如果輸入非預期的值會得到 warning（factors 必須是已知變數值的類別變數），如： fruit &lt;- c(&quot;apple&quot;, &quot;banana&quot;) parse_factor(c(&quot;apple&quot;, &quot;banana&quot;, &quot;bannn&quot;), levels = fruit) ## Warning: 1 parsing failure. ## row col expected actual ## 3 -- value in level set bannn ## [1] apple banana &lt;NA&gt; ## attr(,&quot;problems&quot;) ## # A tibble: 1 × 4 ## row col expected actual ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 3 NA value in level set bannn ## Levels: apple banana 12.2.4 Dates, Date-Times, and Times 關於日期與時間，有三種 parser： parse_datetime()：要輸入 ISO8601 的 date-time，即依序輸入年、月、日、時、分、秒（可參照維基百科說明），如： parse_datetime(&quot;20201223&quot;) # [1] &quot;2020-12-23 UTC&quot; # 如果沒有輸入時間的話就會被設置為午夜 parse_datetime(&quot;2020-03-14&quot;) # [1] &quot;2020-03-14 UTC&quot; parse_datetime(&quot;2021-09-01T14:17:28&quot;) # [1] &quot;2021-09-01 14:17:28 UTC&quot; parse_date()：輸入年、月、日，中間以 - 或 / 隔開，如： parse_date(&quot;2021-04-23&quot;) # [1] &quot;2021-04-23&quot; parse_date(&quot;2021/08/15&quot;) # [1] &quot;2021-08-15&quot; parse_time()：輸入時、分、秒、am 或 pm（後兩者為選擇性的），前三者之間以冒號隔開，時間與上下午之間以空格隔開，如： library(hms) parse_time(&quot;01:23&quot;) # 01:23:00 parse_time(&quot;02:24:25&quot;) # 02:24:25 parse_time(&quot;03:23:56 pm&quot;) # 15:23:56 自訂年月日時間的格式方式如下。 Year %Y (4 digits). %y (2 digits; 00-69 → 2000-2069, 70-99 → 1970-1999). Month %m (2 digits). %b (abbreviated name, like “Jan”). %B (full name, “January”). Day %d (2 digits). %e (optional leading space). Time %H (0–23 hour format). %I (0–12, must be used with %p). %p (a.m./p.m. indicator). %M (minutes). %S (integer seconds). %OS (real seconds). %Z (time zone [a name, e.g., America/Chicago]). %z (as offset from UTC, e.g., +0800). Nondigits %. (skips one nondigit character). %* (skips any number of nondigits). parse_date(&quot;01/02/15&quot;, &quot;%m/%d/%y&quot;) # [1] &quot;2015-01-02&quot; parse_date(&quot;01/02/15&quot;, &quot;%d/%m/%y&quot;) # [1] &quot;2015-02-01&quot; parse_date(&quot;01/02/15&quot;, &quot;%y/%m/%d&quot;) # [1] &quot;2001-02-15&quot; 12.3 Parsing a File 所以 readr 到底怎麼解析檔案？它如何猜測各個 column 的型態？如果 readr 所猜測的並非我們所要的，那該怎麼辦？ 12.3.1 策略 readr 的方式是先讀入前 1000 列的資料，並運用捷思來猜測各行的型態。我們可以使用 guess_parser() 來模擬 readr 的猜測過程，其將會回傳 readr 的猜測；而使用 parse_guess() 可以解析向量，如： guess_parser(&quot;2021-09-22&quot;) # [1] &quot;date&quot; guess_parser(&quot;04:23&quot;) # [1] &quot;time&quot; guess_parser(&quot;2021-04-12T04:12&quot;) # [1] &quot;datetime&quot; guess_parser(c(TRUE, NA)) # [1] &quot;logical&quot; guess_parser(c(&quot;TRUE&quot;, NA)) # [1] &quot;logical&quot; guess_parser(c(2, 4.5, 6)) # [1] &quot;double&quot; str(parse_guess(&quot;2021-04-12&quot;)) # Date[1:1], format: &quot;2021-04-12&quot; 詳細而言，捷思法就如： logical：只包含 “F”、“T”、“FALSE” 或 “TRUE”。 integer：只包含數字與 -。 double：只包含合法的 doubles。 number：包含有 grouping mark 的合法 doubles。 time：包含預設的時間格式。 date：包含預設的日期格式。 date-time：包含 ISO8601 格式者。 如果都不滿足，那就還是會是字串向量。 12.3.2 問題 問題在於如果檔案很大，那這招是行不通的： 前 1000 列可能只是特例。 如果有太多缺漏值，readr 會把它猜成字元向量，但也許應該是別的型態。 以下有一個出問題的範例： challenge &lt;- read_csv(readr_example(&quot;challenge.csv&quot;)) ## Rows: 2000 Columns: 2 ## ── Column specification ──────────────────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## dbl (1): x ## date (1): y ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. problems(challenge) ## # A tibble: 0 × 5 ## # … with 5 variables: row &lt;int&gt;, col &lt;int&gt;, expected &lt;chr&gt;, actual &lt;chr&gt;, ## # file &lt;chr&gt; 此時，我們應該是逐行檢視應該如何解析，其中 col_type 即告訴 R 要載入什麼類型的資料，如： challenge &lt;- read_csv( readr_example(&quot;challenge.csv&quot;), col_types = cols( x = col_integer(), y = col_character() ) ) 看起來解決了前幾列的問題，但我們用 tail() 一看就知道 x 最後面幾列都是 doubles，且 y 最後面幾列都是日期，所以應該改成： challenge &lt;- read_csv( readr_example(&quot;challenge.csv&quot;), col_types = cols( x = col_double(), y = col_date() ) ) 12.3.3 其他策略 我們也可以改變 readr 要一開始要檢查的列數，如： challenge2 &lt;- read_csv( readr_example(&quot;challenge.csv&quot;), guess_max = 1001 ) ## Rows: 2000 Columns: 2 ## ── Column specification ──────────────────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## dbl (1): x ## date (1): y ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. 全部都先讀取成字元向量，有時候也很便於診斷出問題出在哪，如： challenge2 &lt;- read_csv(readr_example(&quot;challenge.csv&quot;), col_types = cols(.default = col_character()) ) 然後我們也可以配合使用 type_convert()，如： type_convert(challenge2) ## ## ── Column specification ──────────────────────────────────────────────────────── ## cols( ## x = col_double(), ## y = col_date(format = &quot;&quot;) ## ) ## # A tibble: 2,000 × 2 ## x y ## &lt;dbl&gt; &lt;date&gt; ## 1 404 NA ## 2 4172 NA ## 3 3004 NA ## 4 787 NA ## 5 37 NA ## 6 2332 NA ## 7 2489 NA ## 8 1449 NA ## 9 3665 NA ## 10 3863 NA ## # … with 1,990 more rows 如果有很嚴重的解析問題，可以先以 read_lines 讀字元向量進來，甚至以 read_file() 讀長度為 1 的字元向量進來，再使用其他解析字串的技巧解決這個問題。 12.4 寫入檔案 readr 提供了兩個函數可以幫助我們把資料寫入磁碟：write_csv() 與 write_tsv()。兩個函數所輸出的檔案都會以 UTF-8 編碼，且日期時間會以 ISO8601 格式，如： write_csv(challenge, &quot;challenge.csv&quot;) 想要輸出成 Excel 格式，則可以使用 write_excel_csv()。 不過以上這種做法就有一個風險：要重新讀入檔案時還要重新煩惱解析的問題。 12.5 其他類型的資料 表格類型的資料可以使用： haven：用於讀取 SPSS、Stata 與 SAS 檔。 readxl：用以讀取 Excel 檔（.xls 與 .xlsx 檔）。 DBI：與 RMySQL、RSQLite 或 RPostgreSQL 配合使用，可以跑 SQL queries，然後從資料庫回傳一個 data frame。 階層資料（hierarchical data）可以使用： jsonlite：用以讀取 JSON 檔。 xml2：用以讀取 XML 檔。 其他類型的檔案，可以參考 R Data Import/Export 或 rio。 參考文獻 "],["tidyr.html", "13 以 tidyr 整理資料 13.1 Tidy Data 13.2 Spreading and Gathering 13.3 Separating and Pull 13.4 Missing Values", " 13 以 tidyr 整理資料 本章為 Wickham and Grolemund (2016) 第 9 章內容。另外可參見 Wickham (2014) 作為本章補充。 Happy families are all alike; every unhappy family is unhappy in its own way. — Leo Tolstoy Tidy datasets are all alike, but every messy dataset is messy in its own way. — Hadley Wickham 需要的套件 library(tidyverse) 13.1 Tidy Data 一筆整潔的資料有三個彼此相關的規則： 每個變數都自成一行。 每個觀察值都自成一列。 每個變數值都自成一格。 因此，我們要做的事情就是： 把每筆資料都放在一個 tibble 中。 把每個變數都放在一行中。 以下有五筆資料，每筆都是相同的，但是只有 table1 是整潔的（tidy）的： table1 ## # A tibble: 6 × 4 ## country year cases population ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 table2 ## # A tibble: 12 × 4 ## country year type count ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 1999 cases 745 ## 2 Afghanistan 1999 population 19987071 ## 3 Afghanistan 2000 cases 2666 ## 4 Afghanistan 2000 population 20595360 ## 5 Brazil 1999 cases 37737 ## 6 Brazil 1999 population 172006362 ## 7 Brazil 2000 cases 80488 ## 8 Brazil 2000 population 174504898 ## 9 China 1999 cases 212258 ## 10 China 1999 population 1272915272 ## 11 China 2000 cases 213766 ## 12 China 2000 population 1280428583 table3 ## # A tibble: 6 × 3 ## country year rate ## * &lt;chr&gt; &lt;int&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745/19987071 ## 2 Afghanistan 2000 2666/20595360 ## 3 Brazil 1999 37737/172006362 ## 4 Brazil 2000 80488/174504898 ## 5 China 1999 212258/1272915272 ## 6 China 2000 213766/1280428583 table4a ## # A tibble: 3 × 3 ## country `1999` `2000` ## * &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 745 2666 ## 2 Brazil 37737 80488 ## 3 China 212258 213766 table4b ## # A tibble: 3 × 3 ## country `1999` `2000` ## * &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 19987071 20595360 ## 2 Brazil 172006362 174504898 ## 3 China 1272915272 1280428583 事實上，因為 dplyr 與 ggplot2，以及所有 tidyverse 的套件，甚至是多數的 R 套件都是為 tidy data 所設計，因此這個環節至關重要。 不過，有時候 nontidy data 也有其用處。例如可能效能較好，或佔據的空間更小；或者某些專業領域有其儲存資料的特殊傳統。詳情可以參見 Non-tidy data。 13.2 Spreading and Gathering 不整潔的資料，有兩類常見的問題： 一個變數存在多行中。 一個觀察值分散在好幾列中。 想要解決這兩種問題，我們可以使用 tidyr 所提供的 gather() 與 spread() 函數。 13.2.1 Gathering 以剛剛展示過的 table4a 而言，它行的名稱不是變數的名稱： table4a ## # A tibble: 3 × 3 ## country `1999` `2000` ## * &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 745 2666 ## 2 Brazil 37737 80488 ## 3 China 212258 213766 要整理這批資料，我們需要三種參數： 應該要是變數值而不是變數的行，即 1999 和 2000。 其值原本是行的名稱的新變數名稱，這裡將有變數值為 1999 和 2000 的變數稱為 year，搭配引數 key。 其值原本散落在格子內的新變數名稱，這裡稱呼為 cases，搭配引數 value。 所以，我們可以如此整理 table4a： table4a %&gt;% gather(`1999`, `2000`, key = &quot;year&quot;, value = &quot;cases&quot;) ## # A tibble: 6 × 3 ## country year cases ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 ## 2 Brazil 1999 37737 ## 3 China 1999 212258 ## 4 Afghanistan 2000 2666 ## 5 Brazil 2000 80488 ## 6 China 2000 213766 Figure 13.1: gather() 的運作方式。 我們可以依樣畫葫蘆地整理 table4b： table4b %&gt;% gather(`1999`, `2000`, key = &quot;year&quot;, value = &quot;population&quot;) ## # A tibble: 6 × 3 ## country year population ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 1999 19987071 ## 2 Brazil 1999 172006362 ## 3 China 1999 1272915272 ## 4 Afghanistan 2000 20595360 ## 5 Brazil 2000 174504898 ## 6 China 2000 1280428583 接下來，我們可以利用第 14 章會學到的 dplyr::left_join() 來合併這兩者： tidy4a &lt;- table4a %&gt;% gather(`1999`, `2000`, key = &quot;year&quot;, value = &quot;cases&quot;) tidy4b &lt;- table4b %&gt;% gather(`1999`, `2000`, key = &quot;year&quot;, value = &quot;population&quot;) left_join(tidy4a, tidy4b) ## # A tibble: 6 × 4 ## country year cases population ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Brazil 1999 37737 172006362 ## 3 China 1999 212258 1272915272 ## 4 Afghanistan 2000 2666 20595360 ## 5 Brazil 2000 80488 174504898 ## 6 China 2000 213766 1280428583 13.2.2 Spreading Spreading 與 gathering 恰好相反，所要處理的問題是觀察值分散在不同列裏，table2 就有這樣的問題： table2 ## # A tibble: 12 × 4 ## country year type count ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 1999 cases 745 ## 2 Afghanistan 1999 population 19987071 ## 3 Afghanistan 2000 cases 2666 ## 4 Afghanistan 2000 population 20595360 ## 5 Brazil 1999 cases 37737 ## 6 Brazil 1999 population 172006362 ## 7 Brazil 2000 cases 80488 ## 8 Brazil 2000 population 174504898 ## 9 China 1999 cases 212258 ## 10 China 1999 population 1272915272 ## 11 China 2000 cases 213766 ## 12 China 2000 population 1280428583 要處理這種問題，我們需要兩種參數： 包含變數名稱的行，此處即 type，搭配引數 key。 包含組成多個變數的變數值的行，此處即 count，搭配引數 value。 table2 %&gt;% spread(key = type, value = count) ## # A tibble: 6 × 4 ## country year cases population ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 Figure 13.2: spread() 的運作方式。 13.3 Separating and Pull 另外兩種問題是一行中有多個變數與一個變數分散在多行，我們可以使用 separate() 與 unite() 來解決這兩種問題。 13.3.1 Seperate table3 的問題就在有一行 rate，事實上裝了兩個變數： table3 ## # A tibble: 6 × 3 ## country year rate ## * &lt;chr&gt; &lt;int&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745/19987071 ## 2 Afghanistan 2000 2666/20595360 ## 3 Brazil 1999 37737/172006362 ## 4 Brazil 2000 80488/174504898 ## 5 China 1999 212258/1272915272 ## 6 China 2000 213766/1280428583 只要有分隔字元的話，seperate 可以把一行拉成兩行，如： table3 %&gt;% separate(rate, into = c(&quot;cases&quot;, &quot;population&quot;)) ## # A tibble: 6 × 4 ## country year cases population ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 Figure 13.3: separate() 的運作方式。 separate() 預設會將非數字或字母的字元當成分隔字元，然後拆開。不過，如果有特殊的需求，我們也可以引數 sep 來手動指定分隔符號，如： table3 %&gt;% separate(rate, into = c(&quot;cases&quot;, &quot;population&quot;), sep = &quot;/&quot;) sep 引數也不見得要丟入符號。我們可以在 sep 丟入數字，正值代表從字串左邊數來第 \\(n\\) 個處分隔，負值則為從右邊數來第 \\(n\\) 個處分隔，如： table3 %&gt;% separate(year, into = c(&quot;century&quot;, &quot;year&quot;), sep = 2) ## # A tibble: 6 × 4 ## country century year rate ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 19 99 745/19987071 ## 2 Afghanistan 20 00 2666/20595360 ## 3 Brazil 19 99 37737/172006362 ## 4 Brazil 20 00 80488/174504898 ## 5 China 19 99 212258/1272915272 ## 6 China 20 00 213766/1280428583 不過，事情還沒有結束。注意到上面的 cases 與 population，本應是數字，卻被記為字元。我們可以使用引數 convert 解決此問題： table3 %&gt;% separate( rate, into = c(&quot;cases&quot;, &quot;population&quot;), convert = TRUE ) ## # A tibble: 6 × 4 ## country year cases population ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 13.3.2 Unite unite() 與 separate() 恰好相反，即把數行合併成一行。我們可以把 table5 的 century 與 year 兩行合併成 new，其中還可以加上引數 sep，因為 unite() 合併時預設會加入 _，因此我們必須設置為 sep = \"\"，如： table5 ## # A tibble: 6 × 4 ## country century year rate ## * &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 19 99 745/19987071 ## 2 Afghanistan 20 00 2666/20595360 ## 3 Brazil 19 99 37737/172006362 ## 4 Brazil 20 00 80488/174504898 ## 5 China 19 99 212258/1272915272 ## 6 China 20 00 213766/1280428583 table5 %&gt;% unite(new, century, year, sep = &quot;&quot;) ## # A tibble: 6 × 3 ## country new rate ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745/19987071 ## 2 Afghanistan 2000 2666/20595360 ## 3 Brazil 1999 37737/172006362 ## 4 Brazil 2000 80488/174504898 ## 5 China 1999 212258/1272915272 ## 6 China 2000 213766/1280428583 Figure 13.4: unite() 的運作方式。 13.4 Missing Values 資料裡的缺漏值有兩種呈現形式： Explicit. 以 NA 表示。 Implicit. 單純地沒有紀錄變數值。 stocks &lt;- tibble( year = c(2015, 2015, 2015, 2015, 2016, 2016, 2016), qtr = c( 1, 2, 3, 4, 2, 3, 4), return = c(1.88, 0.59, 0.35, NA, 0.92, 0.17, 2.66)) 在以上的資料中，有兩個缺漏值： 2015 年的第四季的報酬為 NA（explicit）。 少了 2016 年第一季的資料（implicit）。 13.4.1 讓潛藏的缺漏值顯露出來 要如何讓潛藏的缺漏值顯露出來呢？ 使用 spread() 把 year 放到 column 去，再使用 gather() 把行的名稱變成變數的名稱，如： stocks %&gt;% spread(year, return) %&gt;% gather(year, return, `2015`:`2016`, na.rm = FALSE) ## # A tibble: 8 × 3 ## qtr year return ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 2015 1.88 ## 2 2 2015 0.59 ## 3 3 2015 0.35 ## 4 4 2015 NA ## 5 1 2016 NA ## 6 2 2016 0.92 ## 7 3 2016 0.17 ## 8 4 2016 2.66 使用 complete()，如： stocks %&gt;% complete(year, qtr) ## # A tibble: 8 × 3 ## year qtr return ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2015 1 1.88 ## 2 2015 2 0.59 ## 3 2015 3 0.35 ## 4 2015 4 NA ## 5 2016 1 NA ## 6 2016 2 0.92 ## 7 2016 3 0.17 ## 8 2016 4 2.66 13.4.2 自動填入 treatment &lt;- tribble( ~ person, ~ treatment, ~response, &quot;Derrick Whitmore&quot;, 1, 7, NA, 2, 10, NA, 3, 9, &quot;Katherine Burke&quot;, 1, 4 ) 使用 fill() 會自動填入最常見的非缺漏值： treatment %&gt;% fill(person) ## # A tibble: 4 × 3 ## person treatment response ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Derrick Whitmore 1 7 ## 2 Derrick Whitmore 2 10 ## 3 Derrick Whitmore 3 9 ## 4 Katherine Burke 1 4 參考文獻 "],["dplyr2.html", "14 以 dplyr 處理關聯性資料 14.1 nycflights13 14.2 Keys 14.3 Mutating Joins 14.4 Filtering joins 14.5 Join Problems 14.6 Set operations", " 14 以 dplyr 處理關聯性資料 本章為 Wickham and Grolemund (2016) 第 10 章內容。第 9 章介紹了 dplyr 基本的操作，本章則要再延伸，介紹如何以 dplyr 處理關聯性資料（relational data）。一筆資料可能由好幾個表格組成，之所以被稱為關聯性資料，即每一對表格之間定義了關係（relations） 本章尚未完成。 需要的套件 library(tidyverse) library(nycflights13) 以 dplyr 處理關聯性資料有以下幾種操作： Mutating joins: 從另一個表格所配對的觀察值添加新的變數到表格。 Filtering joins: 依據觀察值是否能配對到另一個表格來篩選觀察值。 Set operations: 把觀察值當作集合元素一般運算。 事實上，也有專門處理關聯性資料的關聯性資料庫管理系統（relational database management system, RDBMS），SQL 即一種關聯性資料庫語言。儘管 SQL 有更多功能，但 dplyr 在處理用以資料分析的關聯性資料時會方便於 SQL。 14.1 nycflights13 nycflights13 包含了與 flights 關聯的四個 tibbles，如圖 14.1 與如下： airlines：所有航空公司及其縮寫。 airlines ## # A tibble: 16 × 2 ## carrier name ## &lt;chr&gt; &lt;chr&gt; ## 1 9E Endeavor Air Inc. ## 2 AA American Airlines Inc. ## 3 AS Alaska Airlines Inc. ## 4 B6 JetBlue Airways ## 5 DL Delta Air Lines Inc. ## 6 EV ExpressJet Airlines Inc. ## 7 F9 Frontier Airlines Inc. ## 8 FL AirTran Airways Corporation ## 9 HA Hawaiian Airlines Inc. ## 10 MQ Envoy Air ## 11 OO SkyWest Airlines Inc. ## 12 UA United Air Lines Inc. ## 13 US US Airways Inc. ## 14 VX Virgin America ## 15 WN Southwest Airlines Co. ## 16 YV Mesa Airlines Inc. airports：所有機場及其地點與縮寫。 airports ## # A tibble: 1,458 × 8 ## faa name lat lon alt tz dst tzone ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 04G Lansdowne Airport 41.1 -80.6 1044 -5 A America/… ## 2 06A Moton Field Municipal Airport 32.5 -85.7 264 -6 A America/… ## 3 06C Schaumburg Regional 42.0 -88.1 801 -6 A America/… ## 4 06N Randall Airport 41.4 -74.4 523 -5 A America/… ## 5 09J Jekyll Island Airport 31.1 -81.4 11 -5 A America/… ## 6 0A9 Elizabethton Municipal Airport 36.4 -82.2 1593 -5 A America/… ## 7 0G6 Williams County Airport 41.5 -84.5 730 -5 A America/… ## 8 0G7 Finger Lakes Regional Airport 42.9 -76.8 492 -5 A America/… ## 9 0P2 Shoestring Aviation Airfield 39.8 -76.6 1000 -5 U America/… ## 10 0S9 Jefferson County Intl 48.1 -123. 108 -8 A America/… ## # … with 1,448 more rows planes：所有飛機與其代號。 planes ## # A tibble: 3,322 × 9 ## tailnum year type manufacturer model engines seats speed engine ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; ## 1 N10156 2004 Fixed wing m… EMBRAER EMB-1… 2 55 NA Turbo-… ## 2 N102UW 1998 Fixed wing m… AIRBUS INDUST… A320-… 2 182 NA Turbo-… ## 3 N103US 1999 Fixed wing m… AIRBUS INDUST… A320-… 2 182 NA Turbo-… ## 4 N104UW 1999 Fixed wing m… AIRBUS INDUST… A320-… 2 182 NA Turbo-… ## 5 N10575 2002 Fixed wing m… EMBRAER EMB-1… 2 55 NA Turbo-… ## 6 N105UW 1999 Fixed wing m… AIRBUS INDUST… A320-… 2 182 NA Turbo-… ## 7 N107US 1999 Fixed wing m… AIRBUS INDUST… A320-… 2 182 NA Turbo-… ## 8 N108UW 1999 Fixed wing m… AIRBUS INDUST… A320-… 2 182 NA Turbo-… ## 9 N109UW 1999 Fixed wing m… AIRBUS INDUST… A320-… 2 182 NA Turbo-… ## 10 N110UW 1999 Fixed wing m… AIRBUS INDUST… A320-… 2 182 NA Turbo-… ## # … with 3,312 more rows weather：NYC 每小時的天氣。 weather ## # A tibble: 26,115 × 15 ## origin year month day hour temp dewp humid wind_dir wind_speed ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 EWR 2013 1 1 1 39.0 26.1 59.4 270 10.4 ## 2 EWR 2013 1 1 2 39.0 27.0 61.6 250 8.06 ## 3 EWR 2013 1 1 3 39.0 28.0 64.4 240 11.5 ## 4 EWR 2013 1 1 4 39.9 28.0 62.2 250 12.7 ## 5 EWR 2013 1 1 5 39.0 28.0 64.4 260 12.7 ## 6 EWR 2013 1 1 6 37.9 28.0 67.2 240 11.5 ## 7 EWR 2013 1 1 7 39.0 28.0 64.4 240 15.0 ## 8 EWR 2013 1 1 8 39.9 28.0 62.2 250 10.4 ## 9 EWR 2013 1 1 9 39.9 28.0 62.2 260 15.0 ## 10 EWR 2013 1 1 10 41 28.0 59.6 260 13.8 ## # … with 26,105 more rows, and 5 more variables: wind_gust &lt;dbl&gt;, precip &lt;dbl&gt;, ## # pressure &lt;dbl&gt;, visib &lt;dbl&gt;, time_hour &lt;dttm&gt; Figure 14.1: 關聯性資料。 根據圖 14.1 可知： flights 透過變數 carrier 與 airlines 連接。 flights 透過變數 origin 及 dest 與 airports 連接。 flights 透過變數 tailnum 與 planes 連接。 flights 透過變數 origin、year、month、day 及 hour 與 weather 連接。 14.2 Keys Keys 為連接一對表格的變數。Keys 有兩種類型： Primary key: Uniquely identifies an observation in its own table. Foreign key: Uniquely identifies an observation in another table. 例如 planes$tailnum 就是 primary key；而 flights$tailnum 則是 foreign key。當然，變數可以同時是 primary key 與 foreign key；如 origin 是 weather 的 primary key，又是 airport 的 foreign key。 識別了表格中的 primary key 以後， 我們可以確認看看是否他們唯一地識別了每個觀察值。我們可以利用 count() 來計算 primary keys，然後看看 n 有沒有大於 1，如： planes %&gt;% count(tailnum) %&gt;% filter(n &gt; 1) ## # A tibble: 0 × 2 ## # … with 2 variables: tailnum &lt;chr&gt;, n &lt;int&gt; weather %&gt;% count(year, month, day, hour, origin) %&gt;% filter(n &gt; 1) ## # A tibble: 3 × 6 ## year month day hour origin n ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 2013 11 3 1 EWR 2 ## 2 2013 11 3 1 JFK 2 ## 3 2013 11 3 1 LGA 2 14.3 Mutating Joins 14.4 Filtering joins 14.5 Join Problems 14.6 Set operations 集合運算很少使用，但當我們想要把單一個複雜的 filter 拆解成多個簡單的部分時，集合運算可以幫上大忙。假設 x 與 y 有相同的變數，集合運算有三種： intersect(x, y): 回傳 x 與 y 的觀察值的交集。 union(x, y): 回傳 x 或 y 的觀察值的聯集。 setdiff(x, y): 回傳 x 的觀察值，但要扣除 y 也有的。 參考文獻 "],["stringr.html", "15 以 stringr 處理字串 15.1 String Basics 15.2 Matching Patterns with Regular Expressions 15.3 Tools 15.4 Other Types of Pattern 15.5 Other Uses of Regular Expressions 15.6 stringi", " 15 以 stringr 處理字串 本章為 Wickham and Grolemund (2016) 第 11 章內容，重點為正規表達式（regular expression）。 需要的套件 我們需要特別加載 stringr，因為它並非 tidyverse 的核心。 library(tidyverse) library(stringr) 15.1 String Basics 我們可以使用單引號 ' 或雙引號 \" 來創建字串，並無不同。不過，如果要在字串中使用單引號或雙引號，想當然就得用另一種來創建字串，如： string1 &lt;- &quot;This is a string.&quot; string2 &lt;- &#39;This is a string.&#39; string3 &lt;- &quot;This is a &#39;string.&#39;&quot; string4 &lt;- &#39;This is a &quot;string.&quot;&#39; c(string1, string2, string3, string4) ## [1] &quot;This is a string.&quot; &quot;This is a string.&quot; &quot;This is a &#39;string.&#39;&quot; ## [4] &quot;This is a \\&quot;string.\\&quot;&quot; 注意到 string4，\\ 即跳脫字元。當我們想要在字串中使用單引號或雙引號時，如果不以上面那種單雙引號的方式來區分，那就需要使用跳脫字元（如果我們需要在字串中加入 \\ 的話，則需要輸入 \\\\）。 不過，當我們直接印出字串時，就會包含跳脫字元，但這並非字串本身。如果我們想要看到字串本身，可以使用 writeLines() 函數，即： writeLines(c(string3, string4)) ## This is a &#39;string.&#39; ## This is a &quot;string.&quot; 事實上，其他特殊字元也是如此，例如 \\n 或 \\t，甚或 unicode 碼，如： writeLines(c(&quot;\\u5104&quot;, &quot;\\u32a3&quot;, &quot;\\u03A9&quot;)) ## 億 ## ㊣ ## Ω 15.1.1 String Length Base R 有一套用於字串的函數，但以下我們都會使用 stringr 所提供的函數。它們全都以 str_ 開頭。 如果我們想知道字串的長度，我們可以使用 str_length() 函數，如： str_length(c(&quot;a&quot;, &quot;R for Data Science&quot;, NA)) ## [1] 1 18 NA 15.1.2 Combining Strings 如果要合併兩個以上的字串，我們可以使用 str_c()，如： str_c(&quot;R&quot;, &quot;for&quot;, &quot;Data&quot;, &quot;Science&quot;) # [1] &quot;RforDataScience&quot; str_c(&quot;R&quot;, &quot;for&quot;, &quot;Data&quot;, &quot;Science&quot;, sep = &quot; &quot;) # [1] &quot;R for Data Science&quot; str_c(&quot;R&quot;, &quot;for&quot;, &quot;Data&quot;, &quot;Science&quot;, sep = &quot;, &quot;) # [1] &quot;R, for, Data, Science&quot; 引數除了能是字串，也能是向量，而比較短的向量的元素同 Base R 一樣，會被重新回收再利用，如： str_c(c(&quot;A&quot;, &quot;B&quot;), c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)) ## [1] &quot;Aa&quot; &quot;Bb&quot; &quot;Ac&quot; &quot;Bd&quot; str_c(c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)) ## Warning in stri_c(..., sep = sep, collapse = collapse, ignore_null = TRUE): ## longer object length is not a multiple of shorter object length ## [1] &quot;Aa&quot; &quot;Bb&quot; &quot;Cc&quot; &quot;Ad&quot; 長度是 0 的會被丟棄， 把向量轉為字串，我們可以使用引數 collapse，如： str_c(c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;), collapse = &quot;, &quot;) ## [1] &quot;x, y, z&quot; 15.1.3 Subsetting Strings 15.1.4 Locales 15.2 Matching Patterns with Regular Expressions 15.2.1 Basic Matches 15.2.2 Anchors 15.2.3 Character Classes and Alternatives 15.2.4 Repetition 15.2.5 Grouping and Backreferences 15.3 Tools 15.3.1 Detect Matches 15.3.2 Extract Matches 15.3.3 Grouped Matches 15.3.4 Replacing Matches 15.3.5 Splitting 15.3.6 Find Matches 15.4 Other Types of Pattern 15.5 Other Uses of Regular Expressions 15.6 stringi 參考文獻 "],["forcats.html", "16 以 forcats 處理 Factors", " 16 以 forcats 處理 Factors 本章為 Wickham and Grolemund (2016) 第 12 章內容。 參考文獻 "],["lubridate.html", "17 以 lubridate 處理日期時間", " 17 以 lubridate 處理日期時間 本章為 Wickham and Grolemund (2016) 第 13 章內容。 參考文獻 "],["以-magrittr-使用-pipes.html", "18 以 magrittr 使用 Pipes", " 18 以 magrittr 使用 Pipes "],["tidyfunction.html", "19 函數", " 19 函數 "],["tidyvector.html", "20 向量", " 20 向量 "],["purrr.html", "21 遞迴與 purrr", " 21 遞迴與 purrr "],["modelr.html", "22 modelr 與基礎的模型", " 22 modelr 與基礎的模型 We must be careful not to confuse data with the abstractions we use to analyze them. — William James "],["modelbuilding.html", "23 建立模型", " 23 建立模型 "],["purrrbroom.html", "24 purrr 與 broom", " 24 purrr 與 broom "],["singlereg.html", "25 單變數迴歸 25.1 解釋變數為連續變數 25.2 解釋變數為類別變數", " 25 單變數迴歸 本部分將探討社會科學計量。本章為 Ismay and Kim (2019) 第 5 章內容。 Lucky is he who has been able to understand the causes of things. — Virgil (29 BC) 需要的套件 library(tidyverse) library(moderndive) library(skimr) library(gapminder) 其中，moderndive 使用 tidyverse style 編寫，可以從事基本的線性迴歸；skimr 則可以幫助我們快速地計算敘述統計。 25.1 解釋變數為連續變數 以下，我們想了解的是老師的外貌與其教學評鑑的分數有關係嗎？是什麼關係？因此，解釋變數（explanatory variable） \\(x\\) 為老師的外貌分數，而結果變數 （outcome variable）為老師的教學評鑑分數。 25.1.1 探索性資料分析 在 moderdive 中，有一 data frame 為 evals，其包含了 UT Austin 的 463 門課程。我們使用 select() 選取我們接下來將要使用的變數，包括 ID、score 與 bty_avg，並且存在名為 evals_ch5 裡頭。 evals_ch5 &lt;- evals %&gt;% select(ID, score, bty_avg) 回憶第 10 章所提及的，當我們拿到資料要分析或建模之前，第一件事情就是進行探索性資料分析，即 EDA。EDA 讓我們了解個別變數的分配、變數之間是否有潛在的關係與是否有 outliers 或缺漏值。EDA 常見的三個步驟：5 觀察原始資料的值。 計算概括的統計量，如平均數、中位數或四分位距等。 資料視覺化。 25.1.1.1 EDA：觀察原始資料的值 我們可以使用 tibble 中的 glimpse() 查看資料，如： glimpse(evals_ch5) ## Rows: 463 ## Columns: 3 ## $ ID &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,… ## $ score &lt;dbl&gt; 4.7, 4.1, 3.9, 4.8, 4.6, 4.3, 2.8, 4.1, 3.4, 4.5, 3.8, 4.5, 4.… ## $ bty_avg &lt;dbl&gt; 5.000, 5.000, 5.000, 5.000, 3.000, 3.000, 3.000, 3.333, 3.333,… 也能使用 dplyr 中的 sample_n() 函數，隨機挑選給定數量的觀察值，如： evals_ch5 %&gt;% sample_n(size = 5) ## # A tibble: 5 × 3 ## ID score bty_avg ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 108 5 4.33 ## 2 152 3.6 4.83 ## 3 121 3.7 4.83 ## 4 137 4.7 4.17 ## 5 183 3 4.33 由上，我們可知有 463 個觀察值。其中，各個變數分別代表： ID：在這份資料中用以編號觀察值的變數。 score：連續變數；老師的平均教學評鑑分數；最高 5 分，最低 1 分；為我們所關切的結果變數 \\(y\\)。 bty_avg：連續變數；老師的平均外貌分數，最高 10 分，最低 1 分；為我們所關切的解釋變數 \\(x\\)。 25.1.1.2 EDA：簡單的敘述統計 既然 score 與 bty_avg 是連續的數值變數，那我們可以計算他們的平均值與中位數，如： evals_ch5 %&gt;% summarise(mean_score = mean(score), mean_bty_avg = mean(bty_avg), median_score = median(score), median_bty_avg = median(bty_avg)) ## # A tibble: 1 × 4 ## mean_score mean_bty_avg median_score median_bty_avg ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 4.17 4.42 4.3 4.33 不過，如果要使用 summarize 來計算標準差、極值與分量的話，並非不可，只是比較麻煩。我們可以使用套件 skimr 中的 skim() 函數。把 data frame 丟入這個函數，將會回傳常用的敘述統計量，如： evals_ch5 %&gt;% select(score, bty_avg) %&gt;% skim() ── Data Summary ──────────────────────── Values Name Piped data Number of rows 463 Number of columns 2 _______________________ Column type frequency: numeric 2 ________________________ Group variables None ── Variable type: numeric ─────────────────────────────────────────────────────────────────── skim_variable n_missing complete_rate mean sd p0 p25 p50 p75 p100 hist 1 score 0 1 4.17 0.544 2.3 3.8 4.3 4.6 5 ▁▁▅▇▇ 2 bty_avg 0 1 4.42 1.53 1.67 3.17 4.33 5.5 8.17 ▃▇▇▃▂ 其中，回傳的有： missing：缺漏值的數量。 complete：非缺漏值的數量。 n：所有值變數值的數量。 mean：平均值。 sd：標準差（standard deviation）。 p0：0th 分量，即最小值。 p25：25th 分量。 p50：50th 分量。 p75：75th 分量。 p100：100th 分量，即最大值。 不過，skim() 回傳的這些都是所謂的 univariate summary statistics。但我們還會想知道 binary summary statistics。例如，如果兩個變數都是數值變數，那我們可以計算相關係數（correlation coefficients） 。 想要計算相關係數的話，我們有兩種方式。 使用 moderndive 中的 get_correlation() 函數，使用 formula ~，把解釋變數放在 ~ 右邊，結果變數放在 ~ 左邊，如： evals_ch5 %&gt;% get_correlation(formula = score ~ bty_avg) ## # A tibble: 1 × 1 ## cor ## &lt;dbl&gt; ## 1 0.187 使用 summarize() 中的 cor 函數，如： evals_ch5 %&gt;% summarise(correlation = cor(score, bty_avg)) ## # A tibble: 1 × 1 ## correlation ## &lt;dbl&gt; ## 1 0.187 25.1.1.3 EDA：視覺化 加上 position = \"jitter\"（或者不用 geom_point()，改用 hgeom_jitter()）如同第 7 章所說的，是為了避免 overplotting 的情況。 evals_ch5 %&gt;% ggplot(aes(x = bty_avg, y = score)) + geom_point(position = &quot;jitter&quot;) + labs(x = &quot;Beauty Score&quot;, y = &quot;Teaching Score&quot;, title = &quot;Scatterplot of realtionship of traching and beauty scores&quot;) 我們也可以使用 geom_smooth(method = \"lm\")，就能以最小平方法來適配模型，並畫出迴歸線（regression line），如： evals_ch5 %&gt;% ggplot(aes(x = bty_avg, y = score)) + geom_jitter() + geom_smooth(method = &quot;lm&quot;, se = FALSE, formula = &#39;y ~ x&#39;) + labs(x = &quot;Beauty Score&quot;, y = &quot;Teaching Score&quot;, title = &quot;Relationship between teaching and beauty scores&quot;) 事實上，藍色線段的斜率恰等於上節所算出的相關係數 0.0187。不過，雖然相關係數與迴歸線的斜率的正負號通常相同，但其值通常不同。 25.1.2 簡單線性迴歸 如何進行簡單線性回歸？定義一迴歸線 \\(\\hat{y} = \\hat{b}_0 + \\hat{b}_1\\cdot x\\)，我們可以： 使用 lm() 函數適配迴歸模型，然後存在 score_model 中。 把 score_model 丟到套件 moderndive 中的 get_regression_table() 函數得到 regression table。 score_model &lt;- lm(score ~ bty_avg, data = evals_ch5) get_regression_table(score_model) ## # A tibble: 2 × 7 ## term estimate std_error statistic p_value lower_ci upper_ci ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 intercept 3.88 0.076 51.0 0 3.73 4.03 ## 2 bty_avg 0.067 0.016 4.09 0 0.035 0.099 簡而言之，我們適配出的迴歸模型即 \\[ \\begin{aligned} \\hat{y} &amp;= \\hat{b}_0 +\\hat{b}_1 \\cdot x\\\\ \\widehat{\\rm score} &amp;= 3.88 + 0.067 \\cdot {\\rm bty\\_avg} \\end{aligned} \\] 這說明了，當 bty_avg 每增加 1 單位，score 平均會增加 0.067 單位。不過要注意的是，這是相關，而不是因果；即這是 associated increase，而非 causal increase。 25.1.3 Observed/fitted values and residuals 如果我們想看個別的點的預測值與殘差呢？我們可以 get_regression_points() 來完成這件事，如： regression_points &lt;- get_regression_points(score_model) head(regression_points) ## # A tibble: 6 × 5 ## ID score bty_avg score_hat residual ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 4.7 5 4.21 0.486 ## 2 2 4.1 5 4.21 -0.114 ## 3 3 3.9 5 4.21 -0.314 ## 4 4 4.8 5 4.21 0.586 ## 5 5 4.6 3 4.08 0.52 ## 6 6 4.3 3 4.08 0.22 25.2 解釋變數為類別變數 世界上各國的預期壽命有什麼差異？各個大陸的人的預期壽命之間有何差異？同個大陸之間，預期壽命的分佈又是如何呢？ 我們可以使用套件 gapminder 中的 gapminder 這個 data frame 來嘗試回答這個問題。其中，結果變數 \\(y\\) 是國家的預期壽命，一個連續變數；解釋變數 \\(x\\) 是國家屬於哪大洲，一個類別變數。資料詳情可以參照套件說明。 25.2.1 探索性資料分析 首先載入資料。我們觀察的焦點放在 2007 年的狀況，並且我們需要 country、lifeExp、continent 的資料。 library(gapminder) gapminder2007 &lt;- gapminder %&gt;% filter(year == 2007) %&gt;% select(continent, country, lifeExp) 25.2.1.1 EDA：觀察原始資料 glimpse(gapminder2007) ## Rows: 142 ## Columns: 3 ## $ continent &lt;fct&gt; Asia, Europe, Africa, Africa, Americas, Oceania, Europe, Asi… ## $ country &lt;fct&gt; &quot;Afghanistan&quot;, &quot;Albania&quot;, &quot;Algeria&quot;, &quot;Angola&quot;, &quot;Argentina&quot;, … ## $ lifeExp &lt;dbl&gt; 43.828, 76.423, 72.301, 42.731, 75.320, 81.235, 79.829, 75.6… gapminder2007 %&gt;% sample_n(size = 5) ## # A tibble: 5 × 3 ## continent country lifeExp ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; ## 1 Americas Puerto Rico 78.7 ## 2 Europe Belgium 79.4 ## 3 Asia Kuwait 77.6 ## 4 Africa Uganda 51.5 ## 5 Africa Reunion 76.4 25.2.1.2 EDA：簡單的敘述統計 gapminder2007 %&gt;% select(lifeExp, continent) %&gt;% skim() ── Data Summary ──────────────────────── Values Name Piped data Number of rows 142 Number of columns 2 _______________________ Column type frequency: factor 1 numeric 1 ________________________ Group variables None ── Variable type: factor ─────────────────────────────────────────────────────────────────── skim_variable n_missing complete_rate ordered n_unique top_counts 1 continent 0 1 FALSE 5 Afr: 52, Asi: 33, Eur: 30, Ame: 25 ── Variable type: numeric ────────────────────────────────────────────────────────────────── skim_variable n_missing complete_rate mean sd p0 p25 p50 p75 p100 hist 1 lifeExp 0 1 67.0 12.1 39.6 57.2 71.9 76.4 82.6 ▂▃▃▆▇ 25.2.2 線性迴歸 25.2.3 Observed/fitted values and residuals 參考文獻 "],["multireg.html", "26 多變數迴歸", " 26 多變數迴歸 本章為 Ismay and Kim (2019) 第 6 章內容。 I would rather discover one true cause than gain the kingdom of Persia. — Democritus 參考文獻 "],["binomial.html", "27 二元迴歸", " 27 二元迴歸 "],["logit.html", "28 Logit Regression", " 28 Logit Regression "],["ologit.html", "29 Ordered Logit Regression", " 29 Ordered Logit Regression "],["IV.html", "30 工具變數", " 30 工具變數 "],["邊界估計.html", "31 邊界估計", " 31 邊界估計 "],["縱貫資料.html", "32 縱貫資料", " 32 縱貫資料 "],["合成控制.html", "33 合成控制", " 33 合成控制 "],["探索性因素分析.html", "34 探索性因素分析", " 34 探索性因素分析 "],["驗證性因素分析.html", "35 驗證性因素分析", " 35 驗證性因素分析 "],["html.html", "36 HTML 36.1 瀏覽器呈現與原始碼 36.2 語法規則 36.3 標籤與屬性 36.4 解析", " 36 HTML 本章為 Munzert et al. (2014) 第 2 章內容。 HTML 為 the HyperText Markup Language 的縮寫。 在節 36.1，將會使用瀏覽器呈現網頁原始碼（source code），並查看特定的 HTML 元素。 在節 36.2，將會介紹標記語言的邏輯與 HTML 的語法規則。 在節 36.3，將會呈現 HTML 最重要的詞彙。 在節 36.4，將會討論重構 HTML 結構及語法的過程，即解析（parsing），與其如何幫助我們從網頁文檔提取資訊。 36.1 瀏覽器呈現與原始碼 HTML 檔為純文字檔（plain text file）。HTML markup 可以用來定義文檔哪些部分該是標題、連結、表格，或其他格式。這些標記會告訴瀏覽器文檔如何組織，與其各部分的功能。 我們在網頁瀏覽器中所看到過的是轉譯過的 HTML 檔，例如網頁 http://www.r-datacollection.com/materials/html/OurFirstHTML.html ，呈現在我們眼前的是一句話：“I am your first HTML-file!”，而實際上有如此的原始碼： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;First HTML&lt;/title&gt; &lt;!-- 此網頁的 title --&gt; &lt;/head&gt; &lt;body&gt; I am your first HTML-file! &lt;/body&gt; &lt;/html&gt; 36.2 語法規則 36.2.1 標籤、元素與屬性 透過可以被瀏覽器讀懂的標籤（tags），純文字檔可以變成 HTML 文件。 標籤由 &lt; 與 &gt; 包著，分成兩種，其一為 start tags，又稱為 opening tags，例如 &lt;title&gt;；其二為 end tags，又稱為 closing tags，與 start tags 不同的是多了 /，如 &lt;/title&gt;。 元素（elements）則包含 start tags、contents 與 end tags，6如： &lt;title&gt;First HTML&lt;/title&gt; 不過，並非所有的元素都會有一個 start tag 與一個 end tag。例如 &lt;br&gt; 意思是換行，就不會有另一個 &lt;/br&gt; 為 end tag。如果元素形為 &lt;body/&gt;，在 start tag 中就以 / 結束，則稱為空元素，因為沒有任何 content。HTML 的標籤的大小寫並不重要，因此 &lt;tagNAME&gt;、&lt;TAGNAME&gt; 或 &lt;tagname&gt; 都是等價的，但一般我們會寫成全部都是小寫的形式。 此外，標籤還有一特色為屬性（attributes），通常放在 start tag 的標籤名稱之後。一個屬性會有一個屬性名稱與一個值，例如： &lt;a href=&quot;http://www.r-datacollection.com/&quot;&gt;Link to Homepage&lt;/a&gt; 其中的 href=\"http://www.r-datacollection.com/\"就是指定 anchor &lt;a&gt; 的屬性，而 href 就是屬性名稱，以單引號或雙引號包著的 \"http://www.r-datacollection.com/\" 即是屬性的值。標籤也能有多個屬性，只要用空格隔開即可。 36.2.2 樹結構 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;First HTML&lt;/title&gt; &lt;/head&gt; &lt;body&gt; I am your first HTML-file! &lt;/body&gt; &lt;/html&gt; 以上述範例而言，html 包著 &lt;head&gt; 與 &lt;body&gt;，&lt;head&gt; 則包著 &lt;title&gt;，就像樹結構（tree structure）一樣，如圖 36.1。 Figure 36.1: 樹結構。 36.2.3 註釋 HTML 可以加入註釋（comments），以 &lt;!-- 開頭，--&gt; 結尾，中間的文字會被忽略，不會被呈現在瀏覽器上，如： &lt;!-- Hi, I am a comment. I can span several lines and I am able to store additional content that is not displayed by the browser. --&gt; 36.2.4 保留與特殊字元 HTML 的標籤使用 &lt; 與 &gt;，那我們要在正文使用 &lt; 或 &gt; 時怎麼辦？ 對於這些會在 HTML 語法中使用的字元，如果要在 content 中使用它們，就要透過對應的 character entities。Entities 以 &amp; 開頭，以 ; 結尾。例如，如果我們希望瀏覽器可以顯示 “5 &lt; 6 but 7 &gt; 3”，不應該使用 &lt;p&gt;5 &lt; 6 but 7 &gt; 3 &lt;/p&gt; 而應該使用 &lt;p&gt;5 &amp;lt; 6 but 7 &amp;gt; 3 &lt;/p&gt; Table 36.1: HTML entities. 字元 Entity number Entity name 意思 ” &amp;#34; &amp;quot; quotation mark ’ &amp;#39; &amp;apos; apostrophe &amp; &amp;#38; &amp;amp; ampersand &lt; &amp;#60; &amp;lt; less than &gt; &amp;#62; &amp;gt; greater than &amp;#160; &amp;nbsp; non-breaking space á &amp;#224; &amp;agrave; a with grave accent ♡ &amp;#224; &amp;hearts; heart 36.2.5 文件類型定義 36.2.6 空白與換行 36.3 標籤與屬性 36.3.1 The anchor tag &lt;a&gt; 36.3.2 The metadata tag &lt;meta&gt; 36.3.3 The external reference tag &lt;link&gt; 36.3.4 Emphasizing tags &lt;b&gt;, &lt;i&gt;, &lt;strong&gt; 36.3.5 The paragraphs tag &lt;p&gt; 36.3.6 Heading tags &lt;h1&gt;, &lt;h2&gt;, &lt;h3&gt;,… 36.3.7 Listing content with &lt;ul&gt;, &lt;ol&gt;, and &lt;dl&gt; 36.3.8 The organizational tags &lt;div&gt; and &lt;span&gt; 36.3.9 The &lt;form&gt; tag and its companions 36.3.10 The foreign script tag &lt;script&gt; 36.3.11 Table tags &lt;table&gt;, &lt;tr&gt;, &lt;td&gt;, and &lt;th&gt; 36.4 解析 36.4.1 Discarding nodes 36.4.2 提取資訊 參考文獻 "],["xml-與-json.html", "37 XML 與 JSON", " 37 XML 與 JSON "],["xpath.html", "38 XPath", " 38 XPath "],["http.html", "39 HTTP", " 39 HTTP "],["ajax.html", "40 AJAX", " 40 AJAX "],["sql-與關聯性資料庫.html", "41 SQL 與關聯性資料庫", " 41 SQL 與關聯性資料庫 "],["正規表達式.html", "42 正規表達式", " 42 正規表達式 "],["網路爬蟲.html", "43 網路爬蟲", " 43 網路爬蟲 在節 3.2.3 已簡介過以 rvest 抓取網路資料的方式。本章 "],["langmodeling.html", "44 語言與建模", " 44 語言與建模 本章為 Hvitfeldt and Silge (2021) 第 1 章內容。 參考文獻 "],["斷詞.html", "45 斷詞", " 45 斷詞 "],["ref.html", "參考文獻", " 參考文獻 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
